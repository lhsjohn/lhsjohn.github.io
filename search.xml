<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ActiveMQ]]></title>
    <url>%2F2018%2F08%2F17%2FActiveMQ%2F</url>
    <content type="text"><![CDATA[What is ActiveMQ? ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。主要特点： 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务) 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA 支持通过JDBC和journal提供高速的消息持久化 从设计上保证了高性能的集群,客户端-服务器,点对点 支持Ajax 支持与Axis的整合 可以很容易得调用内嵌JMS provider,进行测试 ActiveMQ的消息形式对于消息的传递有两种类型： 一种是点对点的，即一个生产者和一个消费者一一对应； 另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · StreamMessage – Java原始值的数据流 · MapMessage–一套名称-值对 · TextMessage–一个字符串对象 · ObjectMessage–一个序列化的 Java对象 · BytesMessage–一个字节的数据流 使用测试(未整合Spring)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public void testQueueProducer() throws Exception &#123; // 1.创建一个连接工厂对象,需要指定服务的ip以及端口 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.1.128:61616&quot;); // 2.使用工厂对象来创建一个Connection对象 Connection connection = connectionFactory.createConnection(); // 3.开启连接，调用Connection对象的start方法 connection.start(); // 4.创建一个Session对象 // 第一个参数:是否开启事务。如果true开启事务，第二个无意义。一般不开启false // 第二个参数：如果不开启事务。应答模式，一般是自动应答或者手动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5.使用Session对象创建一个Destination对象。两种形式queue、topic Queue queue = session.createQueue(&quot;spring-queue&quot;); // 6.使用Session对象创建一个Producer对象 MessageProducer producer = session.createProducer(queue); // 7.创建一个Message对象，可以使用TextMessage。 /* * TextMessage textMessage=new ActiveMQTextMessage(); * textMessage.setText(&quot;hello Activemq&quot;); */ TextMessage textMessage = session.createTextMessage(&quot;hello Activemq&quot;); // 8.发送消息 producer.send(textMessage); // 9.关闭资源 producer.close(); session.close(); connection.close();&#125;public void testQueueConsumer() throws Exception &#123; // 创建一个ConnectionFactory对象连接MQ服务器 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.1.128:61616&quot;); // 创建一个连接对象 Connection connection = connectionFactory.createConnection(); // 开启连接 connection.start(); // 使用Connection对象创建一个Session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建一个Destinatiion对象，queue对象 Queue queue = session.createQueue(&quot;spring-queue&quot;); // 使用Session对象创建一个消费者对象 MessageConsumer consumer = session.createConsumer(queue); // 接收消息 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; // 打印结果 TextMessage textMessage = (TextMessage) message; String text; try &#123; text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 等待接收消息 System.in.read(); // 关闭资源 consumer.close(); session.close(); connection.close();&#125;public void testTopicProducer() throws Exception &#123; // 1.创建一个连接工厂对象,需要指定服务的ip以及端口 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.1.128:61616&quot;); // 2.使用工厂对象来创建一个Connection对象 Connection connection = connectionFactory.createConnection(); // 3.开启连接，调用Connection对象的start方法 connection.start(); // 4.创建一个Session对象 // 第一个参数:是否开启事务。如果true开启事务，第二个无意义。一般不开启false // 第二个参数：如果不开启事务。应答模式，一般是自动应答或者手动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5.使用Session对象创建一个Destination对象。两种形式queue、topic Topic topic = session.createTopic(&quot;test-topic&quot;); // 6.使用Session对象创建一个Producer对象 MessageProducer producer = session.createProducer(topic); // 7.创建一个Message对象，可以使用TextMessage。 /* * TextMessage textMessage=new ActiveMQTextMessage(); * textMessage.setText(&quot;hello Activemq&quot;); */ TextMessage textMessage = session.createTextMessage(&quot;topicMessage&quot;); // 8.发送消息 producer.send(textMessage); // 9.关闭资源 producer.close(); session.close(); connection.close();&#125;public void testTopicConsumer() throws Exception &#123; // 创建一个ConnectionFactory对象连接MQ服务器 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://192.168.1.128:61616&quot;); // 创建一个连接对象 Connection connection = connectionFactory.createConnection(); // 开启连接 connection.start(); // 使用Connection对象创建一个Session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建一个Destinatiion对象，queue对象 Topic topic = session.createTopic(&quot;test-topic&quot;); // 使用Session对象创建一个消费者对象 MessageConsumer consumer = session.createConsumer(topic); // 接收消息 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; // 打印结果 TextMessage textMessage = (TextMessage) message; String text; try &#123; text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println(&quot;topic 消费者3已经启动&quot;); // 等待接收消息 System.in.read(); // 关闭资源 consumer.close(); session.close(); connection.close();&#125; 作者：lhsjohn]]></content>
      <categories>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SolrCloud，一个分布式搜索方案]]></title>
    <url>%2F2018%2F08%2F14%2FSolrCloud%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近搞分布式搜索服务的实现，一直受到性能的瓶颈制约，单机版的solr服务对于少数用户体验还可以，但是涉及到几千的并发的时候，难免会造成性能的突然下降。 下面是一套利用solr和zookeeper实现的分布式搜索架构方案 Solr集群的系统架构 三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud。 索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。用户发起索引请求分别从shard1和shard2上获取，解决高并发问题。 Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。比如：针对商品信息搜索可以创建一个collection。 collection=shard1+shard2+….+shardX 每个Core是Solr中一个独立运行单位，提供 索引和搜索服务。一个shard需要由一个Core或多个Core组成。由于collection由多个shard组成所以collection一般由多个core组成。 Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。 Collection的逻辑分片。每个Shard被化成一个或者多个replication，通过选举确定哪个是Leader。 下面是我的实现方案 下面是大体的实现步骤 第一步：创建四个tomcat实例。每个tomcat运行在不同的端口。8180、8280、8380、8480 第二步：部署solr的war包。把单机版的solr工程复制到集群中的tomcat中。 第三步：为每个solr实例创建一个对应的solrhome。使用单机版的solrhome复制四份。 第四步：需要修改solr的web.xml文件。把solrhome关联起来。 第五步：配置solrCloud相关的配置。每个solrhome下都有一个solr.xml，把其中的ip及端口号配置好。 第六步：让zookeeper统一管理配置文件。需要把solrhome/collection1/conf目录上传到zookeeper。上传任意solrhome中的配置文件即可。 第七步：修改tomcat/bin目录下的catalina.sh 文件，关联solr和zookeeper。把此配置添加到配置文件中：JAVA_OPTS=”-DzkHost=192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183” 第八步：启动每个tomcat实例。要包装zookeeper集群是启动状态。 第九步：访问集群 第十步：创建新的Collection进行分片处理。http://192.168.25.154:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 第十一步：删除不用的Collection。http://192.168.25.154:8180/solr/admin/collections?action=DELETE&amp;name=collection1 在java中我们可以使用solrJ来对集群进行操作 使用步骤：第一步：把solrJ相关的jar包添加到工程中。 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。 第三步：需要设置DefaultCollection属性。 第四步：创建一SolrInputDocument对象。 第五步：向文档对象中添加域 第六步：把文档对象写入索引库。 第七步：提交。 最后来一段测试java代码 1234567891011121314151617181920@Test public void testSolrCloudAddDocument() throws Exception &#123; // 第一步：把solrJ相关的jar包添加到工程中。 // 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。 //参数是zookeeper的地址列表，使用逗号分隔 CloudSolrServer solrServer = new CloudSolrServer(&quot;192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot;); // 第三步：需要设置DefaultCollection属性。 solrServer.setDefaultCollection(&quot;collection2&quot;); // 第四步：创建一SolrInputDocument对象。 SolrInputDocument document = new SolrInputDocument(); // 第五步：向文档对象中添加域 document.addField(&quot;item_title&quot;, &quot;测试商品&quot;); document.addField(&quot;item_price&quot;, &quot;100&quot;); document.addField(&quot;id&quot;, &quot;test001&quot;); // 第六步：把文档对象写入索引库。 solrServer.add(document); // 第七步：提交。 solrServer.commit(); &#125; 完毕！ 作者: lhsjohn]]></content>
      <tags>
        <tag>java</tag>
        <tag>solr+zookeeper</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastdfs]]></title>
    <url>%2F2018%2F08%2F11%2Ffastdfs%2F</url>
    <content type="text"><![CDATA[FastDFS是C语言开发，建议在linux上运行，下面使用Centos6.4作为安装环境。安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ 安装libeventFastDFS依赖libevent库，需要安装： yum -y install libevent 安装libfastcommonlibfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下 cd /usr/local tar -zxvf libfastcommonV1.0.7.tar.gz cd libfastcommon-1.0.7./make.sh ./make.sh install 注意：libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。 tracker编译安装将FastDFS_v5.05.tar.gz拷贝至/usr/local/下 tar -zxvf FastDFS_v5.05.tar.gz cd FastDFS ./make.sh ./make.sh install 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下。 配置安装成功后进入/etc/fdfs目录：拷贝一份新的tracker配置文件： cp tracker.conf.sample tracker.conf 修改tracker.confvi tracker.confbase_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFS 启动/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart启动的日志显示先停止5619进程（实际环境不是5619） 设置开机启动 vim /etc/rc.d/rc.local 将运行命令行添加进文件：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 下面安装FastDFS-storage 安装libevent同tracker 安装libfastcommon同tracker 配置安装成功后进入/etc/fdfs目录： 拷贝一份新的storage配置文件：cp storage.conf.sample storage.conf 修改storage.conf vi storage.conf 1234567891011修改storage.confvi storage.confgroup_name=group1base_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFSstore_path0=/home/yuqing/FastDFS改为：store_path0=/home/FastDFS/fdfs_storage#如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......tracker_server=192.168.101.3:22122 #配置tracker服务器:IP#如果有多个则配置多个trackertracker_server=192.168.101.4:22122 启动/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 设置开机启动 vim /etc/rc.d/rc.local 将运行命令行添加进文件：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart tracker.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711 基本配置disable#func：配置是否生效#valu：true、falsedisable=falsebind_addr#func：绑定IP#valu：IP地址bind_addr=192.168.6.102port#func：服务端口#valu：端口整数值port=22122connect_timeout#func：连接超时#valu：秒单位正整数值connect_timeout=30network_timeout#func：网络超时#valu：秒单位正整数值network_timeout=60base_path#func：Tracker数据/日志目录地址#valu：路径base_path=/home/michael/fdfs/base4trackermax_connections#func：最大连接数#valu：正整数值max_connections=256work_threads#func：线程数，通常设置CPU数#valu：正整数值work_threads=4store_lookup#func：上传文件的选组方式。#valu：0、1或2。# 0：表示轮询# 1：表示指定组# 2：表示存储负载均衡（选择剩余空间最大的组）store_lookup=2store_group#func：指定上传的组，如果在应用层指定了具体的组，那么这个参数将不会起效。另外如果store_lookup如果是0或2，则此参数无效。#valu：group1等store_group=group1store_server#func：上传服务器的选择方式。(一个文件被上传后，这个storage server就相当于这个文件的storage server源，会对同组的storage server推送这个文件达到同步效果)#valu：0、1或2# 0: 轮询方式（默认）# 1: 根据ip 地址进行排序选择第一个服务器（IP地址最小者）# 2: 根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority），优先级值越小优先级越高。store_server=0store_path#func：上传路径的选择方式。storage server可以有多个存放文件的base path（可以理解为多个磁盘）。#valu：# 0: 轮流方式，多个目录依次存放文件# 2: 存储负载均衡。选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的）store_path=0download_server#func：下载服务器的选择方式。#valu：# 0：轮询（默认）# 1：IP最小者# 2：优先级排序（值最小的，优先级最高。）download_server=0reserved_storage_space#func：保留空间值。如果某个组中的某个服务器的剩余自由空间小于设定值，则文件不会被上传到这个组。#valu：# G or g for gigabyte# M or m for megabyte# K or k for kilobytereserved_storage_space=1GBlog_level#func：日志级别#valu：# emerg for emergency# alert# crit for critical# error# warn for warning# notice# info for information# debug for debugginglog_level=inforun_by_group / run_by_user#func：指定运行该程序的用户组#valu：用户组名或空run_by_group=#func：#valu：run_by_user=allow_hosts#func：可以连接到tracker server的ip范围。可设定多个值。#valuallow_hosts=check_active_interval#func：检测 storage server 存活的时间隔，单位为秒。# storage server定期向tracker server 发心跳，# 如果tracker server在一个check_active_interval内还没有收到storage server的一次心跳，# 那边将认为该storage server已经下线。所以本参数值必须大于storage server配置的心跳时间间隔。# 通常配置为storage server心跳时间间隔的2倍或3倍。check_active_interval=120thread_stack_size#func：设定线程栈的大小。 线程栈越大，一个线程占用的系统资源就越多。# 如果要启动更多的线程（V1.x对应的参数为max_connections，V2.0为work_threads），可以适当降低本参数值。#valu：如64KB，默认值为64，tracker server线程栈不应小于64KBthread_stack_size=64KBstorage_ip_changed_auto_adjust#func：这个参数控制当storage server IP地址改变时，集群是否自动调整。注：只有在storage server进程重启时才完成自动调整。#valu：true或falsestorage_ip_changed_auto_adjust=true2 同步storage_sync_file_max_delay#func：同组storage服务器之间同步的最大延迟时间。存储服务器之间同步文件的最大延迟时间，根据实际情况进行调整#valu：秒为单位，默认值为1天（24*3600）#sinc：v2.0storage_sync_file_max_delay=86400storage_sync_file_max_time#func：存储服务器同步一个文件需要消耗的最大时间，缺省为300s，即5分钟。#sinc：v2.0storage_sync_file_max_time=300sync_log_buff_interval#func：同步或刷新日志信息到硬盘的时间间隔。注意：tracker server 的日志不是时时写硬盘的，而是先写内存。#valu：以秒为单位sync_log_buff_interval=103 trunk 和 slot#func：是否使用trunk文件来存储几个小文件#valu：true或false#sinc：v3.0use_trunk_file=false#func：最小slot大小#valu：&lt;= 4KB，默认为256字节#sinc：v3.0slot_min_size=256#func：最大slot大小#valu：&gt;= slot_min_size，当小于这个值的时候就存储到trunk file中。默认为16MB。#sinc：v3.0slot_max_size=16MB#func：trunk file的size#valu：&gt;= 4MB，默认为64MB#sinc：v3.0trunk_file_size=64MB4 HTTP 相关是否启用 HTTP#func：HTTP是否生效#valu：true或falsehttp.disabled=falseHTTP 服务器端口号#func：tracker server上的http port#valu：#note：只有http.disabled=false时才生效http.server_port=7271检查Storage存活状态的间隔时间（心跳检测）#func：检查storage http server存活的间隔时间#valu：单位为秒#note：只有http.disabled=false时才生效http.check_alive_interval=30心跳检测使用的协议方式#func：检查storage http server存活的方式#valu：# tcp：连接到storage server的http端口，不进行request和response。# http：storage check alive url must return http status 200.#note：只有http.disabled=false时才生效http.check_alive_type=tcp检查 Storage 状态的 URI#func：检查storage http server是否alive的uri/url#note：只有http.disabled=false时才生效http.check_alive_uri=/status.html]]></content>
      <categories>
        <category>fastdfs</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
        <tag>fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pom文件]]></title>
    <url>%2F2018%2F08%2F08%2FPom%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.e3mall&lt;/groupId&gt; &lt;artifactId&gt;e3-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt; &lt;jackson.version&gt;2.4.2&lt;/jackson.version&gt; &lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;httpclient.version&gt;4.3.5&lt;/httpclient.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;joda-time.version&gt;2.5&lt;/joda-time.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt; &lt;pagehelper.version&gt;3.4.2-fix&lt;/pagehelper.version&gt; &lt;jsqlparser.version&gt;0.9.1&lt;/jsqlparser.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;jedis.version&gt;2.7.2&lt;/jedis.version&gt; &lt;solrj.version&gt;4.10.3&lt;/solrj.version&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;zookeeper.version&gt;3.4.7&lt;/zookeeper.version&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt; &lt;activemq.version&gt;5.11.2&lt;/activemq.version&gt; &lt;freemarker.version&gt;2.3.23&lt;/freemarker.version&gt; &lt;quartz.version&gt;2.2.2&lt;/quartz.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 时间操作组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Apache工具组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Jackson Json处理工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;!--more--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- quartz任务调度框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.paginator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 文件上传组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- solr客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;$&#123;solrj.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;$&#123;freemarker.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(四)-----单件模式]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E5%9B%9B)-----%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单件模式的定义确保一个类只有一个实例，并提供一个全局访问点。 类图 1.其中uniqueInstance 变量持有唯一的单间实例 2.getInstance()方法是静态的，这意味着它是一个类方法，所以可以在代码的任何地方使用Singleton.getnstance()访问它。这样和访问全局变量一样，只是多了一个优点：单件可以延迟实例化。 3.单件模式的类也可以是一般的类，具有一般的数据和方法。 下面是一个单件模式的经典实现： 1234567891011121314151617181920212223 Public class Singleton()&#123;//利用一个静态变量来记录Singleton类的唯一实例Private static Singleton uniqueInstance;//这里是用到的其他的有用的实例化的变量//把构造器类设置为私有的，只有自Singleton类内才可以调用构造器Private Singleton() &#123; &#125; //用getInstance()方法实例化对象，并返回这个对象的实例 Public static Singleton getInstance()&#123; If(uniqueInstance==null) &#123; uniqueInstance=new Singleton(); &#125; Return uniqueInstance; &#125;//这里是其他有用的方法&#125; 单件模式的多线程之伤 现在我们知道，绝大多数的应用程序都是多线程的，那么我们如果采用上面经典的单例模式的实现化，遇到多线程情况，就会遇到很大的麻烦了 下面我们来处理这种麻烦，处理多线程 在这里只需要我们把getInstance() 变成同步(synchronized)方法即可。 1234567891011121314151617181920212223 Public class Singleton()&#123;//利用一个静态变量来记录Singleton类的唯一实例 Private static Singleton uniqueInstance;//这里是用到的其他的有用的实例化的变量 //把构造器类设置为私有的，只有自Singleton类内才可以调用构造器Private Singleton() &#123; &#125; //用getInstance()方法实例化对象，并返回这个对象的实例Public static synchronized Singleton getInstance()&#123; if(uniqueInstance==null) &#123; uniqueInstance=new Singleton();&#125; Return uniqueInstance; &#125;//这里是其他有用的方法&#125; 通过增加synchronized 关键字到getInstance()方法中,我们迫使每个线程在进入这个方法之前，要先等候别的线程离开该方法。也就是说，不会有两个线程可以同时进入这个方法。 但这里需要我们注意的是，尽管用这个方式可以很简单的解决了上面的问题，但是这种方法却会降低应用程序的性能。 所以我们考虑一下，能否改善多线程呢？ 下面是我们可以采取的几种选择： 1.如果getInstance()的性能对于应用程序不是很关键，就什么也不用去做，直接可以采取上面所说的加上 synchronized 的做法。 2.使用”急切”创建实例，而不用延迟实例化的方法 123456789101112131415 Public class Singleton&#123; //在静态初始化器中创建单件，这段代码保证了线程安全。Private static Singleton uniqueInstace= new Singleton(); Private Singleton () &#123;&#125;Public static Singleton getInstance() &#123; Return uniqueInstance; &#125; &#125; 采用这个做法，我们依赖JVM 在加载这个类时马上创建此唯一的单件实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定会创建此实例。 3.用“双重检查加锁”，在getInstance()中减少同步 利用双重检查加锁，首先检查是否实例已经创建了，如果尚未创建，”才”进行同步，这样一来，只有第一次会同步，这正是我们想要的。 123456789101112131415161718192021 Public class Singleton&#123; //在静态初始化器中创建单件，这段代码保证了线程安全。 Private static Singleton uniqueInstace; Private Singleton () &#123;&#125; Public static Singleton getInstance() &#123; If(uniqueInstance ==null)&#123; Synchronized(Singleton.class) &#123; If(uniqueInstance ==null)&#123; uniqueInstance =new Singleton(); &#125; &#125; &#125; Return uniqueInstance; &#125;&#125; 注意如果使用的是JVM1.2或之前的版本，我们必须建立单间注册表，以免垃圾回收器将单件回收。 总的来说，单件模式相对于其他模式来说类图结构虽然没有那么复杂，但它却扮演着非常重要的角色，在保证应用程序的稳定性和安全性方面起着非常重要的作用。 作者:lhsjohn]]></content>
      <categories>
        <category>设计模式</category>
        <category>java</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道算法题]]></title>
    <url>%2F2018%2F08%2F06%2F%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法题:请用js根据网站用户的内裤颜色调改变网站主题文字颜色。]]></content>
      <categories>
        <category>段子</category>
      </categories>
      <tags>
        <tag>段子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threadqiushi.py]]></title>
    <url>%2F2018%2F08%2F06%2Fthreadqiushi.py%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#!/usr/bin/env python# -*- coding:utf-8 -*-# 使用了线程库import threading# 队列from Queue import Queue# 解析库from lxml import etree# 请求处理import requests# json处理import jsonimport timeclass ThreadCrawl(threading.Thread): def __init__(self, threadName, pageQueue, dataQueue): #threading.Thread.__init__(self) # 调用父类初始化方法 super(ThreadCrawl, self).__init__() # 线程名 self.threadName = threadName # 页码队列 self.pageQueue = pageQueue # 数据队列 self.dataQueue = dataQueue # 请求报头 self.headers = &#123;&quot;User-Agent&quot; : &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&quot;&#125; def run(self): print &quot;启动 &quot; + self.threadName while not CRAWL_EXIT: try: # 取出一个数字，先进先出 # 可选参数block，默认值为True #1. 如果对列为空，block为True的话，不会结束，会进入阻塞状态，直到队列有新的数据 #2. 如果队列为空，block为False的话，就弹出一个Queue.empty()异常， page = self.pageQueue.get(False) url = &quot;http://www.qiushibaike.com/8hr/page/&quot; + str(page) +&quot;/&quot; #print url content = requests.get(url, headers = self.headers).text time.sleep(1) self.dataQueue.put(content) #print len(content) except: pass print &quot;结束 &quot; + self.threadName &lt;!--more--&gt;class ThreadParse(threading.Thread): def __init__(self, threadName, dataQueue, filename, lock): super(ThreadParse, self).__init__() # 线程名 self.threadName = threadName # 数据队列 self.dataQueue = dataQueue # 保存解析后数据的文件名 self.filename = filename # 锁 self.lock = lock def run(self): print &quot;启动&quot; + self.threadName while not PARSE_EXIT: try: html = self.dataQueue.get(False) self.parse(html) except: pass print &quot;退出&quot; + self.threadName def parse(self, html): # 解析为HTML DOM html = etree.HTML(html) node_list = html.xpath(&apos;//div[contains(@id, &quot;qiushi_tag&quot;)]&apos;) for node in node_list: # xpath返回的列表，这个列表就这一个参数，用索引方式取出来，用户名 username = node.xpath(&apos;./div/a/@title&apos;)[0] # 图片连接 image = node.xpath(&apos;.//div[@class=&quot;thumb&quot;]//@src&apos;)#[0] # 取出标签下的内容,段子内容 content = node.xpath(&apos;.//div[@class=&quot;content&quot;]/span&apos;)[0].text # 取出标签里包含的内容，点赞 zan = node.xpath(&apos;.//i&apos;)[0].text # 评论 comments = node.xpath(&apos;.//i&apos;)[1].text items = &#123; &quot;username&quot; : username, &quot;image&quot; : image, &quot;content&quot; : content, &quot;zan&quot; : zan, &quot;comments&quot; : comments &#125; # with 后面有两个必须执行的操作：__enter__ 和 _exit__ # 不管里面的操作结果如何，都会执行打开、关闭 # 打开锁、处理内容、释放锁 with self.lock: # 写入存储的解析后的数据 self.filename.write(json.dumps(items, ensure_ascii = False).encode(&quot;utf-8&quot;) + &quot;\n&quot;)CRAWL_EXIT = FalsePARSE_EXIT = Falsedef main(): # 页码的队列，表示20个页面 pageQueue = Queue(20) # 放入1~10的数字，先进先出 for i in range(1, 21): pageQueue.put(i) # 采集结果(每页的HTML源码)的数据队列，参数为空表示不限制 dataQueue = Queue() filename = open(&quot;duanzi.json&quot;, &quot;a&quot;) # 创建锁 lock = threading.Lock() # 三个采集线程的名字 crawlList = [&quot;采集线程1号&quot;, &quot;采集线程2号&quot;, &quot;采集线程3号&quot;] # 存储三个采集线程的列表集合 threadcrawl = [] for threadName in crawlList: thread = ThreadCrawl(threadName, pageQueue, dataQueue) thread.start() threadcrawl.append(thread) # 三个解析线程的名字 parseList = [&quot;解析线程1号&quot;,&quot;解析线程2号&quot;,&quot;解析线程3号&quot;] # 存储三个解析线程 threadparse = [] for threadName in parseList: thread = ThreadParse(threadName, dataQueue, filename, lock) thread.start() threadparse.append(thread) # 等待pageQueue队列为空，也就是等待之前的操作执行完毕 while not pageQueue.empty(): pass # 如果pageQueue为空，采集线程退出循环 global CRAWL_EXIT CRAWL_EXIT = True print &quot;pageQueue为空&quot; for thread in threadcrawl: thread.join() print &quot;1&quot; while not dataQueue.empty(): pass global PARSE_EXIT PARSE_EXIT = True for thread in threadparse: thread.join() print &quot;2&quot; with lock: # 关闭文件 filename.close() print &quot;谢谢使用！&quot;if __name__ == &quot;__main__&quot;: main()]]></content>
      <categories>
        <category>爬虫</category>
        <category>python</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活带有主观性 —— 二刷《当幸福来敲门》]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%94%9F%E6%B4%BB%E5%B8%A6%E6%9C%89%E4%B8%BB%E8%A7%82%E6%80%A7%E4%BA%8C%E5%88%B7%E3%80%8A%E5%BD%93%E5%B9%B8%E7%A6%8F%E6%9D%A5%E6%95%B2%E9%97%A8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[“黑夜给了我黑色的眼睛，我却用它寻找光明”。这是顾城的一句经典语录，如果可以的话，我想把这个经典语录赋予给这个拥有灵魂的电影。 这部电影带给你最大的震撼或许就是，不同的成长阶段，你对他的感受会有所不同吧。 第一次观看这部电影大概是在三年前，高二的时候。应试型的教育形式一遍又一遍的在你身边重复显现，或许就真的变成了考试的机器一般，学习与考试，你的时间完全不在你手上，做不了自己喜欢的事情，成绩再好也毫无意义。 也就在这个状态之下，我观看了这么一部电影。这或许也是看到开头就能知道故事结局的一部电影，但是它确实有足够的魅力来吸引人们去观看它，去思考我们眼睛看不到的地方。 “克里斯·加德纳，生活在旧金山的黑人男青年，靠做推销员养着老婆还有幼子。克里斯从没觉得日子过得很幸福，当然也没很痛苦，就跟美国千千万普通男人一样过着平淡的生活，直到有一天，一系列突如其来的变故才让克里斯知道，原来平淡的日子有多珍贵。 首先，他丢了工作，公司裁员让他丢了饭碗。克里斯从此遭遇了一连串重大打击，妻子因忍受不了长期的贫困生活愤而出走，连六岁大的儿子（杰登·史密斯）也一同带走。没过多久，妻子又把儿子还给了克里斯，从此克里斯不仅要面对失业的困境，还要独立抚养儿子。没过多久，克里斯因长期欠交房租被房东赶出家门，带着儿子流落街头。在接下的两三年中，这对苦命父子的住所从纸皮箱搬到公共卫生间。克里斯坚强面对困境时刻打散工赚钱，同时也努力培养孩子乐观面对困境的精神，父子俩日子虽苦，但还是能快乐生活。一次，克里斯在停车场遇见一个开高级跑车的男人，克里斯问他做什么工作才能过上这样的生活，那男人告诉他自己是做股票经纪人的，克里斯从此就决定自己要做一个出色的股票经纪人，和儿子过上好日子。完全没有股票知识的克里斯靠着毅力在华尔街一家股票公司当上学徒，头脑灵活的他很快就掌握了股票市场的知识，随后开上了自己的股票经纪公司，最后成为百万富翁。一路上克里斯经历了不少挫折，但是年幼的儿子每次都能给予他最大的鼓励，两父子相互扶持最终完成了又一个美国梦。” 克里斯是幸运的的也是不幸运的。 他的不幸运来源于他之前的穷困潦倒，虽然这部电影并没有给我们介绍他之前的背景，我们也就无法得知他现在处境的原因，电影的开头只是给我们说明了确实有这么一个处境，至于其他的部分，就由你来想吧! 或许是他年轻时候的不努力也或者是他年轻时因为某些变故造成的自己与机会的远离。但是在那个年代，机会似乎也没有那么多。 高二的时候看这部影片，确实是一部实实在在的励志电影，一个人靠着自己坚定的意志力和常人难以接受的决定来改变自己的人生。给我当时增加了不少的动力，这些动力，来源于他的勇敢。 成功一帆风顺固然很好，但是如果你走的道路太顺利了，只能说明这条路很多人和你一样走过。 克里斯是一个真正的爷们，他的刚强，并不是一些人眼中所说的身强体壮，而是他重重的责任感以及永不抱怨的精神。即便在最为穷困的时候，也给自己孩子买了心爱的生日礼物，带着孩子吃甜点而自己也只是在旁边看着，妻子离她而去，自己也毅然而然扛起了生活的重担。看电影的时候都会为他感到着急，为什么运气会那么差，“屋漏偏逢天阴雨”，又看到屏幕上的一个个的弹幕，有庆幸自己成功的，也有刚失败激励自己重头再来的，只能说是，事态纷杂，每个人的经历都不一样，获得真正意义上的成功，又有几个呢？ 他的幸运是让他在人生最为低谷的时候抓住了机会，我们看到的，机会不是别人送来的，是他自己争取来的，有他的努力，当然与他与人坦诚相处的态度也是分不开的。 今天又把这部电影看了一遍，思考的角度与当年却有些不同。 现在，我觉得克里斯是不幸的。 首先是对于成功的定义，我觉得这是一部被资本化了的电影，首先故事的背景就是发生在资本化的美国，人们以金钱来衡量自己的财富，作为判断自己的人生成败的重要标准。 这种价值观，太过于“唯物”。 也许大家沉浸于他的改变中无所自拔，想象着这大概就是生活最为美好的情况。但我们同时也注意到，克里斯似乎并没有朋友，没有知己，完全是一个人在单打独斗，哪怕是在自己最为穷困潦倒的时刻，也找不到一个可以歇息的地方，只能带着自己的小孩子去睡车站厕所。同时他也有一段比较失败的婚姻，生活的窘迫逼走了他的妻子，只有他和儿子相依为命，一个人奔走于城市街头，拼命寻找自己的机遇。 最后他虽然取得了物质上的成功，但他却也早已经失去了永远无法挽回的东西。这样的人生对于克里斯是幸福的吗？ 他的“成功”之外，还有很重要的一点，就是他的天赋。 要是克里斯没那份数学天赋呢？他要是玩不来魔方呢？作为一个天才，他的奋斗很感人。但真相是，大部分人只是普通人。他们绝对不可能像克里斯一样去做“股票经纪人”，但是即便如此，也不能一棒子打死就说是天赋决定了他的成功。 天赋或许是你开启一扇门的钥匙，但前提是你要找对那一扇门。有天赋的人相比于其他人来说，只是多了一条捷径。 更多普通人的成功，则是靠的自己的兴趣和热爱 。 只有你真正的去热爱一样东西，在别人眼里，你所经历的苦只是放在他们身上他们认为的苦而已，真正沉浸于其中的喜悦，别人不得而知。 有追求，有意义，有妥协。人生的黄金三词，妥协使你低姿态开启人生，以大众视角观察周围的世界，去发现新的机遇。有追求则是投身于自己真正喜欢的事业，与强者为伴，不断学习进步，同时增强自身的能力，抓住发现的机遇，敢于做出决定，两个字就是果断，三个字就是执行力。 有意义是建立在其他两个词的基础之上的，这种“意义”，不仅仅是自己价值的实现，不仅仅是看到自己给周围带来改变时的那种成就感，也兼顾人生的其他方面，包括社交、精神享受等种种方面。 无论是有天赋的人，还是有着一腔热血的人，或是平平凡凡的人，都应该脚踏实地，一步一个脚印，胜不骄败不馁，要真正认清楚自己所处的现实情况。不要对一时间的”成就”蒙蔽住了双眼，记住，你所谓的成就并不一定是别人眼中认为的成功。 因为，对成功这个词的定义，每个人是不一样的。但是对于努力这个词，每个人一定会是一样的。 永远也不要抱怨，不去计较不公平，只要自己肯做出改变，一切皆有可能。 这应该是我在大二结束之际二刷这部电影的收获了。随着你的成长，观察问题的视野和角度也在不断变换。 毕竟每个人都有每个人不同看待问题的观点，对于这个电影的评论也无法做到让每个人都赞同，但也不要人云亦云亦步亦趋就好了。 最后说一句，男主的精神值得我们去学习，但他的行为并不是代表对每个人都有效的，因为生活往往带有主观性。从这部影片中，我们理应自己感受到更多！ 作者：lhsjohn]]></content>
      <categories>
        <category>观后感</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>影评</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ez_setup.py]]></title>
    <url>%2F2018%2F08%2F04%2Fez_setup.py%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#!/usr/bin/env python&quot;&quot;&quot;Setuptools bootstrapping installer.Maintained at https://github.com/pypa/setuptools/tree/bootstrap.Run this script to install or upgrade setuptools.This method is DEPRECATED. Check https://github.com/pypa/setuptools/issues/581 for more details.&quot;&quot;&quot;import osimport shutilimport sysimport tempfileimport zipfileimport optparseimport subprocessimport platformimport textwrapimport contextlibfrom distutils import logtry: from urllib.request import urlopenexcept ImportError: from urllib2 import urlopentry: from site import USER_SITEexcept ImportError: USER_SITE = None# 33.1.1 is the last version that supports setuptools self upgrade/installation.DEFAULT_VERSION = &quot;33.1.1&quot;DEFAULT_URL = &quot;https://pypi.io/packages/source/s/setuptools/&quot;DEFAULT_SAVE_DIR = os.curdirDEFAULT_DEPRECATION_MESSAGE = &quot;ez_setup.py is deprecated and when using it setuptools will be pinned to &#123;0&#125; since it&apos;s the last version that supports setuptools self upgrade/installation, check https://github.com/pypa/setuptools/issues/581 for more info; use pip to install setuptools&quot;MEANINGFUL_INVALID_ZIP_ERR_MSG = &apos;Maybe &#123;0&#125; is corrupted, delete it and try again.&apos;log.warn(DEFAULT_DEPRECATION_MESSAGE.format(DEFAULT_VERSION))def _python_cmd(*args): &quot;&quot;&quot; Execute a command. Return True if the command succeeded. &quot;&quot;&quot; args = (sys.executable,) + args return subprocess.call(args) == 0def _install(archive_filename, install_args=()): &quot;&quot;&quot;Install Setuptools.&quot;&quot;&quot; with archive_context(archive_filename): # installing log.warn(&apos;Installing Setuptools&apos;) if not _python_cmd(&apos;setup.py&apos;, &apos;install&apos;, *install_args): log.warn(&apos;Something went wrong during the installation.&apos;) log.warn(&apos;See the error message above.&apos;) # exitcode will be 2 return 2def _build_egg(egg, archive_filename, to_dir): &quot;&quot;&quot;Build Setuptools egg.&quot;&quot;&quot; with archive_context(archive_filename): # building an egg log.warn(&apos;Building a Setuptools egg in %s&apos;, to_dir) _python_cmd(&apos;setup.py&apos;, &apos;-q&apos;, &apos;bdist_egg&apos;, &apos;--dist-dir&apos;, to_dir) # returning the result log.warn(egg) if not os.path.exists(egg): raise IOError(&apos;Could not build the egg.&apos;)class ContextualZipFile(zipfile.ZipFile): &quot;&quot;&quot;Supplement ZipFile class to support context manager for Python 2.6.&quot;&quot;&quot; def __enter__(self): return self def __exit__(self, type, value, traceback): self.close() def __new__(cls, *args, **kwargs): &quot;&quot;&quot;Construct a ZipFile or ContextualZipFile as appropriate.&quot;&quot;&quot; if hasattr(zipfile.ZipFile, &apos;__exit__&apos;): return zipfile.ZipFile(*args, **kwargs) return super(ContextualZipFile, cls).__new__(cls)&lt;!--more--&gt;@contextlib.contextmanagerdef archive_context(filename): &quot;&quot;&quot; Unzip filename to a temporary directory, set to the cwd. The unzipped target is cleaned up after. &quot;&quot;&quot; tmpdir = tempfile.mkdtemp() log.warn(&apos;Extracting in %s&apos;, tmpdir) old_wd = os.getcwd() try: os.chdir(tmpdir) try: with ContextualZipFile(filename) as archive: archive.extractall() except zipfile.BadZipfile as err: if not err.args: err.args = (&apos;&apos;, ) err.args = err.args + ( MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename), ) raise # going in the directory subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0]) os.chdir(subdir) log.warn(&apos;Now working in %s&apos;, subdir) yield finally: os.chdir(old_wd) shutil.rmtree(tmpdir)def _do_download(version, download_base, to_dir, download_delay): &quot;&quot;&quot;Download Setuptools.&quot;&quot;&quot; py_desig = &apos;py&#123;sys.version_info[0]&#125;.&#123;sys.version_info[1]&#125;&apos;.format(sys=sys) tp = &apos;setuptools-&#123;version&#125;-&#123;py_desig&#125;.egg&apos; egg = os.path.join(to_dir, tp.format(**locals())) if not os.path.exists(egg): archive = download_setuptools(version, download_base, to_dir, download_delay) _build_egg(egg, archive, to_dir) sys.path.insert(0, egg) # Remove previously-imported pkg_resources if present (see # https://bitbucket.org/pypa/setuptools/pull-request/7/ for details). if &apos;pkg_resources&apos; in sys.modules: _unload_pkg_resources() import setuptools setuptools.bootstrap_install_from = eggdef use_setuptools( version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=DEFAULT_SAVE_DIR, download_delay=15): &quot;&quot;&quot; Ensure that a setuptools version is installed. Return None. Raise SystemExit if the requested version or later cannot be installed. &quot;&quot;&quot; to_dir = os.path.abspath(to_dir) # prior to importing, capture the module state for # representative modules. rep_modules = &apos;pkg_resources&apos;, &apos;setuptools&apos; imported = set(sys.modules).intersection(rep_modules) try: import pkg_resources pkg_resources.require(&quot;setuptools&gt;=&quot; + version) # a suitable version is already installed return except ImportError: # pkg_resources not available; setuptools is not installed; download pass except pkg_resources.DistributionNotFound: # no version of setuptools was found; allow download pass except pkg_resources.VersionConflict as VC_err: if imported: _conflict_bail(VC_err, version) # otherwise, unload pkg_resources to allow the downloaded version to # take precedence. del pkg_resources _unload_pkg_resources() return _do_download(version, download_base, to_dir, download_delay)def _conflict_bail(VC_err, version): &quot;&quot;&quot; Setuptools was imported prior to invocation, so it is unsafe to unload it. Bail out. &quot;&quot;&quot; conflict_tmpl = textwrap.dedent(&quot;&quot;&quot; The required version of setuptools (&gt;=&#123;version&#125;) is not available, and can&apos;t be installed while this script is running. Please install a more recent version first, using &apos;easy_install -U setuptools&apos;. (Currently using &#123;VC_err.args[0]!r&#125;) &quot;&quot;&quot;) msg = conflict_tmpl.format(**locals()) sys.stderr.write(msg) sys.exit(2)def _unload_pkg_resources(): sys.meta_path = [ importer for importer in sys.meta_path if importer.__class__.__module__ != &apos;pkg_resources.extern&apos; ] del_modules = [ name for name in sys.modules if name.startswith(&apos;pkg_resources&apos;) ] for mod_name in del_modules: del sys.modules[mod_name]def _clean_check(cmd, target): &quot;&quot;&quot; Run the command to download target. If the command fails, clean up before re-raising the error. &quot;&quot;&quot; try: subprocess.check_call(cmd) except subprocess.CalledProcessError: if os.access(target, os.F_OK): os.unlink(target) raisedef download_file_powershell(url, target): &quot;&quot;&quot; Download the file at url to target using Powershell. Powershell will validate trust. Raise an exception if the command cannot complete. &quot;&quot;&quot; target = os.path.abspath(target) ps_cmd = ( &quot;[System.Net.WebRequest]::DefaultWebProxy.Credentials = &quot; &quot;[System.Net.CredentialCache]::DefaultCredentials; &quot; &apos;(new-object System.Net.WebClient).DownloadFile(&quot;%(url)s&quot;, &quot;%(target)s&quot;)&apos; % locals() ) cmd = [ &apos;powershell&apos;, &apos;-Command&apos;, ps_cmd, ] _clean_check(cmd, target)def has_powershell(): &quot;&quot;&quot;Determine if Powershell is available.&quot;&quot;&quot; if platform.system() != &apos;Windows&apos;: return False cmd = [&apos;powershell&apos;, &apos;-Command&apos;, &apos;echo test&apos;] with open(os.path.devnull, &apos;wb&apos;) as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_powershell.viable = has_powershelldef download_file_curl(url, target): cmd = [&apos;curl&apos;, url, &apos;--location&apos;, &apos;--silent&apos;, &apos;--output&apos;, target] _clean_check(cmd, target)def has_curl(): cmd = [&apos;curl&apos;, &apos;--version&apos;] with open(os.path.devnull, &apos;wb&apos;) as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_curl.viable = has_curldef download_file_wget(url, target): cmd = [&apos;wget&apos;, url, &apos;--quiet&apos;, &apos;--output-document&apos;, target] _clean_check(cmd, target)def has_wget(): cmd = [&apos;wget&apos;, &apos;--version&apos;] with open(os.path.devnull, &apos;wb&apos;) as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_wget.viable = has_wgetdef download_file_insecure(url, target): &quot;&quot;&quot;Use Python to download the file, without connection authentication.&quot;&quot;&quot; src = urlopen(url) try: # Read all the data in one block. data = src.read() finally: src.close() # Write all the data in one block to avoid creating a partial file. with open(target, &quot;wb&quot;) as dst: dst.write(data)download_file_insecure.viable = lambda: Truedef get_best_downloader(): downloaders = ( download_file_powershell, download_file_curl, download_file_wget, download_file_insecure, ) viable_downloaders = (dl for dl in downloaders if dl.viable()) return next(viable_downloaders, None)def download_setuptools( version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=DEFAULT_SAVE_DIR, delay=15, downloader_factory=get_best_downloader): &quot;&quot;&quot; Download setuptools from a specified location and return its filename. `version` should be a valid setuptools version number that is available as an sdist for download under the `download_base` URL (which should end with a &apos;/&apos;). `to_dir` is the directory where the egg will be downloaded. `delay` is the number of seconds to pause before an actual download attempt. ``downloader_factory`` should be a function taking no arguments and returning a function for downloading a URL to a target. &quot;&quot;&quot; # making sure we use the absolute path to_dir = os.path.abspath(to_dir) zip_name = &quot;setuptools-%s.zip&quot; % version url = download_base + zip_name saveto = os.path.join(to_dir, zip_name) if not os.path.exists(saveto): # Avoid repeated downloads log.warn(&quot;Downloading %s&quot;, url) downloader = downloader_factory() downloader(url, saveto) return os.path.realpath(saveto)def _build_install_args(options): &quot;&quot;&quot; Build the arguments to &apos;python setup.py install&apos; on the setuptools package. Returns list of command line arguments. &quot;&quot;&quot; return [&apos;--user&apos;] if options.user_install else []def _parse_args(): &quot;&quot;&quot;Parse the command line for options.&quot;&quot;&quot; parser = optparse.OptionParser() parser.add_option( &apos;--user&apos;, dest=&apos;user_install&apos;, action=&apos;store_true&apos;, default=False, help=&apos;install in user site package&apos;) parser.add_option( &apos;--download-base&apos;, dest=&apos;download_base&apos;, metavar=&quot;URL&quot;, default=DEFAULT_URL, help=&apos;alternative URL from where to download the setuptools package&apos;) parser.add_option( &apos;--insecure&apos;, dest=&apos;downloader_factory&apos;, action=&apos;store_const&apos;, const=lambda: download_file_insecure, default=get_best_downloader, help=&apos;Use internal, non-validating downloader&apos; ) parser.add_option( &apos;--version&apos;, help=&quot;Specify which version to download&quot;, default=DEFAULT_VERSION, ) parser.add_option( &apos;--to-dir&apos;, help=&quot;Directory to save (and re-use) package&quot;, default=DEFAULT_SAVE_DIR, ) options, args = parser.parse_args() # positional arguments are ignored return optionsdef _download_args(options): &quot;&quot;&quot;Return args for download_setuptools function from cmdline args.&quot;&quot;&quot; return dict( version=options.version, download_base=options.download_base, downloader_factory=options.downloader_factory, to_dir=options.to_dir, )def main(): &quot;&quot;&quot;Install or upgrade setuptools and EasyInstall.&quot;&quot;&quot; options = _parse_args() archive = download_setuptools(**_download_args(options)) return _install(archive, _build_install_args(options))if __name__ == &apos;__main__&apos;: sys.exit(main())]]></content>
      <categories>
        <category>爬虫</category>
        <category>python</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(三)装饰者模式]]></title>
    <url>%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%B8%89)-----%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式的定义装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 可以这么说：“装饰者模式给爱用继承的人一个全新的眼界” 下面来看一个装饰者模式的使用案例 对于一家咖啡店的订单系统，起初所有种类咖啡的类都是继承自饮料类的(Beverage),其中饮料类是一个抽象的类，内有description的实例变量，用来描述所做的饮料，有cost()方法来返回价钱。 但是我们都知道，咖啡的种类有很多很多种，加入的调料也不尽相同，比如说我们可以定制摩卡咖啡，奶泡咖啡等，且这些调料的价钱也是不尽相同的，或许我们最初想法是再将咖啡的种类根据调料来进行划分，派生出更多的子类出来，但是这种做法是不明智的，咖啡的种类有成千上百种，调料也有成千上百种，照这个思想进行下去的话，岂不是要派生出一大堆类出来，这对于系统的维护来说也将是一个棘手的事情。 那么，有没有其他的解决方案呢？ 答案是肯定的，在这里就是需要用到一个经典的设计模式——装饰者模式。 在这个例子中，我们要以饮料为主体，然后在运行时以调料来装饰饮料。举个栗子，如果顾客想要一杯摩卡和奶泡深焙咖啡，我们要做的事情有 1.拿一个深焙咖啡(DarkRoast)对象 2.以摩卡(Mocha)对象装饰它 3.以奶泡(Whip)对象装饰它 4.调用cost()方法，并依赖委托将调料的价钱加上去 以装饰者构造饮料订单 1.以DarkRoast对象开始，DarkRoast对象继承自Beverage，并且有一个用来计算饮料价钱的cost()方法。 2.顾客想要摩卡(Mocha)，所以建立一个Mocha对象，并用它将DarkRoast对象包起来，Mocha对象是一个装饰者，它的类型反映了它所装饰的对象，在本例中，也就是Beverage, 也就是说两者的类型一致。所以Mocha也有一个cost()方法，通过多态，也可以把Mocha包裹的任何Beverage当成是Beverage，因为Mocha是Berverage的子类型。 3.顾客也想要奶泡(Whip),所以需要建立一个Whip装饰者，并用它将Mocha对象包起来。 4.现在，顾客开始结账了。通过调用最外圈装饰者(Whip)的cost()就可以了。Whip的cost()会先委托它装饰的对象，在这里也就是Mocha，计算出价钱，然后再加上奶泡的价钱。(这种包裹关系你可以理解成食堂里的鸡蛋，鸡蛋壳包着鸡蛋清，鸡蛋清里面又有鸡蛋黄，但它们都是鸡蛋) 现在我们可以做一个简单的总结了 1.装饰者和被装饰对象有着相同的超类型。 2.你可以用一个或者多个装饰者包装一个对象 3.因为装饰者和被装饰的对象有着共同的超类型，所以在任何需要原始对象(被包装的)场合，可以用装饰过的对象代替它。 4.装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，来达到特定的目的。 5.对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。 下面是装饰者模式的类图 下面上代码，把设计转化成代码 先从Berverage类下手 1234567891011121314 Public abstract class Beverage&#123; String description=”Unknow Beverage “;Public String getDescription()&#123; Return description;&#125;Public abstract double cost();&#125; 下面让我们来实现Condiment(调料)抽象类，也就是装饰者类 1234567 Public abstract class CondimentDecorator extends Beverage&#123;Public abstract String getDescription();&#125; 现在我们有了基类，接下来是实现一些饮料，写一些饮料的代码 12345678910111213141516171819202122232425262728Public class Espresso extends Beverage&#123; Public Espresso()&#123; Description=”Espresso”; &#125; Public double cost()&#123; Return 1.99; &#125;&#125;Public class HouseBlend extends Beverage&#123; Public HouseBlend()&#123; Description=”House Blend Coffee”;&#125; Public double cost()&#123; Return 0.89; &#125;&#125; 写调料的代码 123456789101112131415161718192021 Public class Mocha extends CondimentDecorator&#123; Beverage beverage; Public Mocha(Beverage beverage)&#123; this.beverage=beverage; &#125; Public String getDescription()&#123; return beverage.getDescription() +”, Mocha”; &#125; Public double cost()&#123; return 0.20+beverage.cost(); &#125;&#125; 最后，是测试代码 1234567891011121314151617 Public class CoffeeOrders&#123; Public static void main(String[] args)&#123; Beverage beverage=new Espresso(); System.out.println(beverage.getDescription() +” $“+beverage.cost()); Beverage beverage2=new HouseBlend(); beverage2 =new Mocha(beverage2); //用Mocha装饰它 beverage2 =new Mocha(beverage2); //用第二个Mocha装饰它 beverage2 =new Whip(beverage2); System.out.println(beverage2.getDescription()+” $ ”+ beverage2.cost()); &#125;&#125; 输出结果为 Espresso $ 1.99 House Blend Coffee ,Mocha, Mocha, Whip $1.29 这样所有的代码就算完成了，总结说来，我们还应该记住一个新的设计原则 即“类应该对扩展开放，对修改关闭” jdk中也有很多地方用到了装饰者设计模式， 例如JAVA I/O 中的API很多就采取了这种模式 下面是收集的一些比较好的有关于装饰者者模式的博文 设计模式–装饰者模式思考 https://mrdear.cn/2018/03/08/experience/design_patterns--decorator_model/ JDK中的设计模式之装饰者模式 https://blog.csdn.net/kangkanglou/article/details/78744970 Spring容器装饰者模式应用之实现业务类与服务类自由组合的解决方案 https://blog.csdn.net/a1314517love/article/details/47705327 作者:lhsjohn]]></content>
      <categories>
        <category>设计模式</category>
        <category>java</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib2爬虫初级 (二)]]></title>
    <url>%2F2018%2F08%2F01%2Furllib2%E7%88%AC%E8%99%AB%E5%88%9D%E7%BA%A7(%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天用urllib模拟GET请求爬取了百度贴吧的一些内容，但是现在网络上还有很多数据是通过POST请求获得的，更复杂的情况是你要面临着如ajax的一些动态加载的数据，你所要获取的数据不能仅仅限于你在浏览器网页里看到的数据，所以在这里有几个处理的方法。 POST请求发送Request请求对象的里有data参数，它就是用在POST里的，我们要传送的数据就是这个参数data，data是一个字典，里面要匹配键值对 下面是流行的一个比较火的学习案例，通过POST请求模拟有道词典的翻译(之所以选择有道词典，是因为有些翻译词典发起的请求是GET的，这就很狗血了) 首先开启了我Chrome浏览器中的代理插件，要模仿有道词典翻译的工作我们需要得到有关的url以及data数据 这些数据的获取是我们通过抓包获取的 之前的博客写过我现在用的是Fiddler 来抓包的，功能还算比较强大用起来还是挺舒服的。 输入“我爱python” 的文字进行翻译，点击翻译按钮来发起一个请求，如下 下面是我抓到的包 于是接下来我们可以用来模拟发送POST请求 12345678910111213141516171819202122232425# -*- coding:UTF-8 -*-import urllibimport urllib2url=&quot;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule &quot;key =raw_input(&quot;请输入需要翻译的文字:&quot;)headers=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot; &#125;formdata=&#123;&quot;i&quot;:key,&quot;from&quot;:&quot;AUTO&quot;,&quot;to&quot;:&quot;AUTO&quot;,&quot;smartresult&quot;:&quot;dict&quot;,&quot;client&quot;:&quot;fanyideskweb&quot;,&quot;salt&quot;:&quot;1533109653036&quot;,&quot;sign&quot;:&quot;2ad8507b8a10dda31e7c0c1bcd3eef8d&quot;,&quot;doctype&quot;:&quot;json&quot;,&quot;version&quot;:&quot;2.1&quot;,&quot;keyfrom&quot;:&quot;fanyi.web&quot;,&quot;action&quot;:&quot;FY_BY_CLICKBUTTION&quot;,&quot;typoResult&quot;:&quot;false&quot; &#125;data= urllib.urlencode(formdata)request=urllib2.Request(url,data=data,headers=headers)print urllib2.urlopen(request).read() 其中的formdata就是我们抓包抓取的请求体里面的内容，请求体里面是以”&amp;”的形式分割的，在这里我们将数据提取出来转化成字典的形式，建立一个字典formdata. 还有要注意的一点，也是一个坑 请求url中的translate_o 需要写成translate才行，否则会报错，也不知道为什么，就是一个坑 运行程序，输入要翻译的文字，系统会输出一个Json格式的字符串 拿着个json字符串去解析，便可以看到我们想要的结果。有很多在线json解析的工具和网站我这里用的是www.json.cn 解析出来的结果如下12345678910111213&#123; &quot;type&quot;:&quot;ZH_CN2EN&quot;, &quot;errorCode&quot;:0, &quot;elapsedTime&quot;:1, &quot;translateResult&quot;:[ [ &#123; &quot;src&quot;:&quot;我爱python&quot;, &quot;tgt&quot;:&quot;I love the python&quot; &#125; ] ]&#125; 这样我们就完成了一个post请求的发送 处理Ajax加载的情况刚才我们爬取的页面是一个静态页面，所见及所得，但如果我们要爬取的是一个动态加载的页面呢？例如豆瓣电影网，在显示电影列表时就是根据你鼠标滑轮的滑动来加载的，如果你不往下滑动，下面的数据是不会有的。 但是我们只要记得，AJAX一般返回的是JSON,直接对AJAX地址进行post或get，就返回JSON数据了。 下面我们就拿一个例子来获取这种情况下的数据 下面我们就爬一下豆瓣的网站吧 作为爬虫的玩家，我们首先要关注的应该是数据的来源。 那么，我们开始了 像上一个例子一样，首先我们抓取了它的Url,抽取里面的数据建立字典，发送POST请求便可以获取我们想要的数据。 12345678910111213141516171819# -*- coding:UTF-8 -*-import urllibimport urllib2url=&quot;https://movie.douban.com/j/new_search_subjects?sort=T&amp;range=0,10&amp;tags=&amp;start=80&quot;formdata=&#123; &quot;sort&quot;:&quot;T&quot;, &quot;range&quot;:&quot;0,10&quot;, &quot;tags&quot;:&quot;&quot;, &quot;start&quot;:&quot;80&quot; &#125;headers=&#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36&quot;&#125;data=urllib.urlencode(formdata)request=urllib2.Request(url,data=data,headers=headers)print urllib2.urlopen(request).read() 有些参数是我们可以手动去指定的，例如上面代码的range 、start等，这样我们就可以根据自己的需要来获取我们需要的数据的范围了 抓取的结果如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&quot;data&quot;:[ &#123; &quot;directors&quot;:[ &quot;宁浩&quot; ], &quot;rate&quot;:&quot;8.3&quot;, &quot;cover_x&quot;:578, &quot;star&quot;:&quot;40&quot;, &quot;title&quot;:&quot;疯狂的石头&quot;, &quot;url&quot;:&quot;https://movie.douban.com/subject/1862151/&quot;, &quot;casts&quot;:[ &quot;郭涛&quot;, &quot;刘桦&quot;, &quot;连晋&quot;, &quot;黄渤&quot;, &quot;徐峥&quot; ], &quot;cover&quot;:&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p712241453.jpg&quot;, &quot;id&quot;:&quot;1862151&quot;, &quot;cover_y&quot;:764 &#125;, &#123; &quot;directors&quot;:[ &quot;大卫·芬奇&quot; ], &quot;rate&quot;:&quot;8.7&quot;, &quot;cover_x&quot;:1400, &quot;star&quot;:&quot;45&quot;, &quot;title&quot;:&quot;消失的爱人&quot;, &quot;url&quot;:&quot;https://movie.douban.com/subject/21318488/&quot;, &quot;casts&quot;:[ &quot;本·阿弗莱克&quot;, &quot;裴淳华&quot;, &quot;尼尔·帕特里克·哈里斯&quot;, &quot;凯莉·库恩&quot;, &quot;泰勒·派瑞&quot; ], &quot;cover&quot;:&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2221768894.jpg&quot;, &quot;id&quot;:&quot;21318488&quot;, &quot;cover_y&quot;:2100 &#125;, &#123; &quot;directors&quot;:[ &quot;彼得·杰克逊&quot; ], &quot;rate&quot;:&quot;8.9&quot;, &quot;cover_x&quot;:1098, &quot;star&quot;:&quot;45&quot;, &quot;title&quot;:&quot;指环王1：魔戒再现&quot;, &quot;url&quot;:&quot;https://movie.douban.com/subject/1291571/&quot;, &quot;casts&quot;:[ &quot;伊莱贾·伍德&quot;, &quot;西恩·奥斯汀&quot;, &quot;伊恩·麦克莱恩&quot;, &quot;维果·莫腾森&quot;, &quot;奥兰多·布鲁姆&quot; ], &quot;cover&quot;:&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1354436051.jpg&quot;, &quot;id&quot;:&quot;1291571&quot;, &quot;cover_y&quot;:1500 &#125;, &#123; &quot;directors&quot;:[ &quot;陈可辛&quot; ], &quot;rate&quot;:&quot;7.6&quot;, &quot;cover_x&quot;:1017, &quot;star&quot;:&quot;40&quot;, &quot;title&quot;:&quot;中国合伙人&quot;, &quot;url&quot;:&quot;https://movie.douban.com/subject/11529526/&quot;, &quot;casts&quot;:[ &quot;黄晓明&quot;, &quot;邓超&quot;, &quot;佟大为&quot;, &quot;杜鹃&quot; ], &quot;cover&quot;:&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1959304567.jpg&quot;, &quot;id&quot;:&quot;11529526&quot;, &quot;cover_y&quot;:1500 &#125; .............等等等 ] &#125; 这样抓取一个ajax加载的页面也完成了 还有一个比较常用的操作是我们可以用cooike模拟用户登录我们知道，有些网站是需要我们登录过后才可以去访问的，没有登录的用户即便是输入了url地址，也会再次给你重定向到登陆的界面，这样你就不可能看到登录之后的数据了 要想用cooike模拟登录，我们只需要在请求头里面加入cooike的值就行了。至于怎么获取cooike的值，有很多的处理办法，目前只是用的最笨的那种，即抓包获取。 123456789101112131415161718192021import urllib2url = &quot;http://www.renren.com/410043129/profile&quot;headers = &#123; &quot;Host&quot; : &quot;www.renren.com&quot;, &quot;Connection&quot; : &quot;keep-alive&quot;, #&quot;Upgrade-Insecure-Requests&quot; : &quot;1&quot;, &quot;User-Agent&quot; : &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;, &quot;Accept&quot; : &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Referer&quot; : &quot;http://www.renren.com/SysHome.do&quot;, #&quot;Accept-Encoding&quot; : &quot;gzip, deflate, sdch&quot;, &quot;Cookie&quot; : &quot;anonymid=ixrna3fysufnwv; _r01_=1; depovince=GW; jebe_key=f6fb270b-d06d-42e6-8b53-e67c3156aa7e%7Cc13c37f53bca9e1e7132d4b58ce00fa3%7C1484060607478%7C1%7C1484400895379; jebe_key=f6fb270b-d06d-42e6-8b53-e67c3156aa7e%7Cc13c37f53bca9e1e7132d4b58ce00fa3%7C1484060607478%7C1%7C1484400890914; JSESSIONID=abcX8s_OqSGsYeRg5vHMv; jebecookies=0c5f9b0d-03d8-4e6a-b7a9-3845d04a9870|||||; ick_login=8a429d6c-78b4-4e79-8fd5-33323cd9e2bc; _de=BF09EE3A28DED52E6B65F6A4705D973F1383380866D39FF5; p=0cedb18d0982741d12ffc9a0d93670e09; ap=327550029; first_login_flag=1; ln_uact=mr_mao_hacker@163.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn521/20140529/1055/h_main_9A3Z_e0c300019f6a195a.jpg; t=56c0c522b5b068fdee708aeb1056ee819; societyguester=56c0c522b5b068fdee708aeb1056ee819; id=327550029; xnsid=5ea75bd6; loginfrom=syshome&quot;, &quot;Accept-Language&quot; : &quot;zh-CN,zh;q=0.8,en;q=0.6&quot;,&#125;request = urllib2.Request(url, headers = headers)response = urllib2.urlopen(request)print response.read() 这样就可以模拟登录，访问登录后的界面了（这个是网上整理的demo,登进去的也不是我的页面） 以上就是用urllib2进行初级爬虫的一些总结，完成这些也远远算不上入门，总的来说，要做好一个比较漂亮的爬虫程序，还是需要一个不断积累的过程。 除了最后一个不能确定，前面的代码都是可以运行的。 今天的程序到此结束，大功告成！ 作者：lhsjohn]]></content>
      <categories>
        <category>爬虫</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(二)观察者模式]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%BA%8C)-----%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式的定义： 观察者模式定义了对象的一对多依赖，这样一来，让一个对象改变状态时，它的所有依赖者都会收到通知并且会自动更新。 观察者模式的实例： 实例：建立一个气象站应用，利用WeatherData对象取得数据，并更新三个布告板：当前状况、气象统计和天气预报，当WeatherObject对象获得最新的测量数据时，三种布告板必须实时更新。 其实观察者模式可以从订报的角度来理解。 拿报纸的订阅来举例子： 报社的业务就是出版报纸 向某家报社订阅了报纸，只要他们有心得报纸出版，就会给你 送过来。只要你是他们的订户，你就会一直收到新报纸。 当你不再看报纸的时候，取消订阅，他们就不会再送报纸过来 只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。 定义观察者模式，类图 任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的也可以在任何时候删除某些观察者。 有新类型的观察者出现时，主题的代码不需要修改。加入我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。 这里体现了我们的一个设计原则，即为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降到了最低。 基于以上的原则，我们可以得出我们对于该气象站的设计图： 下面我们用代码来实现气象站让我们从建立接口开始123456789Public interface Subject&#123;//这两个方法都需要一个观察者作为变量，该观察者是用来注册或者被删除的 Public void registerObserver(Observer o); Public void removeObserver(Observer o); //当主题状态改变时，这个方法会被调用，以通知所有的观察者 Public void notifyObservers();&#125; 1234567Public interface Observer&#123;//当气象观测值改变时，主题会把这些状态值当做方法的参数，传递给观察者。 Public void update(float temp,float humidity,float pressure);&#125; 123456Public interface DisplayElement&#123;//当布告板需要显示时，调用此方法。 Public void display();&#125; 在WeatherData中实现接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Public class WeatherData implements Subject&#123; Private ArrayList observers; Private float temperature; Private float humidity; Private float pressure; Public WeatherData()&#123; Ovservers=new ArrayList(); &#125; Public void registreObserver(Observer o)&#123; Observers.add(o); &#125; Public void removeObserver(Observer o)&#123; int i=observers.indexOf(o); If(i&gt;=0)&#123; Observers.remove(i); &#125; &#125; Public void notifyObservers()&#123; for(int i=0;i&lt;observers.size();i++)&#123; Observer observer =(Observer) observers.get(i); Observer.update(temperature,humidity,pressure); &#125; &#125; Public void messurementsChanged()&#123; notifyObservers();&#125; Public void setMeasurements(float temperature,float humidity,float pressure) &#123; this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; &#125; //WeatherData的其他方法 &#125; 现在让我们来建立布告板1234567891011121314151617181920212223Public class CurrentConditionsDisplay implements Observer ,DisplayElement &#123; Private float temperature; Private float humidity; Private Subject weatherData; //构造器需要weatherData对象作为注册之用 Public CurrentConditionsDisplay(Subjecy weatherData)&#123; this.weatherData =weatherData; weatherData.registerObserver(this); &#125; Public void update(float temperature,float humidity,float pressure) &#123; this.temperature=temperature; this.humidity=humidity; Display(); &#125; Public void display()&#123; System.out.println(“Current conditions: “+temperature +”℃ and ” +humidity+ “% humidity”) &#125; &#125; 最后我们可以建立一个测试程序1234567891011121314Public class WeatherStation &#123; Public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); CurrentConditionsDisplay currentDisplay =new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(24,65,30.4f); weatherData.setMeasurements(25,64,29.4f); weatherData.setMeasurements(29,59,28.4f); &#125;&#125; 运行程序，即可看到输出结果 Current conditions: 24 ℃ and 65.0 % humidity Current conditions: 25 ℃ and 64.0 % humidity Current conditions: 29 ℃ and 59.0 % humidity 这样一个观察者模式的实例就完成了 java还有内置的观察者模式，Java API内有内置的观察者模式，java.util包内包含最基本的Observer接口与Observeable类，这和我们的Subject接口和 Observer接口很相似。 用我们的这个气象站的实现作比较，用java内置的观察者模式是有一点小的差异的，最明显的差异是WeatherData(也就是我们的主题)现在要扩展字Observable类，并继承一些添加、删除、通知观察者的方法。 下面是收集的一些比较好的有关于观察者模式的博文 1.观察者模式和Spring的结合https://blog.csdn.net/zlts000/article/details/53462181?ref=myread 2.观察者模式与事件监听机制https://blog.csdn.net/qq_22873427/article/details/77169781 3.设计模式–观察者模式的思考https://mrdear.cn/2018/04/20/experience/design_patterns--observer/ 4.设计模式 之 观察者 和监听器的区别https://blog.csdn.net/xiaoliuliu2050/article/details/73274985 5观察者模式和Spring的结合https://blog.csdn.net/zlts000/article/details/53462181?ref=myread 6.深入理解Javascript中的观察者模式https://www.jb51.net/article/106119.htm 作者：lhsjohn]]></content>
      <categories>
        <category>设计模式</category>
        <category>java</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib2爬虫初级 (一)]]></title>
    <url>%2F2018%2F07%2F31%2Furllib2%E7%88%AC%E8%99%AB%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[最近由于项目需要，难得需要获取网络上的一些数据，手动获取的话效率又太低，所以最近想要接触一下爬虫。因为有一小部分java开发的经验，所以入门python并不是特别困难，大概看了半天的官方文档后，决定采用python爬虫来获取相关的数据。 python 现在已经有了几个比较成熟的爬虫框架，如scrapy等，由于刚开始接触python以及python爬虫，我决定从比较底层的urllib2 入手。 爬虫，简单说来就是通过程序模拟浏览器请求站点的行为，把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。 我使用爬虫的目的很简单，就是获取数据。 爬虫的一般流程为1.发起请求 也就是模仿浏览器，发送一个Request，一般包含请求头和请求体的部分。2.获取响应的内容3.解析内容4.保存数据(可以存在mysql这种关系型数据库中，但现在非常火的分布式爬虫经常使用redis、mogodb等非关系型数据库，极大提高了数据处理的性能) 同时推荐一个比较好用的抓包工具Fiddler 还有谷歌的代理请求插件Proxy SwitchyOmega 初级练习爬虫的话基本上都是结合着这两个工具来的 然后自己就跟着做了一个用url2初级爬虫的练习，可以爬取百度贴吧的一些信息，并保存下来为html文件（刚开始入门，并没有考虑到反 反爬虫） 下面安利一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-import urllibimport urllib2def loadPage(url, filename): &quot;&quot;&quot; 作用：根据url发送请求，获取服务器响应文件 url: 需要爬取的url地址 filename : 处理的文件名 &quot;&quot;&quot; print &quot;正在下载 &quot; + filename headers = &#123;&quot;User-Agent&quot; : &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;&#125; request = urllib2.Request(url, headers = headers) return urllib2.urlopen(request).read()def writePage(html, filename): &quot;&quot;&quot; 作用：将html内容写入到本地 html：服务器相应文件内容 &quot;&quot;&quot; print &quot;正在保存 &quot; + filename # 文件写入 with open(filename, &quot;w&quot;) as f: f.write(html) print &quot;-&quot; * 30def tiebaSpider(url, beginPage, endPage): &quot;&quot;&quot; 作用：贴吧爬虫调度器，负责组合处理每个页面的url url : 贴吧url的前部分 beginPage : 起始页 endPage : 结束页 &quot;&quot;&quot; for page in range(beginPage, endPage + 1): pn = (page - 1) * 50 filename = &quot;the&quot; + str(page) + &quot;.html&quot; fullurl = url + &quot;&amp;pn=&quot; + str(pn) #print fullurl html = loadPage(fullurl, filename) #print html writePage(html, filename) print &quot;谢谢使用&quot;if __name__ == &quot;__main__&quot;: kw = raw_input(&quot;请输入需要爬取的贴吧名:&quot;) beginPage = int(raw_input(&quot;请输入起始页：&quot;)) endPage = int(raw_input(&quot;请输入结束页：&quot;)) url = &quot;http://tieba.baidu.com/f?&quot; key = urllib.urlencode(&#123;&quot;kw&quot;: kw&#125;) fullurl = url + key tiebaSpider(fullurl, beginPage, endPage) 下面是运行的效果首先你要输入你想要爬取的关键信息，例如我想爬python吧的一些内容，我就直接输入python了。接下来输入要爬取的页码的范围，例如这里我输入的是1-1,即我只爬取第一页。 爬取成功之后便会生成一个html文件，里面便存放了你所要爬取的内容。 然后一个简单的贴吧爬虫就完成了。。。 再次强调这里使用的是最基本的爬虫，并没有考虑到个别网站的反爬虫措施，也没有分布式的存储，仅仅是通过一个小程序完成爬虫原理的小入门。 当然java也有比较成熟的爬虫封装，例如使用HttpClient的jar包等来实现基本的http操作。 但比较而来，python的爬虫更为简洁，而java爬虫比较好维护。 总而言之，爬虫之路还有走很久，一些东西需要自己不断摸索，只苦逼做项目数据也得自己来搞 orz 太肝了，做完这个记录就滚去睡觉吧 作者：lhsjohn]]></content>
      <categories>
        <category>爬虫</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(一)策略模式]]></title>
    <url>%2F2018%2F07%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%B8%80)-----%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(1)%2F</url>
    <content type="text"><![CDATA[策略模式的定义：策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 OO基础 抽象 封装 多态 继承 OO原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 OO模式 本篇介绍的是策略模式 策略模式的实例： 下面举一个Duck类的实例来说明策略模式 Duck(鸭子)类是所有类的基类 1234567891011121314151617181920212223242526272829 Public abstract class Duck &#123; //为行为接口类型声明两个引用变量，所有鸭子子类(在同一个package中)都继承它们。 FlyBehavior flyBehavior; QuackBehavior quackBehavior; Public Duck() &#123;&#125; Public abstract void display(); Public void performFly()&#123; //委托给行为类 flyBehavior.fly(); &#125; Public void performQuack()&#123; quackBehavior.quack(); &#125; Public void swim()&#123; System.out.println(“所有的鸭子都会游泳”); &#125; &#125; ##飞行行为接口 123456789public interface FlyBehavior &#123; public void fly(); &#125; 12345678910111213141516171819 //这是飞行类的实现，适用于会飞的鸭子Public class FlyWithWings implements FlyBehavior&#123; Public void fly()&#123; System.out.println(“I’m flying!!”); &#125;&#125;//这也是飞行类的实现，给不会飞的鸭子用，如橡皮鸭等Public class FlyNoWay implements FlyBehavior&#123; Public void fly()&#123; System.out.println(“我不会飞”); &#125;&#125; ## QuackBehavior 接口及其实现 12 Public interface QuackBehavior { Public void quack(); } Public class Quack implements QuackBehavior{ Public void quack(){ System.out.println(“Quack”); } } Public class MuteQuack implements QuackBehavior{ Public void quack(){ System.out.println(“&lt;&lt; Silence &gt;&gt;”); } } Public class Squeak implements QuackBehavior{ Public void quack() { System.out.println(“Squeak”); } } 12##下面我们给这些Duck动态设定行为##在Duck 类中加入两个新的方法 Public void setFlyBehavior (FlyBehavior fb) { flyBehavior=fb; } Public void setQuackBehavior (QuackBehavior qb) { quackBehavior =qb; }1##创建一个新的鸭子,模型鸭。 Public class ModelDuck extends Duck{ Public ModelDuck(){ flyBehavior =new FlyNoWay(); quackBehavior=new Quack(); } Public void display(){ System.out.println(“我是模型鸭”); } } 1##建立一个新的FlyBehavior 类型 Public class FlyRocketPowered implements FlyBehavior { Public void fly(){ System.out.println(“我是火箭驱动飞行的”); } } 1##测试类进行测试 Public class TestDuck(){ Public static void main(String[] args){ Duck model=new ModelDuck(); //第一次调用performFly()会被委托给flyBehavior对象，也就是FlyNoWay的实例，该对象 //是在模型鸭构造器中设置的 Model.performFly(); //这里调用继承来的setter方法，给它指定特定的飞行行为 Model.setFlyBehavior(new FlyRocketPowered()); Model.performFly(); } }` 测试结果控制台输出我不会飞 我是火箭驱动飞行的 下面是相关类和接口的关系图 收集的一些写的有关策略模式的比较好的博客 1.【设计模式–spring源码中使用策略模式（Strategy Pattern)】 https://blog.csdn.net/lzwglory/article/details/51822442 2.【策略模式和Spring的结合在项目中的应用】 https://blog.csdn.net/zlts000/article/details/54754789 3.【设计模式（一）策略模式】 https://www.cnblogs.com/jenkinschan/p/5645300.html 4.【深度剖析策略模式（包括该模式在JDK中的应用）】 https://www.cnblogs.com/lewis0077/p/5133812.html 作者：lhsjohn]]></content>
      <categories>
        <category>设计模式</category>
        <category>java</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《西虹市首富》--爆笑与浪漫的融合体]]></title>
    <url>%2F2018%2F07%2F29%2F%E3%80%8A%E8%A5%BF%E8%99%B9%E5%B8%82%E9%A6%96%E5%AF%8C%E3%80%8B---%E7%88%86%E7%AC%91%E4%B8%8E%E6%B5%AA%E6%BC%AB%E7%9A%84%E8%9E%8D%E5%90%88%E4%BD%93%2F</url>
    <content type="text"><![CDATA[在家闲着无聊，无意之间看到了手机上推荐的最近比较火的电影《西虹市首富》。西红柿首付？听起来谐音就挺搞笑，潜意识感觉应该挺不错的一部电影。 “可以去看看，颇具沈腾风格的一部电影。”朋友曾这么给我推荐过。 确实啊，在家也确实无聊，虽然刚买的书已经到了，但是最近浮躁的心却平静不下来，去看吧。 老天并不友好，当我换好衣服准备出门的时候，天就有些阴沉沉的了，因为家电影院不算特别远，“算了，直接去吧”。 “假如突然给你十亿，让你在一个月花完，并且有一部分特殊的要求要满足，你会怎么做？” 电影开篇，十个亿的噱头就足以证实了这部电影的脑洞。 一个有梦想的穷人突然获得十亿，整个故事都像是一场幻想的梦境，简直就是走了“狗屎运”，电影开端给了观众极强的代入感。 在我看来，这部电影能够引人发笑的原因无非就是它的不可预测性的想象，脑洞很大，反转很多，但是仔细去想的话你又会觉得它是合乎情理的，沈腾式的幽默确实给大家带来了不少的小点。 另外一个十足的亮点是王力宏的出场，带翻了全场的节奏，“一个我 需要梦想 需要方向 需要眼泪 更需要 一个人来 点亮天的黑 ”，王力宏的倾情演奏与欢笑惊喜的场面完美融合，其实给人营来了一种暖暖的感动氛围。 整部电影吧，可以说是笑声与浪漫的融合，不乏空奇的想象，也不缺浪漫的爱情。猛烈的抨击了一部分人金钱至上的低俗心态，钱买不来感情，当金钱与人性二选一的时候，你的决定又会是什么？ 爆笑以及浪漫和思考，一样都不能少的，《西虹市首富》这部电影，带给我们的不仅仅是欢笑。 作者：lhsjohn]]></content>
      <categories>
        <category>观后感</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>影评</tag>
        <tag>喜剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Eclipse搭建python环境]]></title>
    <url>%2F2018%2F07%2F29%2FWindows%E4%B8%8BEclipse%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在Eclipse上安装和搭建Python开发环境需要以下五步完成： 1.下载最新的Eclipse安装包,我是基于Python版本python-3.6.4。python-3.6.4要求的Eclipse高版本，我选择了最新的Eclipse版本：eclipse-java-oxygen-2-win32-x86_64.zip下载eclipse-java-oxygen-2-win32-x86_64.zip，可以到Eclipse官方网站：https://www.eclipse.org/downloads/eclipse-packages/在这个页面选择版本系列：Eclipse IDE for Java Developers 2.配置Eclipse开发环境。我下载的是zip包，解压到一个目录E:\developer\eclipse： 3.在Eclipse中添加Python的开发部署软件系统。Eclipse -&gt; Help -&gt; Install New SoftWare -&gt; Add ，在弹出的框添加如图所示的内容： 然后选中python IDE一路next等待下载安装完毕 4.下载最新的Python SDK开发包。Python最新的开发包在官方网站可以下载，链接：https://www.python.org/downloads/release把zip压缩包下载完成后解压到一个文件目录下，比如： 5.此时开始正式写Python代码，写一个经典的hello world。Eclipse中，选择File -&gt; New -&gt; Other，然后会弹出一系列代码项目选择项，选择PyDev Project，然后点击Next。以上配置完成后，就可以正式写Python代码了。新建一个File -&gt; New -&gt; Other -&gt; PyDev Project，然后选中该项目，鼠标右键 -&gt; New -&gt; PyDev Module，在弹出的框中写好包名和Name 然后点击左上角的绿色按钮，选中Hello Test.py就可以看到成功运行出helloWorld了]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>心得</tag>
        <tag>技术</tag>
        <tag>Python环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青春]]></title>
    <url>%2F2018%2F07%2F28%2F%E9%9D%92%E6%98%A5%2F</url>
    <content type="text"><![CDATA[青春不是年华，而是心境，青春不是桃面、丹唇、柔膝，而是深沉的意志、恢弘的想象、炽热的感情；青春是生命的深泉在涌流。青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生有之，六旬男子则更多见。年岁有加，并非垂老；理想丢弃，方堕暮年。岁月悠悠，衰微只及肌肤，热忱抛却，颓唐必至灵魂。忧烦、惶恐、丧失自信，定使心灵扭曲，一起如灰。无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人的心灵应如浩渺瀚海，只要不断接受美好、希望、欢乐、勇气和力量的信号，你无不青春永驻，风华长存。一旦心海枯竭，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即便年方二十，实已垂垂老矣，然则只要虚怀若谷，让喜悦达观、仁爱充盈期间，你就有望在八十高龄告别尘寰时仍觉年轻。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始学习vue.js了]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84vue%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[作为一个刚放暑假的大二技术小白，在家也只是无聊的刷刷手机看看电视等。 一天天的生活确实循环枯燥。 不如学习 早就听说了vue的强大之处，虽然还不怎么流行但自己也早就想去仔细的研究一番那么这个暑假便是一个很好的机会去接触它了解它 [文档链接]：https://cn.vuejs.org/v2/guide/#%E8%B5%B7%E6%AD%A5 作者：lhsjohn]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2018%2F07%2F28%2FThe%20first%20one%2F</url>
    <content type="text"><![CDATA[这算是我刚刚对hexo的一个基本的入门吧，俗话说的好”九尺之台，起于垒土.” 对于自己刚刚搭建的这个比较简单的博客而言，我更把它当做我学习和积累知识的一个平台，是一个起点，以后的许多功能需要不断去完善，希望自己能够加油！ 作者：lhsjohn]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
