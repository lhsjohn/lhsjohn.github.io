<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jsoup爬虫简单实例[笔记] ---- 根据URL爬取多篇凤凰网新闻内容(测试版本)]]></title>
    <url>%2F2018%2F09%2F20%2FJsoup%E7%88%AC%E8%99%AB%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%5B%E7%AC%94%E8%AE%B0%5D%20----%20%E6%A0%B9%E6%8D%AEURL%E7%88%AC%E5%8F%96%E5%A4%9A%E7%AF%87%E5%87%A4%E5%87%B0%E7%BD%91%E6%96%B0%E9%97%BB%E5%86%85%E5%AE%B9(%E6%B5%8B%E8%AF%95%E7%89%88%E6%9C%AC)%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package com.lhsjohn.spider;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.apache.bcel.generic.GETSTATIC;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import org.junit.Test;/** * 凤凰网爬虫 * @author lihuashuo * */public class JsoupTest &#123; public static void main(String[] args) throws Exception &#123; String url = "https://www.ifeng.com/"; String selection = "#FNew .fl.FNewM .FNewMTopLis ul"; List&lt;Map&lt;String, String&gt;&gt; list = new ArrayList&lt;Map&lt;String, String&gt;&gt;(); org.jsoup.nodes.Document doc = Jsoup.connect(url).get(); Elements elements = doc.select(selection); Element element = elements.get(0); String outerHtml = element.outerHtml(); Elements children = element.children(); for (Element element2 : children) &#123; if (element2.select("a").attr("href").startsWith("http://news.ifeng.com/a/")) &#123; Map&lt;String, String&gt; item = new HashMap&lt;String, String&gt;(); Elements aElement = element2.select("a"); item.put("text", aElement.text()); item.put("href", aElement.attr("href")); list.add(item); &#125; // System.out.println(aElement.text()); // System.out.println(aElement.attr("href")); &#125; Element nextElementSibling = element.nextElementSibling(); Elements children2 = nextElementSibling.children(); for (Element element3 : children2) &#123; if (element3.select("a").attr("href").startsWith("http://news.ifeng.com/a/")) &#123; Map item = new HashMap&lt;&gt;(); Elements aElement2 = element3.select("a"); // System.out.println(aElement2.text()); // System.out.println(aElement2.attr("href")); item.put("text", aElement2.text()); item.put("href", aElement2.attr("href")); list.add(item); &#125; &#125; for (Map map : list) &#123; System.out.println(map.toString()); &#125; System.out.println(list.size()); System.out.println("======================开始测试====================================="); // String newUrl = list.get(1).get("href"); String newUrl = list.get(0).get("href"); // for (Map map : list) &#123; // newUrl = (String) map.get("href"); // if (newUrl.startsWith("http://news.ifeng.com/a/")) &#123; // // System.out.println("newUrl:" + newUrl); // //getArticles(newUrl); // &#125; // System.out.println(newUrl); getArticles(newUrl); String newsUrl2 = list.get(1).get("href"); System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"); System.out.println(newsUrl2); getArticles(newsUrl2); for(int i=3;i&lt;list.size();i++) &#123; String tempUrl = list.get(i).get("href"); System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"); System.out.println(tempUrl); getArticles2(tempUrl); &#125; // getArticles2("http://news.ifeng.com/a/20180920/60076776_0.shtml"); &#125; public static void getArticles(String url) throws Exception &#123; Document document = Jsoup.connect(url).get(); String selection = ".yc_main.wrap"; Elements elements = document.select(selection); Element element = elements.get(0); // System.out.println(element.outerHtml()); Elements elements2 = element.select(".yc_tit"); if (!elements2.isEmpty()) &#123; Element element2 = elements2.get(0); Elements children = element2.children(); for (Element element3 : children) &#123; System.out.println(element3.tagName()); if (element3.tagName().equals("h1")) &#123; System.out.println("标题:" + element3.text()); &#125; if (element3.tagName().equals("p")) &#123; Elements children2 = element3.children(); Element element4 = children2.get(0); System.out.println("时间:" + element4.text()); Element element5 = children2.get(1); System.out.println("来源:" + element5.text()); System.out.println("来源链接:" + element5.attr("href")); &#125; &#125; &#125; Elements element6 = element.select(".yc_con_l #yc_con_txt"); System.out.println("element3 size " + element6.size()); if (!element6.isEmpty()) &#123; System.out.println("-------------content-------------"); Element element7 = element6.get(0); System.out.println(element7.text()); &#125; &#125; public static void getArticles2(String url) throws Exception &#123; Document document = Jsoup.connect(url).get(); String selection = "#artical"; Elements elements = document.select(selection); System.out.println(elements.size()); Element element = elements.get(0); Element element2 = element.select("#artical_topic").get(0); System.out.println(element2.text()); Element element3 = element.select("#artical_sth").get(0); Elements children = element3.children(); Element element4 = children.get(0); Element element5 = element4.select(".ss01").get(0); System.out.println("时间:" + element5.text()); Element element6 = element4.select(".ss03 a").get(0); System.out.println("来源: " + element6.text()); System.out.println("来源地址:" + element6.attr("href")); // 获取文章内容 Element element7 = element.select("#artical_real #main_content").get(0); Elements element8 = element7.select(".detailPic img"); if (!element8.isEmpty()) &#123; System.out.println("图片地址:" + element8.get(0).attr("src")); &#125; System.out.println("新闻内容:" + element7.text()); &#125;&#125; 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>Joup</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树的简单实现]]></title>
    <url>%2F2018%2F09%2F18%2FTrie%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Trie树:(来自百度百科)：在计算机科学中，Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package com.lhsjohn.spider.trietest;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;/** * Trie树,这里用来统计、排序和保存大量的字符串 * * @author lihuashuo * */public class Trie &#123; private final int SIZE = 26; private TrieNode root; // 字典树的根 // 字典树节点 class TrieNode &#123; private int num; // 由根至该节点组成的字符串模式出现的次数 private TrieNode[] son; // 所有的儿子节点 private boolean isEnd; // 是不是最后一个节点 private char val; // 节点的值 TrieNode() &#123; num = 1; son = new TrieNode[SIZE]; isEnd = false; &#125; &#125; // 初始化字典树 Trie() &#123; root = new TrieNode(); &#125; // 建立字典树 // 在字典树中插入一个单词 public void insert(String str) &#123; if (str == null || str.length() == 0) &#123; return; &#125; TrieNode node = root; // 将目标单词转化为字符数组 char[] letters = str.toCharArray(); for (int i = 0, len = str.length(); i &lt; len; i++) &#123; int pos = letters[i] - 'a'; if (node.son[pos] == null) &#123; // 如果当前节点的儿子节点中没有该字符,则构建一个TrieNode节点来保存该字符 node.son[pos] = new TrieNode(); node.son[pos].val = letters[i]; &#125; else &#123; // 如果已经存在,则将由根节点至该儿子节点组成的字符串数加1 node.son[pos].num++; &#125; node = node.son[pos]; &#125; node.isEnd = true; &#125; // 计算单词前缀的数量 public int countPrefic(String prefix) &#123; if (prefix == null || prefix.length() == 0) &#123; return -1; &#125; TrieNode node = root; char[] letters = prefix.toCharArray(); for (int i = 0, len = prefix.length(); i &lt; len; i++) &#123; int pos = letters[i] - 'a'; if (node.son[pos] == null) &#123; return 0; &#125; else &#123; node = node.son[pos]; &#125; &#125; return node.num; &#125; // 打印指定前缀的单词 public String hasPrefix(String prefix) &#123; if (prefix == null || prefix.length() == 0) &#123; return null; &#125; TrieNode node = root; char[] letters = prefix.toCharArray(); for (int i = 0, len = prefix.length(); i &lt; len; i++) &#123; int pos = letters[i] - 'a'; char tmp =letters[i]; if (node.son[pos] == null) &#123; return null; &#125; else &#123; node = node.son[pos]; &#125; &#125; preTraverse(node, prefix); return null; &#125; // 遍历经过此节点的单词 public void preTraverse(TrieNode node, String prefix) &#123; if (!node.isEnd) &#123; for (TrieNode child : node.son) &#123; if (child != null) &#123; preTraverse(child, prefix + child.val); &#125; &#125; return; &#125; System.out.println(prefix); &#125; //在字典树中查找一个完全匹配的单词 public boolean has(String str) &#123; if(str == null || str.length()==0) &#123; return false; &#125; TrieNode node = root; char[] letters = str.toCharArray(); for(int i=0,len=str.length();i&lt;len;i++) &#123; int pos = letters[i]-'a'; if(node.son[pos]!=null) &#123; node = node.son[pos]; &#125;else &#123; return false; &#125; &#125; //走到这一步,说明可能完全匹配,可能部分匹配,如果最后一个字符节点为末端节点,则是完全匹配,否则是部分匹配 return node.isEnd; &#125; //前序遍历字典树 public void preTraverse(TrieNode node) &#123; if(node!=null) &#123; System.out.print(node.val+"-"); for(TrieNode child:node.son) &#123; preTraverse(child); &#125; &#125; &#125; public TrieNode getRoot() &#123; return this.root; &#125; public static void main(String[] args) throws Exception &#123; Trie tree = new Trie(); String[] dictionaryData= &#123;"hello","student","computer","sorry","acm","people","experienced", "who","reminds","everyday","almost"&#125;; //构建字典 for(String str:dictionaryData) &#123; tree.insert(str); &#125; String filePath="F:\\Study\\newRecom\\test.txt"; File file = new File(filePath); if(file.isFile() &amp;&amp; file.exists()) &#123; InputStreamReader read = new InputStreamReader(new FileInputStream(file)); BufferedReader bufferedReader = new BufferedReader(read); String lineTxt = null; Map&lt;String,Integer&gt; countMap = new HashMap&lt;String, Integer&gt;(); while((lineTxt = bufferedReader.readLine())!=null) &#123; if(tree.has(lineTxt)) &#123; if(countMap.containsKey(lineTxt)) &#123; countMap.put(lineTxt,countMap.get(lineTxt)+1); &#125;else &#123; countMap.put(lineTxt, 1); &#125; &#125;else &#123; System.out.println(lineTxt+"不在字典中!"); &#125; &#125; for(String s: countMap.keySet()) &#123; System.out.println(s+"出现的次数"+countMap.get(s)); &#125; read.close(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>爬虫</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup爬虫简单实例[笔记] ---- 爬取凤凰网一篇文章的内容]]></title>
    <url>%2F2018%2F09%2F18%2FJsoup%E7%88%AC%E8%99%AB%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%5B%E7%AC%94%E8%AE%B0%5D%20----%20%E7%88%AC%E5%8F%96%E5%87%A4%E5%87%B0%E7%BD%91%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Jsoup 一款极其好用的Java爬虫神器jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。[中文文档]：http://www.open-open.com/jsoup/ 直接来一个小demo吧,很丑的代码,目前暂时只是测试Jsoup的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.lhsjohn.spider;import java.util.ArrayList;import java.util.List;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.nodes.Node;import org.jsoup.select.Elements;public class JsoupTest &#123; public static void main(String[] args) throws Exception &#123; String url = "https://www.ifeng.com/"; org.jsoup.nodes.Document doc = Jsoup.connect(url).get(); Elements topNews = doc.select("#headLineDefault .FNewMTopLis a[href]"); Element firstElement = topNews.first(); String firstTitle = topNews.first().text(); // 爬取&lt;&lt;重返爱的海洋&gt;&gt;文章的url String firstElementUrl = firstElement.attr("abs:href"); System.out.println(firstTitle); System.out.println(firstElementUrl); // 链接新的url进行爬取: Document document = Jsoup.connect(firstElementUrl).get(); Elements topicEl = document.select("#artical #artical_topic"); // 标题内容: String topic = topicEl.text(); Elements timeElement = document.select("#artical #artical_sth .p_time .ss01"); // 时间: String time = timeElement.text(); // 来源: Elements elements = document.select("#artical #artical_sth .p_time .ss03 a"); String text = elements.attr("abs:href"); Elements sourceElement = document.select("#artical #artical_sth .p_time .ss03"); String sourceName = sourceElement.text(); String sourceUrl = sourceElement.attr("abs:href"); // 文章内容 Elements mainContentEl = document.select("#artical #main_content p"); int size = mainContentEl.size(); Element currentElement = mainContentEl.first(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); String text2 = currentElement.text(); String s = ""; Element tmp = null; //遍历p元素节点,并将其的内容添加到List中保存 for (int i = 0; i &lt; size; i++) &#123; tmp = currentElement; s = tmp.text(); list.add(s); currentElement = tmp.nextElementSibling(); &#125; String Content = mainContentEl.text(); System.out.println("========标题========"); System.out.println(topic); System.out.println("========时间========"); System.out.println(time); System.out.println("========来源========"); System.out.println(text); System.out.println(sourceName + " " + sourceUrl); System.out.println("========文章内容========"); System.out.println(list.size()); for (String string : list) &#123; System.out.println(string); &#125; &#125; &#125; 运行结果 123456789101112131415161718重返爱的海洋http://news.ifeng.com/a/20180917/60071302_0.shtml========标题========重返爱的海洋========时间========2018年09月17日 19:38:51========来源========http://api.cportal.cctv.com/api/newsInsert/ywnr.html?id=ArtiJEDQsB91pCigjAa9OShw180917&amp;from=singlemessage央视新闻移动网 ========文章内容========7原标题【独家V观】重返爱的海洋前不久，位于俄罗斯远东城市符拉迪沃斯托克的“海洋”全俄儿童中心，迎来了一批阔别十年的中国青年。十年前，他们有一个共同的身份：赴俄疗养的四川汶川大地震灾区儿童。当年他们在俄罗斯朋友的精心照料下，逐渐抚平内心的创伤。十年后，他们重返故地寻找往日的故事和朋友。在这次难忘的重逢中，还有两位重要的来宾：中国国家主席习近平和俄罗斯总统普京。习主席在现场发表了令人难忘的讲话，他勉励这些已经长大成人的中国孩子：滴水之恩，当涌泉相报，希望他们用爱回报俄罗斯人民，回报“海洋”中心，回报祖国和人民。今天（17日）19:40，中央电视台综合频道和新闻频道将并机播出专题片《重返爱的海洋》，欢迎您到时收看。（央视记者：申勇、刘爱民、王鹏飞、 汤健、王斌、史伟、石伟明、钟锋、 荆伟、陈汉章、彭汉明、 沈忱、张誉耀、 顾鑫、 沃龙、朱兴建、 白璐、蒋林、牟亮、庞振、张成、黄珊、齐欢） 作者: lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>Joup</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Java [笔记] ---- 通用程序设计(一)]]></title>
    <url>%2F2018%2F09%2F17%2FEffective%20Java%20%5B%E7%AC%94%E8%AE%B0%5D%20----%20%E9%80%9A%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[花了大概一周的时间读了一下&lt;&gt;这本书,作为一个初步涉猎Java开发的小白来说,确实这本书让眼界一亮,是一本浓缩了无数工程师经验的书籍。 下面也将融合以下的内容本篇内容主要介绍通用程序设计相关的主要内容 通用程序设计(一)这里主要记录一下一些常见的“经验” 1.将局部变量的作用域最小化。 将局部变量的作用域最小化,可以增强代码的可读性和可维护性。 要使局部变量的作用域最小化,最有力的方法是在第一次使用它的地方声明。 每个局部变量的声明都应该包含一个初始化表达式 2.for-each循环优先于传统的for循环 for-each循环不会有性能损失,甚至用于数组也是一样。比起普通for循环,它还稍有些性能优势,因为它对数组的索引的边界值只计算一次。 对多个集合进行嵌入式迭代时,for-each优势会更加明显。 如果采用传统方式，迭代器对外部集合调用太多的next方法,并且外部集合是内部集合大小的几倍–可能是因为它们是相同的集合循环会正常终止，产生预期之外的结果。 下面则是这个Bug的一种体现，我们本想打印一对骰子的所有可能的滚法。12345678910111213141516171819202122package com.lhsjohn.effective;import java.util.Arrays;import java.util.Collection;import java.util.Iterator;public class Demo1 &#123; enum Face &#123; ONE, TWO, THREE, FOUR, FIVE, SIX &#125; public static void main(String[] args) &#123; Collection&lt;Face&gt; faces = Arrays.asList(Face.values()); for (Iterator&lt;Face&gt; i = faces.iterator(); i.hasNext();) &#123; for (Iterator&lt;Face&gt; j = faces.iterator(); j.hasNext();) &#123; System.out.println(i.next() + " " + j.next()); &#125; &#125; &#125;&#125; 运行结果123456ONE ONETWO TWOTHREE THREEFOUR FOURFIVE FIVESIX SIX 这个程序不会抛出异常,而是只打印6个重复的词，而不是预计的三十六种组合。 但是采用for-each方式便会很好地避免这个问题 3.了解和使用类库使用标准类库有四大好处 1.可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验。 2.不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。 3.它们的性能往往会随着时间的推移而不断的提高。 4.可以使自己的代码融入主流。 每个程序员都应该书序java.lang 、java.util 、java.io .关于其他类库的知识可以根据需要随时学习。 如果一些类库的工具不能满足我们的需要,那么就只能自己来实现这些功能，别无选择。 总而言之，不要重新发明轮子。 4.如果需要精确的答案，请避免使用float和double float和double类型尤其不适合用于货币计算 可以考虑使用BigDecimal试图作为一种解决方案 5.基本类型优先于装箱基本类型 Java类型系统包括两部分组成，包含基本类型如int、double、boolean和引用类型如String、List. 每个基本类型都有一个对应的引用类型,称作装箱基本类型。装箱基本类型中对应于int、double和boolean的是Integer、Double和Boolean。 Java1.5版本开始增加了自动装箱和自动拆箱. 基本类型和装箱基本类型之间有三个主要区别 基本类型只有值,装箱基本类型则具有与它们的值不同的同一性。 基本类型只有功能完备的值,装箱基本类型除了它对应的基本类型的所有功能值外,还有个非功能值:null 基本类型通常比装箱基本类型节省时间和空间 所有因为有了这些差别，在对数值进行比较的时候就应该要谨慎的使用包箱基本类型。 总之,当可以选择的时候,基本类型要优先于装箱基本类型。基本类型更加简单,也更加快速。当程序使用==操作符比较两个装箱基本类型的时候,它做了个同一性比较,这是我们不想看到的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时,它会进行拆箱,当程序进行拆箱时,会抛出空指针异常。最后当程序装箱了基本类型的值时,会导致高开销和不必要的对象创建。 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>Effective Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Effective Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Solr实现后台搜索[笔记]]]></title>
    <url>%2F2018%2F09%2F14%2F%E7%94%A8Solr%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E6%90%9C%E7%B4%A2%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[今天做了一个搜索的小案例。使用solr服务实现后台的搜索功能,并在前台展示出搜索结果。 下面大体说一下自己的实现方案 1.首先是完成自己solr服务器的配置进入linux上配置的 solr-tomcat2-&gt;solr-home-&gt;collection1-&gt;conf用vim 修改里面的schema.xml文件搜索相关域的信息。 在这里我加入了下面的配置12345678910111213141516171819202122&lt;fieldType name="text_ik" class="solr.TextField"&gt; &lt;analyzer class="org.wltea.analyzer.lucene.IKAnalyzer"/&gt;&lt;/fieldType&gt;&lt;field name="stu_usr_name" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="stu_email" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="stu_phone" type="string" indexed="true" stored="true"/&gt;&lt;field name="ent_usr_name" type="string" indexed="false" stored="true" /&gt;&lt;field name="ent_phone" type="string" indexed="true" stored="true" /&gt;&lt;field name="cmd_name" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="cmd_detail" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="cmd_name" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="cmd_detail" type="text_ik" indexed="true" stored="true"/&gt;&lt;field name="item_keywords" type="text_ik" indexed="true" stored="false" multiValued="true"/&gt;&lt;copyField source="cmd_name" dest="item_keywords"/&gt;&lt;copyField source="cmd_detail" dest="item_keywords"/&gt;&lt;copyField source="cmd_type" dest="item_keywords"/&gt; 2.后台封装了搜索结果类SearchResult1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ffGarden.pojo;import java.util.List;/** * 搜索返回结果 * * @author lihuashuo * */public class SearchResult &#123; private List&lt;ItgCommodity&gt; itgCommodityList; private List&lt;Enterprise&gt; enterpriseList; private List&lt;StuAccount&gt; stuAccountList; public List&lt;ItgCommodity&gt; getItgCommodityList() &#123; return itgCommodityList; &#125; public void setItgCommodityList(List&lt;ItgCommodity&gt; itgCommodityList) &#123; this.itgCommodityList = itgCommodityList; &#125; public List&lt;Enterprise&gt; getEnterpriseList() &#123; return enterpriseList; &#125; public void setEnterpriseList(List&lt;Enterprise&gt; enterpriseList) &#123; this.enterpriseList = enterpriseList; &#125; public List&lt;StuAccount&gt; getStuAccountList() &#123; return stuAccountList; &#125; public void setStuAccountList(List&lt;StuAccount&gt; stuAccountList) &#123; this.stuAccountList = stuAccountList; &#125; @Override public String toString() &#123; return "SearchResult [itgCommodityList=" + itgCommodityList + ", enterpriseList=" + enterpriseList + ", stuAccountList=" + stuAccountList + "]"; &#125; &#125; 通过SpringBoot的单元测试的方式完成了对索引库 的添加。这里有坑,如果不采用SpringBootTest,而是只是使用Junit单元测试的方式,你会发现@Autowired的方式自动注入的属性是空值,所以一直报空指针异常。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package com.ffGarden.solr;import java.io.IOException;import java.util.List;import org.apache.solr.client.solrj.SolrServer;import org.apache.solr.client.solrj.SolrServerException;import org.apache.solr.client.solrj.impl.HttpSolrServer;import org.apache.solr.common.SolrInputDocument;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.springframework.web.bind.annotation.RestController;import com.ffGarden.FfGardenSpringbootApplication;import com.ffGarden.pojo.Enterprise;import com.ffGarden.pojo.ItgCommodity;import com.ffGarden.pojo.StuAccount;import com.ffGarden.service.EnterpriseService;import com.ffGarden.service.ItgCommodityService;import com.ffGarden.service.StuAccountService;import com.ffGarden.service.impl.ItgCommodityServiceImpl;@SpringBootTest(classes = FfGardenSpringbootApplication.class,webEnvironment =SpringBootTest.WebEnvironment.RANDOM_PORT)@RunWith(SpringRunner.class)public class AddDocumet &#123; @Autowired private ItgCommodityService itgCommodityServer; @Autowired private EnterpriseService enterpriseService; @Autowired private StuAccountService stuAccountService; @Autowired private SolrServer solrServer; /** * 将商品信息记录导入索引库 * @throws Exception */ @Test public void addItgCommodityDocument() throws Exception &#123; //ItgCommodityService itgCommodityServer = new ItgCommodityServiceImpl(); //SolrServer solrServer = new HttpSolrServer("http://192.168.1.128:8080/solr/collection1"); // 先从数据库中搜索所有记录 List&lt;ItgCommodity&gt; ItgCommoditylist = itgCommodityServer.getAllCommodities(); // 迭代导入索引库 for (ItgCommodity item : ItgCommoditylist) &#123; // 创建一个文档对象 SolrInputDocument document = new SolrInputDocument(); // 向文档对象中添加域 document.addField("id", "cmd"+item.getItgNumber()); document.addField("cmd_name", item.getCmdName()); document.addField("cmd_detail", item.getCmdDetail()); document.addField("cmd_prise", item.getCmdPrise().intValue()); document.addField("cmd_type", item.getCmdType()); document.addField("cmd_integral", item.getNeedIntegral()); // 写入索引库 solrServer.add(document); &#125; // 提交 solrServer.commit(); &#125; /** * 将学生账户记录导入索引库 * @throws Exception */ @Test public void addStuAccountDocument() throws Exception &#123; //先从数据库中搜索所有的学生账户记录 List&lt;StuAccount&gt; stuAccountList = stuAccountService.getAllStuAccounts(); //迭代导入索引库 for(StuAccount item:stuAccountList) &#123; //创建一个文档对象 SolrInputDocument document = new SolrInputDocument(); document.addField("id", "stu"+item.getStuNumber()); document.addField("stu_phone", item.getStuPhone()); document.addField("stu_usr_name", item.getStuUsrName()); document.addField("stu_email", item.getStuEmail()); //写入索引库 solrServer.add(document); &#125; //提交 solrServer.commit(); &#125; /** * 将企业账户记录导入索引库 */ @Test public void addEnterpriseDocument() throws Exception &#123; //从数据库中获取企业列表 List&lt;Enterprise&gt; enterpriseList = enterpriseService.getEnterpriseList(); //迭代导入索引库 for(Enterprise item : enterpriseList) &#123; SolrInputDocument document = new SolrInputDocument(); document.addField("id", "ent"+item.getEntNumber()); document.addField("ent_usr_name", item.getEntUsrName()); document.addField("ent_phone", item.getEntPhone()); document.addField("ent_email", item.getEntEmail()); //写入索引库 solrServer.add(document); &#125; //提交 solrServer.commit(); &#125; &#125; 下面写了三个搜索的方法，完成设置条件的搜索，分别来搜索商品、企业以及学生用户信息。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * 从索引库根据条件查询学生账户 * * @param query * @return * @throws Exception */ public List&lt;StuAccount&gt; searchStuAccount(SolrQuery query) throws Exception &#123; // 根据查询条件查询索引库 QueryResponse queryResponse = solrServer.query(query); // 取查询结果总记录数 SolrDocumentList solrDocumentList = queryResponse.getResults(); // 创建一个学生账户列表对象 List&lt;StuAccount&gt; accountList = new ArrayList&lt;&gt;(); // 取学生列表 // 取高亮后的结果 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : solrDocumentList) &#123; // 取学生账户的信息 StuAccount account = new StuAccount(); // 获取doc 的id 在这里例如是stu1 String docId = (String) solrDocument.get("id"); // 截取id 把前三位的stu 截取掉,这里变成"1" String stuId = docId.substring(3); account.setStuNumber(Integer.valueOf(stuId)); account.setStuUsrName((String) solrDocument.get("stu_usr_name")); account.setStuEmail((String) solrDocument.get("stu_email")); account.setStuPhone((String) solrDocument.get("stu_phone")); // 取高亮结果 List&lt;String&gt; list = highlighting.get(solrDocument.get("id")).get("stu_usr_name"); String stuName = ""; if (list != null &amp;&amp; list.size() &gt; 0) &#123; stuName = list.get(0); &#125; else &#123; stuName = (String) solrDocument.get("stu_usr_name"); &#125; account.setStuUsrName(stuName); // 添加到商品列表 accountList.add(account); &#125; return accountList; &#125; /** * 从索引库根据条件查询商品信息 * * @param query * @return * @throws Exception */ public List&lt;ItgCommodity&gt; searchItgCommodity(SolrQuery query) throws Exception &#123; // 根据查询条件查询索引库 QueryResponse queryResponse = solrServer.query(query); // 取查询结果总记录数 SolrDocumentList solrDocumentList = queryResponse.getResults(); // 创建一个商品列表对象 List&lt;ItgCommodity&gt; itemList = new ArrayList&lt;&gt;(); // 取商品列表 // 取高亮后的结果 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : solrDocumentList) &#123; // 取商品的信息 ItgCommodity item = new ItgCommodity(); String docId = (String) solrDocument.get("id"); // 截取id 把前三位的stu 截取掉,这里变成"1" String cmdId = docId.substring(3); item.setItgNumber(Integer.valueOf(cmdId)); item.setCmdDetail((String) solrDocument.get("cmd_detail")); item.setCmdType((String) solrDocument.get("cmd_type")); item.setCmdPrise(BigDecimal.valueOf((long) solrDocument.get("cmd_prise"))); item.setNeedIntegral((int) (long) solrDocument.get("cmd_integral")); // 取高亮结果 List&lt;String&gt; list = highlighting.get(solrDocument.get("id")).get("cmd_name"); String cmdName = ""; if (list != null &amp;&amp; list.size() &gt; 0) &#123; cmdName = list.get(0); &#125; else &#123; cmdName = (String) solrDocument.get("cmd_name"); &#125; item.setCmdName(cmdName); // 添加到商品列表 itemList.add(item); &#125; return itemList; &#125; /** * 从索引库根据条件查询企业信息 * * @param query * @return * @throws Exception */ public List&lt;Enterprise&gt; searchEnterprise(SolrQuery query) throws Exception &#123; // 根据查询条件查询索引库 QueryResponse queryResponse = solrServer.query(query); // 取查询结果总记录数 SolrDocumentList solrDocumentList = queryResponse.getResults(); // 创建一个商品列表对象 List&lt;Enterprise&gt; entList = new ArrayList&lt;&gt;(); // 取商品列表 // 取高亮后的结果 Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlighting = queryResponse.getHighlighting(); for (SolrDocument solrDocument : solrDocumentList) &#123; // 取企业的信息 Enterprise enterprise = new Enterprise(); // 获取doc 的id 在这里例如是stu1 String docId = (String) solrDocument.get("id"); // 截取id 把前三位的stu 截取掉,这里变成"1" String entId = docId.substring(3); enterprise.setEntNumber(Integer.valueOf(entId)); enterprise.setEntEmail((String) solrDocument.get("ent_email")); enterprise.setEntPhone((String) solrDocument.get("ent_phone")); // 取高亮结果 List&lt;String&gt; list = highlighting.get(solrDocument.get("id")).get("ent_usr_name"); String cmdName = ""; if (list != null &amp;&amp; list.size() &gt; 0) &#123; cmdName = list.get(0); &#125; else &#123; cmdName = (String) solrDocument.get("ent_usr_name"); &#125; enterprise.setEntUsrName(cmdName); // 添加到商品列表 entList.add(enterprise); &#125; return entList; &#125; 最后是Controller的代码1234567891011121314151617181920212223242526272829303132333435363738@RequestMapping(value = "/searchItems", method = RequestMethod.GET) @ResponseBody public EyeJSONResult searchItems(@RequestParam(value = "content", required = true) String content) throws Exception &#123; // 创建一个SolrQuery对象 SolrQuery query = new SolrQuery(); // 设置查询条件 query.setQuery(content); // 设置默认搜索域 query.set("df", "cmd_name"); // 设置高亮显示 query.setHighlight(true); query.addHighlightField("cmd_name"); query.setHighlightSimplePre("&lt;em style=\"color:red\"&gt;"); query.setHighlightSimplePost("&lt;/em&gt;"); // 执行查询 List&lt;ItgCommodity&gt; itemList = searchItgCommodity(query); // 更换搜索域，搜索学生用户 query.set("df", "stu_usr_name"); query.addHighlightField("stu_usr_name"); List&lt;StuAccount&gt; stuAccountList = searchStuAccount(query); // 更换搜索域,搜索企业用户 query.set("df", "ent_usr_name"); query.addHighlightField("ent_usr_name"); List&lt;Enterprise&gt; enterpriseList = searchEnterprise(query); // 创建搜索结果对象 SearchResult result = new SearchResult(); result.setStuAccountList(stuAccountList); result.setItgCommodityList(itemList); result.setEnterpriseList(enterpriseList); // 打印查询结果 // System.out.println(itemList.toString()); // System.out.println("1111111111111111111"); // System.out.println(content); // SolrJUtils.queryIndex(content); return EyeJSONResult.ok(result); &#125; 最后看一下前端的几处关键的实现store 里面的commodity.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import &#123; default as api &#125; from '../../util/api'const commodity = &#123; state:&#123; cmdNumber: 0, commodityDetail:&#123;&#125;, orderNumber: -1, sumPrice: -1, searchContent: "" &#125;, mutations: &#123; DETAIL:(state, commodityDetail) =&gt; &#123; state.cmdNumber = commodityDetail.cmdNumber state.commodityDetail = commodityDetail &#125;, ORDERNUMBER:(state, orderNumber) =&gt; &#123; state.orderNumber = orderNumber; &#125;, SUMPRICE:(state, sumPrice) =&gt; &#123; state.sumPrice = sumPrice; &#125;, SEARCH:(state,searchContent)=&gt;&#123; state.searchContent = searchContent &#125; &#125;, actions:&#123; getCommodityDetail(&#123; commit, state &#125;, searchContent) &#123; return new Promise((resolve, reject) =&gt; &#123; api(&#123; url: "/search/searchItems", method: "get", params: &#123; content: searchContent &#125; &#125;).then(res =&gt; &#123; state.commodityDetail = res.data; resolve(res); &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;) &#125; &#125;, &#125;export default commodity getters.js 1234567891011121314import commodity from "./modules/commodity";const getters = &#123; receiptInfo:state =&gt; state.enterprise.receiptInfo, commodityDetail:state =&gt; state.commodity.commodityDetail, cmdNumber:state =&gt; state.commodity.cmdNumber, orderNumber:state =&gt; state.commodity.orderNumber, sumPrice:state =&gt; state.commodity.sumPrice, role:state =&gt; state.user.role, userNumber:state =&gt; state.user.userNumber, searchContent:state =&gt; state.commodity.searchContent&#125;export default getters 12345doSearch() &#123; this.$store.commit("SEARCH",this.searchContent) this.$router.push("/studentSearch")&#125; 12345678910111213141516171819computed: &#123; ...mapGetters(["searchContent", "commodityDetail"]) &#125;, created() &#123; this.api(&#123; url: "/search/searchItems", method: "get", params: &#123; content: this.searchContent &#125; &#125;).then(res=&gt;&#123; this.enterpriseList = res.data.enterpriseList; this.stuAccountList = res.data.stuAccountList; this.comodityList = res.data.itgCommodityList; //console.log(res.data) &#125;) //this.getCommodityList(); &#125; 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>Solr</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的反射机制 (二）动态代理]]></title>
    <url>%2F2018%2F09%2F12%2FJava%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%20(%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理类在程序运行时创建的代理方式被成为动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。 12345678Object invoke(Object proxy, 方法 method, Object[] args) throws Throwable处理代理实例上的方法调用并返回结果。 当在与之关联的代理实例上调用方法时，将在调用处理程序中调用此方法。 参数 proxy - 调用该方法的代理实例 method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 1.代理是基本的设计模式之一，下面展示一个用来展示代理结构的小示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.lhsjohn.typeinfo.prac;/** * 这是一个展示代理结构的简单示例 * @author lihuashuo * */interface Interface&#123; void doSomething(); void somethingElse(String arg);&#125;class RealObject implements Interface&#123; @Override public void doSomething() &#123; System.out.println("do something....."); &#125; @Override public void somethingElse(String arg) &#123; System.out.println("somethingElse"+ arg); &#125; &#125;class SimpleProxy implements Interface&#123; private Interface proxied; public SimpleProxy(Interface proxied) &#123; this.proxied = proxied; &#125; @Override public void doSomething() &#123; System.out.println("simpleProxy doSomething"); proxied.doSomething(); &#125; @Override public void somethingElse(String arg) &#123; System.out.println("simpleProxy do Something Else"+arg); proxied.somethingElse(arg); &#125; &#125;public class SimpleProxyDemo &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("hahahhh"); &#125; public static void main(String[] args) &#123; consumer(new RealObject()); consumer(new SimpleProxy(new RealObject())); &#125;&#125; 运行结果 123456do something.....somethingElsehahahhhsimpleProxy doSomethingdo something.....simpleProxy do Something ElsehahahhhsomethingElsehahahhh 2.下面是动态代理的一个简单示例，采用动态代理的方法可以动态地创建代理并动态地处理对代理方法的调用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lhsjohn.typeinfo.prac;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("*****proxy: " + proxy.getClass() + ", method: " + method + ", args:" + args); if (args != null) &#123; for (Object arg : args) &#123; System.out.println(" " + arg); &#125; &#125; return method.invoke(proxied, args); &#125;&#125;public class SimpleDynamicProxy &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("aaaaaaa "); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); Interface proxy = (Interface)Proxy.newProxyInstance(Interface.class.getClassLoader(), new Class[] &#123;Interface.class&#125;, new DynamicProxyHandler(real)); consumer(proxy); &#125; &#125; 运行结果 1234567do something.....somethingElseaaaaaaa *****proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.doSomething(), args:nulldo something.....*****proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.somethingElse(java.lang.String), args:[Ljava.lang.Object;@28d93b30 aaaaaaa somethingElseaaaaaaa 3 过滤某些方法的调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.lhsjohn.typeinfo.prac;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;class MethodSelector implements InvocationHandler&#123; private Object proxied; public MethodSelector(Object proxied) &#123; this.proxied = proxied; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals("interesting")) &#123; System.out.println("Proxy detected the interesting method"); &#125; return method.invoke(proxied, args); &#125; &#125; interface SomeMethods&#123; void boring1(); void boring2(); void interesting(String arg); void boring3();&#125;class Implementation implements SomeMethods&#123; @Override public void boring1() &#123; System.out.println("boring1"); &#125; @Override public void boring2() &#123; System.out.println("boring2"); &#125; @Override public void interesting(String arg) &#123; System.out.println("interesting "+ arg); &#125; @Override public void boring3() &#123; System.out.println("boring3"); &#125; &#125;public class SelectingMethods &#123; public static void main(String[] args) &#123; SomeMethods proxy = (SomeMethods) Proxy.newProxyInstance(SomeMethods.class.getClassLoader(), new Class[] &#123;SomeMethods.class&#125;, new MethodSelector(new Implementation())); proxy.boring1(); proxy.boring2(); proxy.interesting("sdfsdfs"); proxy.boring3(); &#125;&#125; 运行结果: 12345boring1boring2Proxy detected the interesting methodinteresting sdfsdfsboring3 4.修改SimpleProxyDemo.java,使其可以度量方法调用的次数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.lhsjohn.typeinfo.prac;import java.util.Date;interface Interface&#123; void doSomething(); void somethingElse(String arg);&#125;class RealObject implements Interface&#123; @Override public void doSomething() &#123; System.out.println("doSomething"); &#125; @Override public void somethingElse(String arg) &#123; System.out.println("somethingElse "+arg); &#125; &#125;class SimpleProxy implements Interface&#123; private Interface proxied; private static int doCount = 0; private static int sEcount = 0; public SimpleProxy(Interface proxied) &#123; this.proxied = proxied; &#125; @Override public void doSomething() &#123; long timeIn = new Date().getTime(); System.out.println("Time called doSomething() " + doCount+" : "+timeIn+" msecs"); System.out.println("on " + new Date()); doCount++; proxied.doSomething(); System.out.println("Call-return time = "+(new Date().getTime()-timeIn)+ "msecs"); &#125; @Override public void somethingElse(String arg) &#123; long timeIn = new Date().getTime(); System.out.println("Time called somethingElse() " + doCount+" : "+timeIn+" msecs"); System.out.println("on " + new Date()); doCount++; proxied.somethingElse(arg); System.out.println("Call-return time = "+(new Date().getTime()-timeIn)+ "msecs"); &#125; &#125;public class SimpleProxyDemo21 &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("bonobo"); &#125; public static void main(String[] args) &#123; consumer(new RealObject()); System.out.println(); consumer(new SimpleProxy(new RealObject())); System.out.println(); consumer(new SimpleProxy(new RealObject())); System.out.println(); consumer(new SimpleProxy(new RealObject())); &#125;&#125; 运行结果: 1234567891011121314151617181920212223242526272829doSomethingsomethingElse bonoboTime called doSomething() 0 : 1536732268520 msecson Wed Sep 12 14:04:28 CST 2018doSomethingCall-return time = 17msecsTime called somethingElse() 1 : 1536732268537 msecson Wed Sep 12 14:04:28 CST 2018somethingElse bonoboCall-return time = 0msecsTime called doSomething() 2 : 1536732268537 msecson Wed Sep 12 14:04:28 CST 2018doSomethingCall-return time = 0msecsTime called somethingElse() 3 : 1536732268537 msecson Wed Sep 12 14:04:28 CST 2018somethingElse bonoboCall-return time = 0msecsTime called doSomething() 4 : 1536732268537 msecson Wed Sep 12 14:04:28 CST 2018doSomethingCall-return time = 0msecsTime called somethingElse() 5 : 1536732268537 msecson Wed Sep 12 14:04:28 CST 2018somethingElse bonoboCall-return time = 0msecs 5.修改SimpleDynamicProxy.java 使其可以度量方法调用的次数123456789101112131415161718192021222324252627282930313233343536373839404142package com.lhsjohn.typeinfo.prac;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Date;class DynamicProxyHandler2 implements InvocationHandler &#123; private Object proxied; public DynamicProxyHandler2(Object proxied) &#123; this.proxied = proxied; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; long timeIn = new Date().getTime(); System.out.println("**** proxy: " + proxy.getClass() + ", method: " + method + ", args: " + args + ", invoked at " + timeIn + " on " + (new Date())); if(args != null) for(Object arg : args) System.out.println(" " + args); long timeOut = new Date().getTime(); System.out.println("Method call-return time: " + (timeOut - timeIn) + " msecs"); return method.invoke(proxied, args); &#125;&#125;public class SimpleDynamicProxy22 &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("bonobo"); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); // Insert a proxy and call again: Interface proxy = (Interface)Proxy.newProxyInstance( Interface.class.getClassLoader(), new Class[]&#123; Interface.class &#125;, new DynamicProxyHandler2(real)); consumer(proxy); &#125;&#125; 运行结果 123456789doSomethingsomethingElse bonobo**** proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.doSomething(), args: null, invoked at 1536732359159 on Wed Sep 12 14:05:59 CST 2018Method call-return time: 17 msecsdoSomething**** proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@1540e19d, invoked at 1536732359176 on Wed Sep 12 14:05:59 CST 2018 [Ljava.lang.Object;@1540e19dMethod call-return time: 0 msecssomethingElse bonobo 6.在SimpleDynamicProxy.java的invoke()内部，尝试打印proxy参数123456789101112131415161718192021222324252627282930313233343536package com.lhsjohn.typeinfo.prac;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;class DynamicProxyHandler implements InvocationHandler &#123; private Object proxied; public DynamicProxyHandler(Object proxied) &#123; this.proxied = proxied; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("**** proxy: " + proxy.getClass() + ", method: " + method + ", args: " + args); if(args != null) for(Object arg : args) System.out.println(" " + args); return method.invoke(proxied, args); &#125;&#125;class SimpleDynamicProxy23 &#123; public static void consumer(Interface iface) &#123; iface.doSomething(); iface.somethingElse("bonobo"); &#125; public static void main(String[] args) &#123; RealObject real = new RealObject(); consumer(real); Interface proxy = (Interface)Proxy.newProxyInstance( Interface.class.getClassLoader(), new Class[]&#123; Interface.class &#125;, new DynamicProxyHandler(real)); consumer(proxy); &#125;&#125; 运行结果: 1234567doSomethingsomethingElse bonobo**** proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.doSomething(), args: nulldoSomething**** proxy: class com.lhsjohn.typeinfo.prac.$Proxy0, method: public abstract void com.lhsjohn.typeinfo.prac.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@28d93b30 [Ljava.lang.Object;@28d93b30somethingElse bonobo]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>反射机制</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度音乐接口]]></title>
    <url>%2F2018%2F09%2F08%2F%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[推荐先装一下JSONView插件 百度音乐全接口http://tingapi.ting.baidu.com/v1/restserver/ting 请求方式：GET 参数处理：format=json&amp;calback=&amp;from=webapp_music&amp;method=以下不同的参数获得不同的数据 一、获取列表例：method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0 参数： type = 1-新歌榜,2-热歌榜,11-摇滚榜,12-爵士,16-流行,21-欧美金曲榜,22-经典老歌榜,23-情歌对唱榜,24-影视金曲榜,25-网络歌曲榜 size = 10 //返回条目数量 offset = 0 //获取偏移 二、搜索例：method=baidu.ting.search.catalogSug&amp;query=海阔天空 参数：query = ” //搜索关键字 三、播放例：method=baidu.ting.song.play&amp;songid=877578 例：method=baidu.ting.song.playAAC&amp;songid=877578 参数：songid = 877578 //歌曲id 注：关于使用file_link不能播放的问题，是因为百度使用Http中的Referer头字段来防止盗链，在HTML文件中加上 这一句让发送出去的Http包都不含Referer字段就行了 四、lrc歌词例：method=baidu.ting.song.lry&amp;songid=877578 参数：songid = 877578 //歌曲id 五、推荐列表例：method=baidu.ting.song.getRecommandSongList&amp;song_id=877578&amp;num=5 参数： song_id = 877578 num = 5//返回条目数量 六、下载例：method=baidu.ting.song.downWeb&amp;songid=877578&amp;bit=24&amp;_t=1393123213 参数： songid = 877578//歌曲id bit = 24, 64, 128, 192, 256, 320 ,flac//码率 _t = 1430215999,, //时间戳 七、获取歌手信息例：method=baidu.ting.artist.getInfo&amp;tinguid=877578 参数： tinguid = 877578 //歌手ting id 八、获取歌手歌曲列表例：method=baidu.ting.artist.getSongList&amp;tinguid=877578&amp;limits=6&amp;use_cluster=1&amp;order=2 参数： tinguid = 877578//歌手ting id limits = 6//返回条目数量]]></content>
      <categories>
        <category>学习</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Vue.js</tag>
        <tag>音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeInfo (二) prac2]]></title>
    <url>%2F2018%2F09%2F06%2FTypeInfo%20(%E4%BA%8C)%20prac2%2F</url>
    <content type="text"><![CDATA[常见的RTTI的形式 传统的类型转换 例如(Shape). 代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。 关键字instanceof。返回一个布尔值,来告诉我们对象是不是某个特定类型的实例。 下面写一个Individual的继承体系Individual.java12345678910111213141516171819202122232425262728293031323334353637383940package typeinfo.pets;public class Individual implements Comparable&lt;Individual&gt; &#123; private static long counter = 0; private final long id = counter++; private String name; public Individual(String name) &#123; this.name = name; &#125; // 'name' is optional: public Individual() &#123;&#125; public String toString() &#123; return getClass().getSimpleName() + (name == null ? "" : " " + name); &#125; public long id() &#123; return id; &#125; public boolean equals(Object o) &#123; return o instanceof Individual &amp;&amp; id == ((Individual)o).id; &#125; public int hashCode() &#123; int result = 17; if(name != null) result = 37 * result + name.hashCode(); result = 37 * result + (int)id; return result; &#125; public int compareTo(Individual arg) &#123; // Compare by class name first: String first = getClass().getSimpleName(); String argFirst = arg.getClass().getSimpleName(); int firstCompare = first.compareTo(argFirst); if(firstCompare != 0) return firstCompare; if(name != null &amp;&amp; arg.name != null) &#123; int secondCompare = name.compareTo(arg.name); if(secondCompare != 0) return secondCompare; &#125; return (arg.id &lt; id ? -1 : (arg.id == id ? 0 : 1)); &#125;&#125; Person.java12345package typeinfo.pets;public class Person extends Individual&#123; public Person (String name) &#123; super(name) ;&#125;&#125; Pet.java123456package typeinfo.pets;public class Pet extends Individual&#123; public Pet(String name) &#123; super(name); &#125; public Pet() &#123; super(); &#125;&#125; Dog.java123456package typeinfo.pets;public class Dog extends Pet &#123; public Dog(String name) &#123; super(name); &#125; public Dog() &#123;super();&#125;&#125; Mutt.java12345678910111213package typeinfo.pets;public class Mutt extends Dog &#123; public Mutt() &#123; super(); &#125; public Mutt(String name) &#123; super(name); &#125; &#125; Pug.java12345678910111213package typeinfo.pets;public class Pug extends Dog &#123; public Pug() &#123; super(); &#125; public Pug(String name) &#123; super(name); &#125; &#125; Cat.java123456789101112package typeinfo.pets;public class Cat extends Dog &#123; public Cat(String name) &#123; super(name); &#125; public Cat() &#123; &#125;&#125; EgyptianMau.java1234567891011121314package typeinfo.pets;public class EgyptianMau extends Cat &#123; public EgyptianMau(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public EgyptianMau() &#123; // TODO Auto-generated constructor stub &#125;&#125; Manx.java1234567891011121314package typeinfo.pets;public class Manx extends Cat &#123; public Manx(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Manx() &#123; // TODO Auto-generated constructor stub &#125;&#125; Cymric.java1234567891011121314package typeinfo.pets;public class Cymric extends Manx &#123; public Cymric(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Cymric() &#123; // TODO Auto-generated constructor stub &#125;&#125; Rodent.java1234567891011121314package typeinfo.pets;public class Rodent extends Pet &#123; public Rodent(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Rodent() &#123; // TODO Auto-generated constructor stub &#125;&#125; Rat.java1234567891011121314package typeinfo.pets;public class Rat extends Rodent &#123; public Rat(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Rat() &#123; // TODO Auto-generated constructor stub &#125;&#125; Mouse.java1234567891011121314package typeinfo.pets;public class Mouse extends Rodent &#123; public Mouse(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Mouse() &#123; // TODO Auto-generated constructor stub &#125;&#125; Hamster.java1234567891011121314package typeinfo.pets;public class Hamster extends Rodent &#123; public Hamster(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; public Hamster() &#123; // TODO Auto-generated constructor stub &#125;&#125; 1.下面我们写一些方法来随机产生一些宠物,为了适应不同的实现,将其定义为抽象类1234567891011121314151617181920212223242526272829303132333435363738394041package typeinfo.pets;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Random;public abstract class PetCreator &#123; private Random rand = new Random(47); public abstract List&lt;Class&lt;? extends Pet&gt;&gt; types(); public Pet randomPet() &#123; int n = rand.nextInt(types().size()); try &#123; return types().get(n).newInstance(); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; public Pet[] createArray(int size) &#123; Pet[] result = new Pet[size]; for(int i = 0;i &lt; size; i++) &#123; result[i] = randomPet(); &#125; return result; &#125; public ArrayList&lt;Pet&gt; arrayList(int size)&#123; ArrayList&lt;Pet&gt; result = new ArrayList&lt;Pet&gt;(); Collections.addAll(result, createArray(size)); return result; &#125; &#125; 2.下面是使用ForName的一个具体实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package typeinfo.pets;import java.sql.Types;import java.util.ArrayList;import java.util.List;public class ForNameCreator extends PetCreator &#123; private static List&lt;Class&lt;? extends Pet&gt;&gt; types = new ArrayList&lt;Class&lt;? extends Pet&gt;&gt;(); private static String[] typeNames = &#123; "typeinfo.pets.Mutt", "typeinfo.pets.Pug", "typeinfo.pets.EgyptianMau", "typeinfo.pets.Manx", "typeinfo.pets.Cymric", "typeinfo.pets.Rat", "typeinfo.pets.Mouse", "typeinfo.pets.Hamster" &#125;; @SuppressWarnings("unchecked") private static void loader() &#123; for (String name : typeNames) &#123; try &#123; types.add((Class&lt;? extends Pet&gt;)Class.forName(name)); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; static &#123; loader(); &#125; @Override public List&lt;Class&lt;? extends Pet&gt;&gt; types() &#123; return types; &#125; &#125; 在这里,为了产生具有实际类型的Class对象的List,必须使用转型。 3.用instanceof对Pet进行计数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package typeinfo.pets;import java.util.HashMap;import org.w3c.dom.css.Counter;public class PetCount &#123; static class PetCounter extends HashMap&lt;String, Integer&gt;&#123; public void count(String type) &#123; Integer quantity = get(type); if(quantity==null) &#123; put(type,1); &#125;else &#123; put(type,quantity+1); &#125; &#125;&#125; public static void countPets(PetCreator creator) &#123; PetCounter counter = new PetCounter(); for(Pet pet : creator.createArray(20)) &#123; System.out.println(pet.getClass().getSimpleName()+" "); if(pet instanceof Pet) &#123; counter.count("Pet"); &#125; if(pet instanceof Dog) &#123; counter.count("Dog"); &#125; if(pet instanceof Mutt) &#123; counter.count("Mutt"); &#125; if(pet instanceof Pug) &#123; counter.count("Pug"); &#125; if(pet instanceof Cat) &#123; counter.count("Cat"); &#125; if(pet instanceof Manx)&#123; counter.count("EgyptianMau"); &#125; if(pet instanceof Manx) &#123; counter.count("Cymric"); &#125; if(pet instanceof Manx) &#123; counter.count("Manx"); &#125; if(pet instanceof Rodent) &#123; counter.count("Rodent"); &#125; if(pet instanceof Rat) &#123; counter.count("Rat"); &#125; if(pet instanceof Mouse) &#123; counter.count("Mouse"); &#125; if(pet instanceof Hamster) &#123; counter.count("Hamster"); &#125; &#125; System.out.println(); System.out.println(counter); &#125; public static void main(String[] args) &#123; countPets(new ForNameCreator()); &#125; &#125; 输出结果: 12345678910111213141516171819202122Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric &#123;EgyptianMau=7, Pug=3, Rat=2, Cymric=7, Mouse=2, Cat=9, Manx=7, Rodent=5, Mutt=3, Dog=15, Pet=20, Hamster=1&#125; 4.使用类字面量进行计数1234567891011121314151617181920212223242526272829package typeinfo.pets;import java.util.Arrays;import java.util.Collections;import java.util.List;public class LiteralPetCreator extends PetCreator &#123; public static final List&lt;Class&lt;? extends Pet&gt;&gt; allTypes = Collections.unmodifiableList(Arrays.asList( Pet.class,Dog.class,Cat.class,Rodent.class,Mutt.class,Pug.class,EgyptianMau.class,Manx.class,Cymric.class, Rat.class,Mouse.class,Hamster.class)); private static final List&lt;Class&lt;? extends Pet&gt;&gt; types = allTypes.subList(allTypes.indexOf(Mutt.class), allTypes.size()); @Override public List&lt;Class&lt;? extends Pet&gt;&gt; types() &#123; // TODO Auto-generated method stub return types; &#125; public static void main(String[] args) &#123; System.out.println(types); &#125; &#125; 输出结果: 1[class typeinfo.pets.Mutt, class typeinfo.pets.Pug, class typeinfo.pets.EgyptianMau, class typeinfo.pets.Manx, class typeinfo.pets.Cymric, class typeinfo.pets.Rat, class typeinfo.pets.Mouse, class typeinfo.pets.Hamster] 5.现在类库中有了两种PetCreator的是实现,为了将第二种作为默认实现,创建一个使用了LiteralPetCreator的外观1234567891011121314151617181920212223242526package typeinfo.pets;import java.util.ArrayList;public class Pets &#123; public static final PetCreator creator = new LiteralPetCreator(); public static Pet randomPet() &#123; return creator.randomPet(); &#125; public static Pet[] createArray(int size) &#123; return creator.createArray(size); &#125; public static ArrayList&lt;Pet&gt; arrayList(int size)&#123; return creator.arrayList(size); &#125; &#125; 下面来测试一下1234567891011package typeinfo.pets;public class PetCount2 &#123; public static void main(String[] args) &#123; PetCount.countPets(Pets.creator); &#125;&#125; 输出结果: 12345678910111213141516171819202122Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric &#123;EgyptianMau=7, Pug=3, Rat=2, Cymric=7, Mouse=2, Cat=9, Manx=7, Rodent=5, Mutt=3, Dog=15, Pet=20, Hamster=1&#125; 6.动态的instanceof123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package typeinfo.pets;import java.util.LinkedHashMap;import java.util.Map;import typeinfo.utils.MapData;public class PetCount3 &#123; static class PetCounter extends LinkedHashMap&lt;Class&lt;? extends Pet&gt;, Integer&gt; &#123; public PetCounter() &#123; super(MapData.map(LiteralPetCreator.allTypes,0)); &#125; public void count(Pet pet) &#123; for(Map.Entry&lt;Class&lt;? extends Pet&gt;,Integer&gt; pair:entrySet()) &#123; if(pair.getKey().isInstance(pet)) &#123; put(pair.getKey(),pair.getValue()+1); &#125; &#125; &#125; public String toString() &#123; StringBuilder result = new StringBuilder("&#123;"); for(Map.Entry&lt;Class&lt;?extends Pet&gt;, Integer&gt; pair: entrySet()) &#123; result.append(pair.getKey().getSimpleName()); result.append("="); result.append(pair.getValue()); result.append(", "); &#125; result.delete(result.length()-2, result.length()); result.append("&#125;"); return result.toString(); &#125; &#125; public static void main(String[] args) &#123; PetCounter petCount = new PetCounter(); for(Pet pet:Pets.createArray(20)) &#123; System.out.println(pet.getClass().getSimpleName()+ " "); petCount.count(pet); &#125; System.out.println(); System.out.println(petCount); &#125; &#125; 输出结果: 12345678910111213141516171819202122Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt Cymric Mouse Pug Mouse Cymric &#123;Pet=20, Dog=15, Cat=9, Rodent=5, Mutt=3, Pug=3, EgyptianMau=2, Manx=7, Cymric=5, Rat=2, Mouse=2, Hamster=1&#125; 7.递归计数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package typeinfo.pets;import java.util.HashMap;import java.util.Map;public class TypeCounter extends HashMap&lt;Class&lt;?&gt;, Integer&gt; &#123; private Class&lt;?&gt; baseType; public TypeCounter(Class&lt;?&gt; baseType) &#123; this.baseType = baseType; &#125; public void count(Object obj) &#123; Class&lt;?&gt;type = obj.getClass(); if(!baseType.isAssignableFrom(type)) &#123; throw new RuntimeException(obj + "incorrect type :"+type + "should be type or subtype of "+baseType ); &#125; countClass(type); &#125; public void countClass(Class&lt;?&gt; type) &#123; Integer quantity = get(type); put(type,quantity == null? 1:quantity+1); Class&lt;?&gt; superClass = type.getSuperclass(); if(superClass != null &amp;&amp; baseType.isAssignableFrom(superClass)) &#123; countClass(superClass); &#125; &#125; public String toString() &#123; StringBuilder result = new StringBuilder("&#123;"); for (Map.Entry&lt;Class&lt;?&gt;, Integer&gt; pair : entrySet()) &#123; result.append(pair.getKey().getSimpleName()); result.append("="); result.append(pair.getValue()); result.append(","); &#125; result.delete(result.length()-2, result.length()); result.append("&#125;"); return result.toString(); &#125; &#125; 12345678910111213141516package typeinfo.pets;public class PetCount4 &#123; public static void main(String[] args) &#123; TypeCounter counter = new TypeCounter(Pet.class); for(Pet pet :Pets.createArray(15)) &#123; System.out.print(pet.getClass().getSimpleName()+" "); counter.count(pet); &#125; System.out.println(); System.out.println(counter); &#125;&#125; 输出结果: 12Rat Manx Cymric Mutt Pug Cymric Pug Manx Cymric Rat EgyptianMau Hamster EgyptianMau Mutt Mutt &#123;Rat=2,Rodent=3,Cymric=3,Mutt=3,EgyptianMau=2,Pug=2,Cat=7,Manx=5,Hamster=1,Dog=12,Pet=1&#125; 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
        <tag>Thinking in java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeInfo (一) prac1]]></title>
    <url>%2F2018%2F09%2F06%2FTypeInfo%20(%E4%B8%80)%20prac1%2F</url>
    <content type="text"><![CDATA[RTTI通过运行时类型信息程序能够使用基类的引用或指针来检查，这些引用或者指针所指向的对象的实际派生类型。 1.使用RTTI,可以查询某个Shape引用所指向的对象的确切类型,然后选择或者剔除特例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lhsjohn.typeinfo.prac;import java.util.Arrays;import java.util.List;abstract class Shape&#123; void draw() &#123;System.out.println(this+".draw()");&#125; abstract public String toString();&#125;class Circle extends Shape&#123; @Override public String toString() &#123; return "Circle"; &#125; &#125;class Square extends Shape&#123; @Override public String toString() &#123; return "Square"; &#125; &#125;class Triangle extends Shape&#123; @Override public String toString() &#123; return "Triangle"; &#125; &#125;public class Shapes &#123; public static void main(String[] args) &#123; List&lt;Shape&gt; shapeList=Arrays.asList(new Circle(),new Square(),new Triangle()); for(Shape shape:shapeList) &#123; shape.draw(); &#125; &#125;&#125; 运行结果： 123Circle.draw()Square.draw()Triangle.draw() 2.一旦某个类的Class对象被载入内存,它就被用来创建这个类的所有对象PS:所有的类都是在对其第一次使用时，动态加载到JVM中的。这个证明构造器也是类的静态方法，即使在构造器之前没有使用static关键字。 下面的程序说明了这个问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lhsjohn.typeinfo.prac;/** * 一旦某个类的Class对象被载入内存,它就被用来创建这个类的所有对象 * @author lihuashuo * */class Candy&#123; static &#123; System.out.println("Loading Candy"); &#125;&#125;class Gum&#123; static &#123; System.out.println("Loading Gum"); &#125;&#125;class Cookie&#123; static &#123; System.out.println("Loading Cookie"); &#125;&#125;public class SweetShop &#123; public static void main(String[] args) &#123; System.out.println("inside main"); new Candy(); System.out.println("After creating Candy"); try &#123; Class.forName("com.lhsjohn.typeinfo.prac.Gum"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("Couldn't find Gum"); &#125; System.out.println("After Class.forName(\"com.lhsjohn.typeinfo.prac.Gum\")"); new Cookie(); System.out.println("After creating Cookie"); &#125; &#125; 运行结果:1234567inside mainLoading CandyAfter creating CandyLoading GumAfter Class.forName("com.lhsjohn.typeinfo.prac.Gum")Loading CookieAfter creating Cookie 从输出中可以看到,Class对象仅在需要的时候才被加载,static初始化是在类被加载时进行的。 3. Class 类一些有用的方法的演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.lhsjohn.typeinfo.prac; interface HasBatteries&#123;&#125; interface Waterproof&#123;&#125; interface Shoots&#123;&#125; class Toy&#123; Toy()&#123;&#125; Toy(int i)&#123;&#125; &#125; class FancyToy extends Toy implements HasBatteries,Waterproof,Shoots&#123; FancyToy()&#123; super(1); &#125; &#125; public class ToyTest &#123; static void printInfo(Class cc) &#123; System.out.println("Class name: "+cc.getName()+" is interface? ["+cc.isInterface()+"]"); System.out.println("Simple name: "+cc.getSimpleName()); System.out.println("Canonical name: "+cc.getCanonicalName()); &#125; public static void main(String[] args) &#123; Class c=null; try &#123; c = Class.forName("com.lhsjohn.typeinfo.prac.FancyToy"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("Can't find FancyToy"); System.exit(1); &#125; printInfo(c); for(Class face : c.getInterfaces()) &#123; printInfo(face); &#125; Class up = c.getSuperclass(); Object obj = null; try &#123; obj = up.newInstance(); &#125; catch (InstantiationException e) &#123; System.out.println("Can't not Instantiate"); System.exit(1); &#125; catch (IllegalAccessException e) &#123; System.out.println("Cannot access"); System.exit(1); &#125; printInfo(obj.getClass()); &#125; &#125; 运行结果： 123456789101112131415Class name: com.lhsjohn.typeinfo.prac.FancyToy is interface? [false]Simple name: FancyToyCanonical name: com.lhsjohn.typeinfo.prac.FancyToyClass name: com.lhsjohn.typeinfo.prac.HasBatteries is interface? [true]Simple name: HasBatteriesCanonical name: com.lhsjohn.typeinfo.prac.HasBatteriesClass name: com.lhsjohn.typeinfo.prac.Waterproof is interface? [true]Simple name: WaterproofCanonical name: com.lhsjohn.typeinfo.prac.WaterproofClass name: com.lhsjohn.typeinfo.prac.Shoots is interface? [true]Simple name: ShootsCanonical name: com.lhsjohn.typeinfo.prac.ShootsClass name: com.lhsjohn.typeinfo.prac.Toy is interface? [false]Simple name: ToyCanonical name: com.lhsjohn.typeinfo.prac.Toy 4.写一个方法,令它接受任意对象为参数，并且能够递归打印出该对象所在的继承体系中的所有类。1234567891011121314151617181920212223242526package com.lhsjohn.typeinfo.prac;class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125;public class Ex8 &#123; public static void Hierarchy(Object o) &#123; if(o.getClass().getSuperclass() != null) &#123; System.out.println(o.getClass() + " is a subclass of " + o.getClass().getSuperclass()); try &#123; Hierarchy(o.getClass().getSuperclass().newInstance()); &#125; catch(InstantiationException e) &#123; System.out.println("Unable to instantiate obj"); &#125; catch(IllegalAccessException e) &#123; System.out.println("Unable to access"); &#125; &#125; &#125; public static void main(String[] args) &#123; Hierarchy(new C()); &#125;&#125; 输出结果： 123class com.lhsjohn.typeinfo.prac.C is a subclass of class com.lhsjohn.typeinfo.prac.Bclass com.lhsjohn.typeinfo.prac.B is a subclass of class com.lhsjohn.typeinfo.prac.Aclass com.lhsjohn.typeinfo.prac.A is a subclass of class java.lang.Object 4.用Class.getDeclaredFields()来打印一个类中的域的相关信息1234567891011121314151617181920212223242526272829303132333435package com.lhsjohn.typeinfo.prac;class A &#123; int i; String s; &#125;class B extends A &#123; int j; float f; &#125;class C extends B &#123; int k; B b;&#125;public class Ex9 &#123; public static void Hierarchy(Object o) &#123; Object[] fields = o.getClass().getDeclaredFields(); if(fields.length == 0) System.out.println(o.getClass() + " has no fields"); if(fields.length &gt; 0) &#123; System.out.println("Field(s) of " + o.getClass() + ":"); for(Object obj : fields) System.out.println(" " + obj); &#125; if(o.getClass().getSuperclass() != null) &#123; System.out.println(o.getClass() + " is a subclass of " + o.getClass().getSuperclass()); try &#123; Hierarchy(o.getClass().getSuperclass().newInstance()); &#125; catch(InstantiationException e) &#123; System.out.println("Unabloe to instantiate obj"); &#125; catch(IllegalAccessException e) &#123; System.out.println("Unable to access"); &#125; &#125; &#125; public static void main(String[] args) &#123; Hierarchy(new C()); &#125;&#125; 输出结果：12345678910111213Field(s) of class com.lhsjohn.typeinfo.prac.C: int com.lhsjohn.typeinfo.prac.C.k com.lhsjohn.typeinfo.prac.B com.lhsjohn.typeinfo.prac.C.bclass com.lhsjohn.typeinfo.prac.C is a subclass of class com.lhsjohn.typeinfo.prac.BField(s) of class com.lhsjohn.typeinfo.prac.B: int com.lhsjohn.typeinfo.prac.B.j float com.lhsjohn.typeinfo.prac.B.fclass com.lhsjohn.typeinfo.prac.B is a subclass of class com.lhsjohn.typeinfo.prac.AField(s) of class com.lhsjohn.typeinfo.prac.A: int com.lhsjohn.typeinfo.prac.A.i java.lang.String com.lhsjohn.typeinfo.prac.A.sclass com.lhsjohn.typeinfo.prac.A is a subclass of class java.lang.Objectclass java.lang.Object has no fields 5.泛化的Class引用123456789101112131415161718192021package com.lhsjohn.typeinfo.prac;/** * 泛化的Class引用 * @author lihuashuo * */public class GenericClassReferences &#123; public static void main(String[] args) &#123; Class intClass = int.class; Class&lt;Integer&gt; generateIntClass = int.class; generateIntClass = intClass; intClass = double.class; //不合法的 //generateIntClass = double.class; &#125; &#125; 注意点：下面的用法是不合法的1Class&lt;Number&gt; genericNumberClass = int.class; 虽然Integer继承自Number,但是Integer Class对象不是Number Class对象的子类 6 向Class引用添加泛型语法12345678910111213package com.lhsjohn.typeinfo.prac;public class BoundedClassReferences &#123; public static void main(String[] args) &#123; //向Class引用添加泛型语法的原因仅仅是为了提供编译期类型检查 Class&lt;?extends Number&gt; bounded = int.class; bounded = double.class; bounded = Number.class; //或者是其他的从Number派生的 &#125;&#125; 向Class对象添加泛型语法的原因仅仅是为了提供编译期类型检查. 7.使用泛型类语法产生一个List123456789101112131415161718192021222324252627282930313233343536package com.lhsjohn.typeinfo.prac;import java.util.ArrayList;import java.util.List;class CountedInteger&#123; private static long counter; private final long id = counter++; public String toString() &#123; return Long.toString(id); &#125; &#125; public class FilledList&lt;T&gt;&#123; private Class&lt;T&gt; type ; public FilledList(Class&lt;T&gt; type) &#123; this.type = type; &#125; public List&lt;T&gt; create(int nElements)&#123; List&lt;T&gt; result = new ArrayList&lt;T&gt;(); for(int i = 0; i &lt; nElements;i++) &#123; try &#123; result.add(type.newInstance()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; FilledList&lt;CountedInteger&gt; fl = new FilledList&lt;CountedInteger&gt;(CountedInteger.class); System.out.println(fl.create(15)); &#125;&#125; 输出结果： 1[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] 8. 将泛型语法用于Class对象时, newInstance()将返回该对象的确切类型。123456789101112131415package com.lhsjohn.typeinfo.prac;public class GenericToyTest &#123; public static void main(String[] args) throws Exception &#123; Class &lt;FancyToy&gt; ftClass = FancyToy.class; FancyToy fancyToy = ftClass.newInstance(); Class&lt;? super FancyToy&gt; up =ftClass.getSuperclass(); Object object = up.newInstance(); &#125;&#125; 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
        <tag>Thinking in java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 字符串 (三) Prac3]]></title>
    <url>%2F2018%2F09%2F03%2FString%20%E5%AD%97%E7%AC%A6%E4%B8%B2%20(%E4%B8%89%EF%BC%89Prac3%2F</url>
    <content type="text"><![CDATA[&lt;开学第一天&gt; 今日份dai码 |0-0| 1.正则表达式与JAVA I/O下面我们将演示如何应用正则表达式在文件中进行搜索匹配操作 1234567891011121314151617181920package com.lhsjohn.pr.string;//: strings/JGrep.java// A very simple version of the "grep" program.// &#123;Args: JGrep.java "\\b[Ssct]\\w+"&#125;import java.util.regex.*;public class JGrep &#123; public static void main(String[] args) throws Exception &#123; Pattern p = Pattern.compile("\\b[Ssct]\\w+"); int index = 0; Matcher m = p.matcher(""); for(String line : new TextFile("F:\\Study\\java\\DesignerPattern\\PracticeString\\src\\com\\lhsjohn\\pr\\string\\JGrep.java")) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group() + ": " + m.start()); &#125; &#125;&#125; 注意:这里的TextFile的作用是将文件打开，读入所有的行后，存储在一个Array List中。 运行结果: 123456789101112131415161718190: com: 81: string: 232: strings: 43: simple: 104: the: 285: Ssct: 266: class: 77: static: 98: String: 269: throws: 4110: compile: 2411: Ssct: 3712: String: 813: Study: 4014: src: 8615: com: 9116: string: 10917: System: 818: start: 31 2. 修改JGrep.java类，令其能够接受一个目录或者文件为参数，如果传入的是目录，就搜索目录中的所有文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.lhsjohn.pr.string;import java.io.File;import java.util.Arrays;import java.util.regex.Matcher;import java.util.regex.Pattern;public class JGrep16 &#123; private static String directoryName ="F:\\Study\\java\\DesignerPattern\\test"; public static void main(String[] args) throws Exception &#123; Pattern p = Pattern.compile("\\b[Ssct]\\w+"); Matcher d = Pattern.compile("\\w+\\.&#123;1&#125;\\w+").matcher(directoryName); if(d.find()) &#123; System.out.println("File: " + directoryName); // Iterate through the lines of the input file: int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object for(String line : new TextFile(directoryName)) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group() + ": " + m.start()); &#125; &#125; Matcher e = Pattern.compile("^\\.&#123;1&#125;$").matcher(directoryName); if(e.find()) &#123; File[] files = new File(directoryName).listFiles(); System.out.println("root dir of files: " + Arrays.asList(files)); // Iterate through the lines of each file in directory: for(File f : files) &#123; if(f.getName().matches("\\w+\\.&#123;1&#125;\\w+")) &#123; System.out.println(f.getName() + ":"); int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object for(String line : new TextFile(f.getName())) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group() + ": " + m.start()); &#125; &#125; System.out.println(); &#125; &#125; d.reset(); e.reset(); if(!(d.find() || e.find())) &#123; if(new File(directoryName).listFiles() == null) &#123; System.out.println("no such directory: " + directoryName); System.exit(0); &#125; File[] files = new File(directoryName).listFiles(); System.out.println(directoryName + ": subdir of files: " + Arrays.asList(files)); // Iterate through the lines of each file in directory: for(File f : files) &#123; int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object for(String line : new TextFile(directoryName + "\\" + f.getName())) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group() + ": " + m.start()); &#125; System.out.println(); &#125; &#125; &#125;&#125; 输出结果： 1234567891011121314151617181920212223242526272829303132F:\Study\java\DesignerPattern\test: subdir of files: [F:\Study\java\DesignerPattern\test\JGrep.java, F:\Study\java\DesignerPattern\test\Receipt.java]0: com: 81: string: 232: strings: 43: simple: 104: the: 285: Ssct: 266: class: 77: static: 98: String: 269: throws: 4110: compile: 2411: Ssct: 3712: String: 813: Study: 4014: src: 8615: com: 9116: string: 10917: System: 818: start: 310: com: 81: string: 232: class: 73: total: 164: System: 365: String: 196: total: 27: total: 428: total: 449: static: 810: String: 25 3.编写一个程序，读取一个java源代码文件，打印出所有注释12345678910111213141516171819202122package com.lhsjohn.pr.string;/* testtest * 测试www */import java.util.regex.Matcher;import java.util.regex.Pattern;public class Ex17 &#123; private static String fileName="F:\\Study\\java\\DesignerPattern\\PracticeString\\src\\com\\lhsjohn\\pr\\string\\Ex17.java"; public static void main(String[] args) throws Exception &#123; Pattern p = Pattern.compile("(//\\s.+)|(/\\*\\s+.+)|(\\*\\s+.+)"); // Iterate through the lines of the input file: int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object System.out.println(fileName + " comments: "); for(String line : new TextFile(fileName)) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group()); &#125; &#125;&#125; 测试结果： 12345F:\Study\java\DesignerPattern\PracticeString\src\com\lhsjohn\pr\string\Ex17.java comments: 0: /* testtest1: * 测试www2: // Iterate through the lines of the input file:3: // creates emtpy Matcher object 4.编写一个程序,读取一个java源代码文件，打印出代码中所有的普通字符串。123456789101112131415161718192021package com.lhsjohn.pr.string;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Ex18 &#123; private static String fileName="F:\\Study\\java\\DesignerPattern\\PracticeString\\src\\com\\lhsjohn\\pr\\string\\Ex17.java"; public static void main(String[] args) throws Exception &#123; Pattern p = Pattern.compile("\".*\""); System.out.println(fileName + " string literals:"); // Iterate through the lines of the input file: int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object for(String line : new TextFile(fileName)) &#123; m.reset(line); while(m.find()) System.out.println(index++ + ": " + m.group()); &#125; &#125;&#125; 运行结果： 123456F:\Study\java\DesignerPattern\PracticeString\src\com\lhsjohn\pr\string\Ex17.java string literals:0: "F:\\Study\\java\\DesignerPattern\\PracticeString\\src\\com\\lhsjohn\\pr\\string\\Ex17.java"1: "(//\\s.+)|(/\\*\\s+.+)|(\\*\\s+.+)"2: ""3: " comments: "4: ": " 5.编写一个程序，输出java源代码中用到的所有类的名字。1234567891011121314151617181920212223242526package com.lhsjohn.pr.string;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Ex19 &#123; private static String fileName="F:\\Study\\java\\DesignerPattern\\PracticeString\\src\\com\\lhsjohn\\pr\\string\\Ex17.java"; public static void main(String[] args) throws Exception &#123; // we want all class names: Pattern p = Pattern.compile("class \\w+\\s+"); // not including those in comment lines: Pattern q = Pattern.compile("^(//|/\\*|\\*)"); System.out.println("classes in " + fileName + ":"); // Iterate through the lines of the input file: int index = 0; Matcher m = p.matcher(""); // creates emtpy Matcher object Matcher n = q.matcher(""); for(String line : new TextFile(fileName)) &#123; m.reset(line); n.reset(line); while(m.find() &amp;&amp; !n.find()) System.out.println(index++ + ": " + m.group()); &#125; &#125;&#125; 输出结果： 12classes in F:\Study\java\DesignerPattern\PracticeString\src\com\lhsjohn\pr\string\Ex17.java:0: class Ex17 6.扫描输入+分词操作1234567891011121314151617181920212223242526272829package com.lhsjohn.pr.string;import java.io.*;public class SimpleRead &#123; public static BufferedReader input = new BufferedReader( new StringReader("Sir Robin of lhsjohn\n20 1.61803")); public static void main(String[] args) &#123; try &#123; System.out.println("What is your name?"); String name = input.readLine(); System.out.println(name); System.out.println( "How old are you? What is your favorite double?"); System.out.println("(input: &lt;age&gt; &lt;double&gt;)"); String numbers = input.readLine(); System.out.println(numbers); String[] numArray = numbers.split(" "); int age = Integer.parseInt(numArray[0]); double favorite = Double.parseDouble(numArray[1]); System.out.format("Hi %s.\n", name); System.out.format("In 5 years you will be %d.\n", age + 5); System.out.format("My favorite double is %f.", favorite / 2); &#125; catch(IOException e) &#123; System.err.println("I/O exception"); &#125; &#125;&#125; 输出结果： 12345678What is your name?Sir Robin of lhsjohnHow old are you? What is your favorite double?(input: &lt;age&gt; &lt;double&gt;)20 1.61803Hi Sir Robin of lhsjohn.In 5 years you will be 25.My favorite double is 0.809015. 7.用Scanner更好地完成扫描输入1234567891011121314151617181920212223package com.lhsjohn.pr.string;import java.util.*;public class BetterRead &#123; public static void main(String[] args) &#123; Scanner stdin = new Scanner(SimpleRead.input); System.out.println("What is your name?"); String name = stdin.nextLine(); System.out.println(name); System.out.println( "How old are you? What is your favorite double?"); System.out.println("(input: &lt;age&gt; &lt;double&gt;)"); int age = stdin.nextInt(); double favorite = stdin.nextDouble(); System.out.println(age); System.out.println(favorite); System.out.format("Hi %s.\n", name); System.out.format("In 5 years you will be %d.\n", age + 5); System.out.format("My favorite double is %f.", favorite / 2); &#125;&#125; 输出结果： 123456789What is your name?Sir Robin of lhsjohnHow old are you? What is your favorite double?(input: &lt;age&gt; &lt;double&gt;)201.61803Hi Sir Robin of lhsjohn.In 5 years you will be 25.My favorite double is 0.809015. 8.Scanner定界符123456789101112package com.lhsjohn.pr.string;import java.util.*;public class ScannerDelimiter &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner("12, 42, 78, 99, 42"); scanner.useDelimiter("\\s*,\\s*"); while(scanner.hasNextInt()) System.out.println(scanner.nextInt()); &#125;&#125; 输出结果： 123451242789942 9.用正则表达式进行扫描12345678910111213141516171819202122232425package com.lhsjohn.pr.string;import java.util.regex.*;import java.util.*;public class ThreatAnalyzer &#123; static String threatData = "58.27.82.161@09/01/2018\n" + "204.45.234.40@09/02/2018\n" + "58.27.82.161@09/03/2018\n" + "58.27.82.161@09/03/2018\n" + "58.27.82.161@09/03/2018\n" + "[Next log section with different data format]"; public static void main(String[] args) &#123; Scanner scanner = new Scanner(threatData); String pattern = "(\\d+[.]\\d+[.]\\d+[.]\\d+)@" + "(\\d&#123;2&#125;/\\d&#123;2&#125;/\\d&#123;4&#125;)"; while(scanner.hasNext(pattern)) &#123; scanner.next(pattern); MatchResult match = scanner.match(); String ip = match.group(1); String date = match.group(2); System.out.format("Threat on %s from %s\n", date,ip); &#125; &#125;&#125; 输出结果： 12345Threat on 09/01/2018 from 58.27.82.161Threat on 09/02/2018 from 204.45.234.40Threat on 09/03/2018 from 58.27.82.161Threat on 09/03/2018 from 58.27.82.161Threat on 09/03/2018 from 58.27.82.161 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
        <tag>Thinking in java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 字符串 (二）Prac2]]></title>
    <url>%2F2018%2F09%2F02%2FString%20%E5%AD%97%E7%AC%A6%E4%B8%B2%20(%E4%BA%8C%EF%BC%89Prac2%2F</url>
    <content type="text"><![CDATA[1.试用正则表达式1(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b 注意事项：(?!)表示匹配时不区分大小写 ?匹配前面的子表达式0次或者多次+匹配前面的子表达式1次或者多次 整个正则表达式合起来为 匹配以元音字母开始元音字母结尾的单词 来匹配“Arline ate eight apples and one orange while Anita hadn’t any” 123456789101112131415161718192021222324252627package com.lhsjohn.pr.string;import java.util.regex.Matcher;import java.util.regex.Pattern;public class TestRegularExpression11 &#123; public static void main(String[] args) &#123; if(args.length &lt; 2) &#123; System.out.println("Usage:\njava TestRegularExpression " + "characterSequence regularExpression+"); System.exit(0); &#125; System.out.println("Input: \"" + args[0] + "\""); for(String arg : args) &#123; System.out.println("Regular expression: \"" + arg + "\""); Pattern p = Pattern.compile(arg); Matcher m = p.matcher(args[0]); if(!m.find()) System.out.println("No match found for " + "\"" + arg + "\""); m.reset(); while(m.find()) &#123; System.out.println("Match \"" + m.group() + "\" at position " + m.start() + ((m.end() - m.start() &lt; 2) ? "" : ("-" + (m.end() - 1)))); &#125; &#125; &#125;&#125; 输出结果： 123456789Input: "Arline ate eight apples and one orange while Anita hadn't any"Regular expression: "Arline ate eight apples and one orange while Anita hadn't any"Match "Arline ate eight apples and one orange while Anita hadn't any" at position 0-60Regular expression: "(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b"Match "Arline" at position 0-5Match " ate" at position 6-9Match " one" at position 27-30Match " orange" at position 31-37Match " Anita" at position 44-49 2.Finding.java12345678910111213141516171819202122232425package com.lhsjohn.pr.string;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Finding &#123; public static void main(String[] args) &#123; Matcher m = Pattern.compile("\\w+").matcher("Evening is full of the linnet's wings"); while(m.find()) System.out.print(m.group()+ " "); System.out.println(); System.out.println("=================================="); int i=0; while(m.find(i)) &#123; System.out.print(m.group()+" "); i++; &#125; &#125;&#125; 模式\w+将字符串划分为单词。find()像迭代器那样向前遍历输出字符串，第二个find()能够接收一个整数作为参数，该整数表示字符串中字符的位置，并以此作为搜索起点。 输出结果: 123Evening is full of the linnet s wings ==================================Evening vening ening ning ing ng g is is s full full ull ll l of of f the the he e linnet linnet innet nnet net et t s s wings wings ings ngs gs s 3.组123456789101112131415161718192021222324252627282930313233package com.lhsjohn.pr.string;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Groups &#123; static public final String POEM= "Twas brillig, and the slithy toves\n" + "Did gyre and gimble in the wabe.\n" + "All mimsy were the borogoves,\n" + "And the mome raths outgrabe.\n\n" + "Beware the Jabberwock, my son,\n" + "The jaws that bite, the claws that catch,\n" + "Beware the Jubjub bird, and shun\n" + "The frumious Bandersnatch."; public static void main(String[] args) &#123; Matcher m = Pattern.compile("(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$").matcher(POEM); while(m.find()) &#123; for(int i=0;i&lt;=m.groupCount();i++) &#123; System.out.print("[" +m.group(i)+ "]"); &#125; System.out.println(); &#125; &#125; &#125; 这里的正则表达式 1(?m)(\\S+)\\s+((\\S+)\\s+(\\S+))$ 由任意数目的非空格字符(\S+)以及随后的任意数目的空格字符(\s+)所组成,目的是捕获每行最后的三个词，每行最后以$结束 显示告诉正则表达式注意输入序列中的换行符，可以由序列开头的模式标记(?m)来完成。 输出结果： 12345678[the slithy toves][the][slithy toves][slithy][toves][in the wabe.][in][the wabe.][the][wabe.][were the borogoves,][were][the borogoves,][the][borogoves,][mome raths outgrabe.][mome][raths outgrabe.][raths][outgrabe.][Jabberwock, my son,][Jabberwock,][my son,][my][son,][claws that catch,][claws][that catch,][that][catch,][bird, and shun][bird,][and shun][and][shun][The frumious Bandersnatch.][The][frumious Bandersnatch.][frumious][Bandersnatch.] 4.修改上面的Groups.java，找出所有不以大写字母开头的词，不重复地计算其个数。12345678910111213141516171819202122232425262728293031323334package com.lhsjohn.pr.string;import java.util.Set;import java.util.TreeSet;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Group12 &#123; static public final String POEM= "Twas brillig, and the slithy toves\n" + "Did gyre and gimble in the wabe.\n" + "All mimsy were the borogoves,\n" + "And the mome raths outgrabe.\n\n" + "Beware the Jabberwock, my son,\n" + "The jaws that bite, the claws that catch,\n" + "Beware the Jubjub bird, and shun\n" + "The frumious Bandersnatch."; public static void main(String[] args) &#123; //找出所有不以大写字母开头的词，不重复的计算其个数 Matcher m = Pattern.compile("(^[a-z]|\\s+[a-z])\\w+").matcher(POEM); Set&lt;String&gt; words=new TreeSet&lt;String&gt;(); while(m.find()) &#123; words.add(m.group()); &#125; System.out.println("符合要求的数目为: " +words.size()); System.out.println(words); &#125; &#125; 输出结果： 12符合要求的数目为: 25[ and, bird, bite, borogoves, brillig, catch, claws, frumious, gimble, gyre, in, jaws, mimsy, mome, my, outgrabe, raths, shun, slithy, son, that, the, toves, wabe, were] 5.start()与end()start()返回先前匹配的起始位置的索引,.而end()返回所匹配的最后字符的索引加一的值. 不多说了，上代码！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lhsjohn.pr.string;import java.util.regex.*;public class StartEnd &#123; public static String input = "As long as there is injustice, whenever a\n" + "Targathian baby cries out, wherever a distress\n" + "signal sounds among the stars ... We'll be there.\n" + "This fine ship, and this fine crew ...\n" + "Never give up! Never surrender!"; private static class Display &#123; private boolean regexPrinted = false; private String regex; Display(String regex) &#123; this.regex = regex; &#125; void display(String message) &#123; if(!regexPrinted) &#123; System.out.println(regex); regexPrinted = true; &#125; System.out.println(message); &#125; &#125; static void examine(String s, String regex) &#123; Display d = new Display(regex); Pattern p = Pattern.compile(regex); Matcher m = p.matcher(s); while(m.find()) d.display("find() '" + m.group() + "' start = "+ m.start() + " end = " + m.end()); if(m.lookingAt()) // No reset() necessary d.display("lookingAt() start = " + m.start() + " end = " + m.end()); if(m.matches()) // No reset() necessary d.display("matches() start = " + m.start() + " end = " + m.end()); &#125; public static void main(String[] args) &#123; for(String in : input.split("\n")) &#123; System.out.println("input : " + in); for(String regex : new String[]&#123;"\\w*ere\\w*", "\\w*ever", "T\\w+", "Never.*?!"&#125;) examine(in, regex); &#125; &#125;&#125; 输出结果： 123456789101112131415161718192021222324252627282930input : As long as there is injustice, whenever a\w*ere\w*find() 'there' start = 11 end = 16\w*everfind() 'whenever' start = 31 end = 39input : Targathian baby cries out, wherever a distress\w*ere\w*find() 'wherever' start = 27 end = 35\w*everfind() 'wherever' start = 27 end = 35T\w+find() 'Targathian' start = 0 end = 10lookingAt() start = 0 end = 10input : signal sounds among the stars ... We'll be there.\w*ere\w*find() 'there' start = 43 end = 48input : This fine ship, and this fine crew ...T\w+find() 'This' start = 0 end = 4lookingAt() start = 0 end = 4input : Never give up! Never surrender!\w*everfind() 'Never' start = 0 end = 5find() 'Never' start = 15 end = 20lookingAt() start = 0 end = 5Never.*?!find() 'Never give up!' start = 0 end = 14find() 'Never surrender!' start = 15 end = 31lookingAt() start = 0 end = 14matches() start = 0 end = 31 6.特别好用的split()可以通过通用边界断开输入文本 12345678910111213141516package com.lhsjohn.pr.string;import java.util.Arrays;import java.util.regex.Pattern;public class SplitDemo &#123; public static void main(String[] args) &#123; String input="This!!unusual use!!of exclamation!!points"; System.out.println(Arrays.toString(Pattern.compile("!!").split(input))); System.out.println(Arrays.toString(Pattern.compile("!!").split(input,3))); &#125; &#125; 输出结果： 12[This, unusual use, of exclamation, points][This, unusual use, of exclamation!!points] 7.用String.split()重写SplitDemo123456789101112131415package com.lhsjohn.pr.string;import java.util.Arrays;import java.util.regex.Pattern;public class SplitDemo14 &#123; public static void main(String[] args) &#123; String input="This!!unusual use!!of exclamation!!points"; System.out.println(Arrays.toString(input.split("!!"))); System.out.println(Arrays.toString(input.split("!!",3))); &#125;&#125; 输出结果: 12[This, unusual use, of exclamation, points][This, unusual use, of exclamation!!points] 8.替换操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.lhsjohn.pr.string;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.util.regex.*;/*! Here's a block of text to use as input to the regular expression matcher. Note that we'll first extract the block of text by looking for the special delimiters, then process the extracted block. !*/public class TheReplacements &#123; public static void main(String[] args) throws Exception &#123; //读入整个文件，将其内容作为String对象返回 String s = read("F:/Study/java/DesignerPattern/PracticeString/src/com/lhsjohn/pr/string/TheReplacements.java"); //mInput用于匹配在/*!和！*/之间的文字 Matcher mInput = Pattern.compile("/\\*!(.*)!\\*/", Pattern.DOTALL) .matcher(s); if(mInput.find()) //注意分组的括号 s = mInput.group(1); // 将存在两个或者两个以上的地方，替换成一个空格: s = s.replaceAll(" &#123;2,&#125;", " "); //删除开头部分的空格，因为是多行模式，所以需要打开多行状态 s = s.replaceAll("(?m)^ +", ""); System.out.println(s); //replaceFirst只对找到的第一个匹配进行替换 //注意replaceFirst()和replaceAll()用来替换的只是普通的字符串,如果需要对这些替换字符串进行特殊的处理 //我们还需要使用appendReplacement()方法 s = s.replaceFirst("[aeiou]", "(VOWEL1)"); StringBuffer sbuf = new StringBuffer(); Pattern p = Pattern.compile("[aeiou]"); Matcher m = p.matcher(s); //先构造sbuf来保存最终结果,然后用group选择了一个组进行相关处理 while(m.find()) m.appendReplacement(sbuf, m.group().toUpperCase()); //在执行了一次或者多次appendReplacement()方法之后,调用此方法可以将输入字符串剩下的部分复制到sbuf中 m.appendTail(sbuf); System.out.println(sbuf); &#125; public static String read(String fileName) &#123; StringBuilder sb = new StringBuilder(); try &#123; BufferedReader in= new BufferedReader(new FileReader( new File(fileName).getAbsoluteFile())); try &#123; String s; while((s = in.readLine()) != null) &#123; sb.append(s); sb.append("\n"); &#125; &#125; finally &#123; in.close(); &#125; &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; return sb.toString(); &#125; &#125; 输出结果: 12345678910Here's a block of text to use as input tothe regular expression matcher. Note that we'llfirst extract the block of text by looking forthe special delimiters, then process theextracted block. H(VOWEL1)rE's A blOck Of tExt tO UsE As InpUt tOthE rEgUlAr ExprEssIOn mAtchEr. NOtE thAt wE'llfIrst ExtrAct thE blOck Of tExt by lOOkIng fOrthE spEcIAl dElImItErs, thEn prOcEss thEExtrActEd blOck. 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
        <tag>Thinking in java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 字符串 (一）Prac1]]></title>
    <url>%2F2018%2F09%2F01%2FString%20%E5%AD%97%E7%AC%A6%E4%B8%B2%20(%E4%B8%80%EF%BC%89Prac1%2F</url>
    <content type="text"><![CDATA[1.无意识的递归12345678910111213141516171819202122232425262728293031package com.lhsjohn.pr.string;import java.util.ArrayList;import java.util.List;/** * 迭代打印本类的地址信息,在这里可以把所有的宽度提取成常量，需要修改时只需要修改一处即可。 * @author lihuashuo * */public class InfiniteRecursion &#123; public String toString() &#123; //return "InfiniteRecursion address: " + this + "\n"; 这样写会报错，原因是将this转换成String时无意识调用了this的toString(),造成递归 return "InfiniteRecursion address: " + super.toString() + "\n"; &#125; public static void main(String[] args) &#123; List&lt;InfiniteRecursion&gt; v=new ArrayList&lt;InfiniteRecursion&gt;(); for( int i=0; i&lt;10; i++ ) v.add(new InfiniteRecursion()); System.out.println(v); &#125; &#125; 输出结果： 1234567891011[InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@70dea4e, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@5c647e05, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@33909752, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@55f96302, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@3d4eac69, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@42a57993, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@75b84c92, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@6bc7c054, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@232204a1, InfiniteRecursion address: com.lhsjohn.pr.string.InfiniteRecursion@4aa298b7] 2.Formatter类的格式化输出1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lhsjohn.pr.string;import java.io.PrintStream;import java.util.Formatter;public class Turtle &#123; private String name; private Formatter f; public Turtle(String name, Formatter f) &#123; this.name = name; this.f = f; &#125; public void move(int x,int y) &#123; f.format(" %s The turtle is at (%d,%d) \n", name,x,y); &#125; public static void main(String[] args) &#123; PrintStream outAlias = System.out; Turtle tommy=new Turtle("tommy", new Formatter(System.out)); Turtle terry=new Turtle("terry", new Formatter(outAlias)); tommy.move(0, 0); terry.move(4, 8); tommy.move(3, 4); terry.move(2, 5); tommy.move(3, 3); terry.move(3, 3); &#125; &#125; 输出结果： 123456tommy The turtle is at (0,0) terry The turtle is at (4,8) tommy The turtle is at (3,4) terry The turtle is at (2,5) tommy The turtle is at (3,3) terry The turtle is at (3,3) 3.修改Turtle.java,使之将结果输出到System.err中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lhsjohn.pr.string;/** * 修改Turtle.java 将结果输出到System.err中 * @author lihuashuo * */import java.io.PrintStream;import java.util.Formatter;public class Turtle2 &#123; private String name; private Formatter f; public Turtle2(String name, Formatter f) &#123; this.name = name; this.f = f; &#125; public void move(int x,int y) &#123; f.format(" %s Turtle is at (%d,%d)\n",name,x,y); &#125; public static void main(String[] args) &#123; PrintStream err = System.err; Turtle2 tommy = new Turtle2("tommy", new Formatter(System.err)); Turtle2 terry = new Turtle2("terry", new Formatter(err)); tommy.move(0, 0); terry.move(4, 8); tommy.move(3, 4); terry.move(2, 5); tommy.move(3, 3); terry.move(3, 3); &#125; &#125; 输出结果： 1234567//字体变成红色tommy Turtle is at (0,0)terry Turtle is at (4,8)tommy Turtle is at (3,4)terry Turtle is at (2,5)tommy Turtle is at (3,3)terry Turtle is at (3,3) 4.我们来格式化打印一个购物收据1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lhsjohn.pr.string;import java.util.Formatter;/** * 格式化说明符来打印一个收据 * @author lihuashuo * */public class Receipt &#123; private double total=0; private Formatter f= new Formatter(System.out); public void printTitle() &#123; f.format("%-15s %5s %10s\n","Item","Qty","Price"); f.format("%-15s %5s %10s\n","----","---","-----"); &#125; public void print(String name,int qty,double price) &#123; f.format("%-15.15s %5d %10.2f\n", name,qty,price); total+=price; &#125; public void printTotal() &#123; f.format("%-15s %5s %10.2f\n","Tax", "",total*0.06); f.format("%-15s %5s %10s\n","", "","-----"); f.format("%-15s %5s %10.2f\n","Total", "",total*1.06); &#125; public static void main(String[] args) &#123; Receipt receipt=new Receipt(); receipt.printTitle(); receipt.print("Jack's Magic Beans", 4, 4.25); receipt.print("Princess Peas", 3, 5.1); receipt.print("Three Bears Porridge", 1, 14.29); receipt.printTotal(); &#125; &#125; 输出结果： 12345678Item Qty Price---- --- -----Jack's Magic Be 4 4.25Princess Peas 3 5.10Three Bears Por 1 14.29Tax 1.42 -----Total 25.06 5.正则表达式入门1234567891011121314151617181920package com.lhsjohn.pr.string;/** * 应用正则表达式匹配相应规则的整数 * @author lihuashuo * */public class IntegerMatch &#123; public static void main(String[] args) &#123; System.out.println("-1234".matches("-?\\d+")); System.out.println("5678".matches("-?\\d+")); System.out.println("+911".matches("-?\\d+")); //可能以一个加号或者减号开头 System.out.println("+911".matches("(-?|\\+)?\\d+")); &#125;&#125; 输出结果： 1234truetruefalsetrue 6.String类自带的正则表达式工具–split()方法，将字符串从正则表达式匹配的地方切开123456789101112131415161718192021222324252627282930313233package com.lhsjohn.pr.string;import java.util.Arrays;/** * 将字符串从正则表达式匹配的地方切开 * 与正则表达式匹配的部分都不存在了 * @author lihuashuo * */public class Splitting &#123; public static String knight= "Then, when you have found the shrubbery, you must "+ "cut down the mightiest tree in the forest... "+ "with... a herring!"; public static void split(String regex) &#123; System.out.println(Arrays.toString(knight.split(regex))); &#125; public static void main(String[] args) &#123; //根据空格来划分字符串 split(" "); // \W表示非单词字符，这个可以删除标点符号 split("\\W+"); // 字母n后面跟着一个或多个非单词字符 split("n\\W+"); &#125; &#125; 输出结果 123[Then,, when, you, have, found, the, shrubbery,, you, must, cut, down, the, mightiest, tree, in, the, forest..., with..., a, herring!][Then, when, you, have, found, the, shrubbery, you, must, cut, down, the, mightiest, tree, in, the, forest, with, a, herring][The, whe, you have found the shrubbery, you must cut dow, the mightiest tree i, the forest... with... a herring!] 7.String.split的重载版本,允许限制字符串分割的次数12345678910111213141516171819package com.lhsjohn.pr.string;/** * 限制字符串分割的次数 * @author lihuashuo * */public class Replacing &#123; static String s = Splitting.knight; public static void main(String[] args) &#123; //以字母f开头，后面跟着一个或者多个字母,并且只能替换掉第一个匹配的部分,在这里"found"替换成了"located" System.out.println(s.replaceFirst("f\\w+", "located")); //匹配的是三个单词中的任意一个，替换所有匹配的部分 System.out.println(s.replaceAll("shrubbery|tree|herring", "banana")); &#125; &#125; 输出结果 12Then, when you have located the shrubbery, you must cut down the mightiest tree in the forest... with... a herring!Then, when you have found the banana, you must cut down the mightiest banana in the forest... with... a banana! 8.编写一个正则表达式，检测一个句子是否以大写字母开头123456789101112131415161718192021222324252627package com.lhsjohn.pr.string;public class Sentence7 &#123; public static void main(String[] args) &#123; //检查一个句子是否以大写字母开头，以句号结尾 String sen="^[A-Z].*[\\.]$"; String s1="Once upon a time."; String s2="abcd."; String s3="Abcd?"; String s4="An easy way out."; String s5="Zorro."; String s6="X."; System.out.println(s1.matches(sen)); System.out.println(s2.matches(sen)); System.out.println(s3.matches(sen)); System.out.println(s4.matches(sen)); System.out.println(s5.matches(sen)); System.out.println(s6.matches(sen)); &#125; &#125; 输出结果： 123456truefalsefalsetruetruetrue 9.将字符串Splitting.knight在the和you处分割1234567891011121314151617package com.lhsjohn.pr.string;import java.util.Arrays;public class Splitting8 &#123; public static String knight= "Then, when you have found the shrubbery, you must "+ "cut down the mightiest tree in the forest... "+ "with... a herring!"; public static void split(String regex) &#123; System.out.println(Arrays.toString(knight.split(regex))); &#125; public static void main(String[] args) &#123; split("the|you"); &#125;&#125; 输出结果： 1[Then, when , have found , shrubbery, , must cut down , mightiest tree in , forest... with... a herring!] 10.用下划线替换Splitting.knight中的所有元音字母12345678910111213package com.lhsjohn.pr.string;public class Replacing9 &#123; public static String knight= "Then, when you have found the shrubbery, you must "+ "cut down the mightiest tree in the forest... "+ "with... a herring!"; public static void main(String[] args) &#123; System.out.println(knight.replaceAll("[aeiouAEIOU]", "_")); &#125;&#125; 输出结果： 1Th_n, wh_n y__ h_v_ f__nd th_ shr_bb_ry, y__ m_st c_t d_wn th_ m_ght__st tr__ _n th_ f_r_st... w_th... _ h_rr_ng! 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>学习</tag>
        <tag>Thinking in java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的反射机制 (一）概念以及常见用法]]></title>
    <url>%2F2018%2F08%2F31%2FJava%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%20(%E4%B8%80%EF%BC%89%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[什么是反射?反射是一种能够在程序运行时动态访问、修改某个类中任意属性（状态）和方法（行为）的机制。 正如我们在学习面向对象时谈到的一样:我们把事物的共性抽象起来，形成了类。 那么同样的道理，我们在Java中所写的类也有一些共性，例如属性/方法/构造函数等，同样，我们也可以将这些特性抽取出来，形成一个类，对所有类的属性和方法进行统一管理。 Java反射提供了以下几个功能(整理的网上的一些材料)java反射机制提供了以下几个功能：在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法。 反射涉及到四个核心类： java.lang.Class.java：类对象； java.lang.reflect.Constructor.java：类的构造器对象； java.lang.reflect.Method.java：类的方法对象； java.lang.reflect.Field.java：类的属性对象 以上是对反射的一个大概的介绍，具体的使用参见下面的测试代码 Person.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.lhsjohn.reflect;import java.io.Serializable;public class Person implements Serializable&#123; private String name; private String sex; private int age; private String address; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public Person(String name, String sex, int age, String address) &#123; this.name = name; this.sex = sex; this.age = age; this.address = address; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", sex=" + sex + ", age=" + age + ", address=" + address + "]"; &#125; &#125; Animal.java1234567package com.lhsjohn.reflect;public interface Animal &#123; public void makeSound(); public void play(String name);&#125; Dog.java123456789101112131415161718192021package com.lhsjohn.reflect;import java.io.Serializable;public class Dog implements Animal &#123; @Override public void makeSound() &#123; System.out.println("汪...汪...."); &#125; @Override public void play(String name) &#123; System.out.println(name +"啃大骨头"); &#125;&#125; 上面是我们写的一些基本的类和测试接口，下面我们就使用这些类来进行测试。 1.通过一个对象获得完整的包名和类名12345678910@Test/** * 1.通过一个对象获得完整的包名和类名 */public void testGetPackageAndClassName() throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); System.out.println(clazz.getName()); &#125; 测试结果 1com.lhsjohn.reflect.Person ##用三种方法实例化Class类对象 12345678910111213141516171819202122/** * 2.实例化Class类对象,这里有三种方法 * @throws Exception */ @Test public void testInstantiateClassObject() throws Exception &#123; Class clazz1=null; Class clazz2=null; Class clazz3=null; //用forName,最常用的一种形式 clazz1=Class.forName("com.lhsjohn.reflect.Person"); clazz2=new Person().getClass(); clazz3=Person.class; System.out.println("Class Name1: " + clazz1.getName()); System.out.println("Class Name2: " + clazz2.getName()); System.out.println("Class Name3: " + clazz3.getName()); &#125; 测试结果: 1Person [name=小王, sex=m, age=20, address=集美大道668号] 3.通过Class实例化其他类的对象123456789101112131415@Test/** * 3.通过Class实例化其他类的对象 */public void testInstantiateOtherObject() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Person person = (Person) clazz.newInstance(); person.setName("小王"); person.setAge(20); person.setSex("m"); person.setAddress("集美大道668号"); System.out.println(person.toString()); &#125; 测试结果： 1Person [name=小王, sex=m, age=20, address=集美大道668号] 4.通过Class来调用其他类中的构造函数12345678910111213141516171819202122232425@Test /** * 4.通过Class来调用其他类中的构造函数,也可以用这种方式来创建对象 */ public void testConstruct() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); Person person1=null; Person person2=null; Person person3=null; Person person4=null; person1=(Person) constructors[3].newInstance(); person2 = (Person) constructors[2].newInstance("小王1",18); person3=(Person) constructors[1].newInstance("小王2",18,"集美大道668号"); person4=(Person) constructors[0].newInstance("小王3","男",18,"集美大道668号"); System.out.println(person1); System.out.println(person2); System.out.println(person3); System.out.println(person4); &#125; 测试结果： 1234Person [name=null, sex=null, age=0, address=null]Person [name=小王1, sex=null, age=18, address=null]Person [name=小王2, sex=null, age=18, address=集美大道668号]Person [name=小王3, sex=男, age=18, address=集美大道668号] 5.获取一个类实现的接口1234567891011@Test/** * 5.获取一个类实现的接口 */public void testGetInterface() throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Dog"); Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); for(int i=0;i&lt;interfaces.length;i++) &#123; System.out.println("所实现的接口: "+ interfaces[i].getName()); &#125;&#125; 测试结果： 1所实现的接口: com.lhsjohn.reflect.Animal 6.取得一个类中的父类12345678910/** * 6.取得一个类中的父类 * @throws Exception */@Testpublic void testGetSuperClass() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Class&lt;?&gt; superclass = clazz.getSuperclass(); System.out.println(clazz.getName()+"所继承的父类为: "+ superclass.getName());&#125; 测试结果: 1com.lhsjohn.reflect.Person所继承的父类为: java.lang.Object 7 获得一个类中的所有构造函数12345678910111213/** * 7获得一个类中的所有构造函数--1 * @throws Exception */@Testpublic void testGetAllConstructs1() throws Exception&#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); for(int i=0;i&lt;constructors.length;i++) &#123; System.out.println("构造函数:" +constructors[i]); &#125; &#125; 测试结果: 1234构造函数:public com.lhsjohn.reflect.Person(java.lang.String,java.lang.String,int,java.lang.String)构造函数:public com.lhsjohn.reflect.Person(java.lang.String,int,java.lang.String)构造函数:public com.lhsjohn.reflect.Person(java.lang.String,int)构造函数:public com.lhsjohn.reflect.Person() 8.获得一个类中的所有构造函数1234567891011121314151617181920212223242526272829303132333435363738/** * 8.获得一个类中的所有构造函数 --2 * @throws Exception */ @Test public void testGetAllConstructs2() throws Exception&#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); for(int i=0;i&lt;constructors.length;i++) &#123; System.out.print("构造函数: " ); int modifiers = constructors[i].getModifiers(); Class&lt;?&gt;[] parameterTypes = constructors[i].getParameterTypes(); System.out.print(Modifier.toString(modifiers)+" "); System.out.print(constructors[i].getName()+" "); System.out.print("("); for(int j=0;j&lt;parameterTypes.length;j++) &#123; System.out.print(parameterTypes[j].getName() +" arg"+j); if(j&lt;parameterTypes.length-1) &#123; System.out.print(","); &#125; &#125; System.out.println(") &#123;&#125;"); &#125; &#125; 测试结果： 1234构造函数: public com.lhsjohn.reflect.Person (java.lang.String arg0,java.lang.String arg1,int arg2,java.lang.String arg3) &#123;&#125;构造函数: public com.lhsjohn.reflect.Person (java.lang.String arg0,int arg1,java.lang.String arg2) &#123;&#125;构造函数: public com.lhsjohn.reflect.Person (java.lang.String arg0,int arg1) &#123;&#125;构造函数: public com.lhsjohn.reflect.Person () &#123;&#125; 9.获得其他类的所有属性12345678910111213141516171819202122232425262728293031/** * 9.获得其他类的所有属性 * @throws Exception */ @Test public void testGetAllFields() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); System.out.println("下面是本类中的属性:......................."); Field[] fields = clazz.getDeclaredFields(); for(int i=0;i&lt;fields.length;i++) &#123; //获得权限修饰符 int modifiers = fields[i].getModifiers(); String pre=Modifier.toString(modifiers); //获得属性类型 Class&lt;?&gt; type = fields[i].getType(); System.out.println(pre +" "+type.getName()+" "+fields[i].getName()); &#125; /* System.out.println("实现的接口以及父类的属性"); Field[] fields1 = clazz.getFields(); for(int i=0;i&lt;fields1.length;i++) &#123; //获得权限修饰符 int modifiers = fields1[i].getModifiers(); String pre=Modifier.toString(modifiers); //获得属性类型 Class&lt;?&gt; type = fields1[i].getType(); System.out.println(pre +" "+type.getName()+" "+fields1[i].getName()); &#125; */ &#125; 测试结果: 12345下面是本类中的属性:.......................private java.lang.String nameprivate java.lang.String sexprivate int ageprivate java.lang.String address 10.通过反射调用类中的方法12345678910111213141516/** * 10.通过反射调用类中的方法 * @throws Exception * @throws Exception */ @Test public void testMethods() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Dog"); //调用Dog类中的makeSound方法 Method method = clazz.getMethod("makeSound"); method.invoke(clazz.newInstance()); //调用Dog类中的play方法 Method method2=clazz.getMethod("play",String.class); method2.invoke(clazz.newInstance(),"二哈"); &#125; 测试结果 12汪...汪....二哈啃大骨头 11.调用get 和set 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 11.调用get 和set 方法 * @throws Exception */@Testpublic void testGetAndSet() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Object object = clazz.newInstance(); setter(object,"Name", "小明", String.class); getter(object, "Name"); &#125;/** * * @param object 需要操作的对象 * @param attr 操作的属性 * @param value 参数的值 * @param type 参数的类型 */public static void setter(Object object,String attr,Object value,Class&lt;?&gt; type) &#123; try &#123; Method method = object.getClass().getMethod("set"+attr,type); method.invoke(object, value); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125;&#125;/** * @param object 操作的对象 * @param attr 操作的属性 */public static void getter(Object object,String attr) &#123; try &#123; Method method = object.getClass().getMethod("get"+attr); System.out.println("get: " +method.invoke(object)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 测试结果： 1get: 小明 12.通过反射修改属性的信息123456789101112131415/** * 12.通过反射修改属性的信息 * @throws Exception */ @Test public void modifyAttributes() throws Exception &#123; Class&lt;?&gt; clazz = Class.forName("com.lhsjohn.reflect.Person"); Object object = clazz.newInstance(); Field field = clazz.getDeclaredField("name"); //设置可以访问私有的权限 field.setAccessible(true); field.set(object, "小李"); System.out.println(field.get(object)); &#125; 测试结果: 1小李 13.通过反射取得或修改数组信息1234567891011121314 /** * 13.通过反射取得或修改数组信息 */@Testpublic void testArray() &#123; int temp[]= &#123;1,2,3,4,5&#125;; Class&lt;?&gt; clazz = temp.getClass().getComponentType(); System.out.println("数组类型 :"+clazz.getTypeName()); System.out.println("数组长度: "+ Array.getLength(temp)); System.out.println("数组的第一个元素: "+Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println("修改之后数组第一个元素为： "+Array.get(temp, 0)); &#125; 测试结果1234数组类型 :int数组长度: 5数组的第一个元素: 1修改之后数组第一个元素为： 100 14.通过反射来修改数组大小123456789101112131415161718192021222324252627282930313233343536373839404142/** * 14.通过反射来修改数组大小 * @throws Exception */@Testpublic void testModifyArratSize() throws Exception &#123; int[] temp=&#123;1,2,3,4,5,6,7,8,9&#125;; int[] newTemp = (int[]) arrayInc(temp,10); printArr(newTemp); String[] atr=&#123;"a","b","c"&#125;; String[] str1=(String[])arrayInc(atr,5); printArr(str1);&#125;/** * 修改数组大小 * @param object * @param len * @return */public static Object arrayInc(Object object,int len) &#123; Class&lt;?&gt; arr = object.getClass().getComponentType(); Object newArr=Array.newInstance(arr, len); int co=Array.getLength(object); System.arraycopy(object, 0, newArr, 0, co); return newArr;&#125;public static void printArr(Object object) &#123; Class&lt;?&gt; clazz = object.getClass(); if(!clazz.isArray()) &#123; return; &#125; System.out.println("数组的长度为: "+Array.getLength(object)); for(int i=0;i&lt;Array.getLength(object);i++) &#123; System.out.println(Array.get(object, i)+" "); &#125; &#125; 测试结果 1234567891011121314151617数组的长度为: 101 2 3 4 5 6 7 8 9 0 数组的长度为: 5a b c null null 以上便是对于反射一些常用操作的测试整理 详例参考:Eason-S &lt;&lt;Java反射机制及IoC原理&gt;&gt; https://www.cnblogs.com/Eason-S/p/5851078.html 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>反射机制</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典台词收录]]></title>
    <url>%2F2018%2F08%2F25%2F%E6%9C%AC%E6%9D%B0%E6%98%8E%E5%B7%B4%E9%A1%BF%E5%A5%87%E4%BA%8B%E7%BB%8F%E5%85%B8%E5%8F%B0%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[终于抽出来时间看了这部想看了很久的电影，一部爱情奇幻类的影片，有创意和脑洞，布拉德皮特演绎的完美饰演赋予了这部电影生命。 像&lt;&lt;泰坦尼克号&gt;&gt;一样,倒叙的方式开场,本杰明留下的牛皮书作为线索，推动着对整个情节的叙述。 大体懵懵懂懂看了第一遍看完了，算不上理解的特别透彻，但是却很喜欢里面的一些经典台词。 下面是从网络上收集的一些比较经典的台词,这部电影的成功之处在于，当你听到类似的台词时，你肯定会毫不犹豫想到这部电影。 并非鸡汤化的台词，只是人性的缩影。(突然发现,代码块不仅可以写代码，还可以装台词 苦笑、、、、、) 12345678910不管何时何地做你想做的事永远都不嫌晚 你可以改变 也可以不变 没有什么硬性规定 我们可能做得很好 也可能很糟 我希望你能充分利用时间 希望你能看到令你吃惊的东西 希望你感受到从未有过的感觉 希望你遇到具有不同观点的人 希望你过上让你自豪的生活 如果你发现生活不如意 我希望你有勇气从头再来 1你可以像疯狗一样对周围的一切愤愤不平，你可以诅咒命运，但是等到最后一刻，你还得平静的放手而去 1我们注定要失去我们所爱之人，不然我们怎么知道，他们对我们来说多么重要。 1爱一个人的最高境界 就是一直守望着她。直到她的生命结束 由自己承担起所有相思的悲伤与痛苦直到自己消失在这个世界上 1有些时候我觉得很好笑，那些在我们记忆里占据很小一部分的人，你竟然一辈子都忘不掉。 Sometimes, I find it laughable that those in our memory occupy a small fraction of people are often left us with a most impressive. 1234567891011有些人，注定可以于河边闲坐。 有些人被闪电击中过七次。 有些人对音乐有着非凡的天赋。 有些人是艺术家。 有些人是游泳健将。 有些人懂得制作纽扣。 有些人懂莎士比亚。 有些人是妈妈。 还有些人，是舞者。 我们注定要失去我们所爱的人， 要不然我们怎么知道他们对我们有多么的重要。 1一件事无论太晚，或是像我太早，都不会阻拦你成为你想成为的那个人。这个过程没有时间的期限，只要你想，随时都可以开始，要改变或者保持现状都无所谓，做事情本不应有所束缚。我们可以办好这件事却也可以把它搞砸，但我希望最终你能成为你想成为的人，我希望你有时能驻足于这个令你感到惊叹的世界；体会你从未有过的感觉；我希望你能见到其他与你观点不同的人们；我希望你能有一个值得自豪的一生，如果和你想象的生活不一样，我希望你能有勇气，重新启程。 12345678910111213只要是有意义的事 再晚去做都是有意义的 做你想做的人 这件事 没有时间限制 只要你愿意 什么时候都可以开始 你能从现在开始改变 也可以一成不变 这件事 没有规矩可言 你能活出最精彩的自己 也可能搞得一团乱 我希望 你能活出最精彩的自己 我希望 你能见识到令你惊奇的事物 我希望 你能体验从未有过的情感 我希望 你能遇见一些想法不同的人 我希望 你为你自己的人生感到骄傲 如果你发现自己还没有做到 我希望 你有勇气 重头再来 1一件事无论太晚，或是像我太早，都不会阻拦你成为你想成为的那个人。这个过程没有时间的期限，只要你想，随时都可以开始，要改变或者保持现状都无所谓，做事情本不应有所束缚。 12But tell you a little secret. Fat people, skinny people,tall people,white people, they are just as alone as we are. but they are scared shitless. 告诉你一个小秘密，无论什么肤色，什么体型，人都是孤独的，但可怕的不是孤独，而是惧怕孤独 1你要一直不停地往前走，不然你不会知道生活还会给你什么。 --奎恩 1我喜欢你的皱纹，每一条都爱。 1我们的生命被命运所决定，即使是我们错过的那个人。 ——大卫·芬奇 1如果只有那么一件事情，并没有按原来发生的话，如果那个鞋带没有断掉；或者如果那辆货车提前几分钟开走；如果那个商品早早就被包装好，因为她没有和他的男朋友分手；如果那个男人的闹钟提前上了五分钟；如果那个司机没有停下来去喝杯咖啡；如果那个女人没有忘记她的大衣，而坐上了早一班的出租车，黛西和她的朋友就将穿过马路，出租车也只会擦肩而过。但是生活就是这么不可预测，在一系列的交错层叠的人与事中，没有谁能掌控它们，而出租车没有碰巧开过去，那个司机也有些精力不集中，那个出租车还是撞到了黛西，她的腿被撞伤了。 12——晚安，本杰明。 ——晚安，黛西。 123每个人都会觉得自己不一样， 不过我们最后都会去同一个地方， 只是走的路不一样而已。 1有些时候我觉得很可笑，那些在我们记忆力占据着很小一部分的人们，却往往给我们留下了最深刻的印象。 12345——本杰明写给女儿的信《返老还童》 我们可以度过美好时光，也可以虚度光阴，但我希望你活得精彩。我希望你能看到令你惊叹的事物，我希望你体会从未有过的感觉，我希望你遇见具有不同观点的人，我希望你的一生能让自己过得自豪。如果你发现你的生活并非如此，我希望你能有勇气重新来过。 每个人都会觉得自己不一样， 不过我们最后都会去同一个地方， 只是走的路不一样而已。 1绝大多数的人都会从外表上来对你进行判断，而不会去了解你到底是一个什么样的人。 12It's a funny thing about coming home. Smells the same. Looks the same. Feels the same. 回家是一件有意思的事情。一样的味道、一样的屋子、一样的感觉。 1就像我曾经拥有整个人生，我却记不起来它是什么样子。 作者：lhsjohn]]></content>
      <categories>
        <category>观后感</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>影评</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-axios]]></title>
    <url>%2F2018%2F08%2F24%2FVue-axios(1)%2F</url>
    <content type="text"><![CDATA[参考地址：https://www.kancloud.cn/yunye/axios/234845参考地址：https://github.com/axios/axios 1.Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 2.优势： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 3.安装： npm install axios –save 4.引入： import Axios from “axios” Vue.prototype.$axios = Axios 5.应用： 1234567891011121314this.$axios(&#123; method:"get", url:"http://www.wwtliu.com/sxtstu/news/juhenews.php", params:&#123; type:"yule", count:30 &#125;&#125;).then(res =&gt; &#123; console.log(res.data)&#125;).catch(error =&gt; &#123; console.log(error)&#125;) Mock(网络请求模拟数据的方案): 1.请求自己的JSON格式数据 缺点：无法进行post请求 2.自己搭建服务器模拟数据 挺好的 3.使用线上已存在的数据 必须提前存在服务器 axios 的GET请求HelloWorld.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class="hello"&gt; &lt;ul&gt; &lt;li v-for="item in axiosData.banner"&gt;&#123;&#123;item.title&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'HelloWorld', data () &#123; return &#123; axiosData:&#123; banner:[] &#125; &#125; &#125;, created()&#123; // this.$axios.get("http://www.wwtliu.com/sxtstu/news/juhenews.php",&#123; // params:&#123; // type:"yule", // count:10 // &#125; // &#125;) // .then(res=&gt;&#123; // console.log(res.data) // // this.axiosData=res.data // &#125;) // .catch(error=&gt;&#123; // console.log(error) // &#125;)this.$axios(&#123; method:"get", url:"http://www.wwtliu.com/sxtstu/news/juhenews.php", params:&#123; type:"yule", count:30 &#125;&#125;).then(res=&gt;&#123; console.log(res.data)&#125;).catch(error=&gt;&#123; console.log(error)&#125;) &#125;&#125;&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;&lt;/style&gt; POST请求postdemo.vue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div class="root"&gt; post请求 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;//qs 专门用来转换参数类型import qs from "qs"export default &#123; name: 'post', data()&#123; //选项，数据 return&#123; &#125; &#125;, created()&#123; //axios的post请求接收参数是form-data格式的:?name=iwen&amp;age=20 // this.$axios.post("http://www.wwtliu.com/sxtstu/blueberrypai/login.php",qs.stringify(&#123; // user_id:"iwen@qq.com", // password:"iwen123", // verification_code:"crfvw" // &#125;)) // .then(res=&gt;&#123; // console.log(res); // &#125;) // .catch(error=&gt;&#123; // console.log(error) // &#125;)this.$axios(&#123; method:"POST", url:"/sxtstu/blueberrypai/login.php", data:&#123; user_id:"iwen@qq.com", password:"iwen123", verification_code:"crfvw" &#125;, // transformRequest:[function(data)&#123; // return qs.stringify(data); // &#125;]&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(error=&gt;&#123; console.log(error)&#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; Axios 跨域传输的问题baidu.vue12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class="root"&gt; 百度 &lt;ul&gt; &lt;li v-for="(item,index) in music.song_list"&gt;&#123;&#123;item.album_title&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'baidu', data()&#123; return&#123; music:&#123; song_list:[] &#125; &#125; &#125;, created()&#123; //网络请求 var url=this.HOST+"/v1/restserver/ting?method=baidu.ting.billboard.billList&amp;type=1&amp;size=10&amp;offset=0"; this.$axios.get(url) .then(res=&gt;&#123; this.music=res.data; console.log(res) &#125;) .catch(error=&gt;&#123; console.log(error) &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 解决跨域传输的问题需要修改配置文件在config下面的index.js 中的dev中添加 12345678proxyTable: &#123; "/baidu_music_api": &#123; target: "http://tingapi.ting.baidu.com", changeOrigin: true, pathRewrite: &#123; '^/baidu_music_api': '' &#125;&#125; 然后通过在main.js里进行相关的配置，重启服务器完成跨域传输 mian.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import Axios from "axios"Vue.prototype.HOST='/baidu_music_api'Vue.prototype.$axios=Axiosimport qs from "qs"//全局配置//Axios.defaults.baseURL = 'http://www.wwtliu.com';// Axios.defaults.baseURL = 'http://tingapi.ting.baidu.com';//Axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;// Axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';// Vue.config.productionTip = false// 添加请求拦截器Axios.interceptors.request.use(function(config) &#123; // 在发送请求之前做些什么 if(config.method==="post")&#123; config.data=qs.stringify(config.data); &#125; console.log(config); return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器Axios.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 if(response.status!==200)&#123; return; &#125; console.log(response); return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;);/* eslint-disable no-new */new Vue(&#123; el: '#app', components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) App.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div id="app"&gt; &lt;img src="./assets/logo.png"&gt; &lt;!-- &lt;PostDemo/&gt; --&gt;&lt;BaiDu/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from './components/HelloWorld'import PostDemo from './components/postdemo'import BaiDu from './components/baidu'export default &#123; name: 'app', data()&#123; return&#123; music:&#123; song_list:[] &#125; &#125; &#125;, components: &#123; // HelloWorld, // PostDemo, BaiDu &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 用这种方法同样可以进行js爬虫,可以爬取跨域的一些开放API站点,然后进行数据处理 分享一个百度音乐 接口 http://www.wwtliu.com/blog/?p=271 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>javaScript</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(五)-----适配器模式]]></title>
    <url>%2F2018%2F08%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%BA%94)-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F(1)%2F</url>
    <content type="text"><![CDATA[适配器模式的定义 将一个类的接口，转换成客户所期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 类图： 这里有四个名词，需要理解一下 Client: 客户端，调用自己需要领域的接口Target Target: 定义客户端需要的跟特定领域相关的接口 Adaptee: 已经存在的接口，但是与客户端所需领域的接口要求不一致，需要被适配(例如是方法名字不一致) Adapter: 适配器，把Adaptee适配成Client需要的Target Example1Adaptee.java1234567891011121314151617package com.lhsjohn.adapter.example1;/** * 已经存在的接口，这个接口需要被适配 * @author lihuashuo * */public class Adaptee &#123; /** * 示意方法，原本已经存在，已经实现了的方法 */ public void specificRequest() &#123; //具体的功能处理 &#125; &#125; Target.java12345678910111213141516package com.lhsjohn.adapter.example1;/** * 定义客户端使用的接口，与特定领域相关 * @author lihuashuo * */public interface Target &#123; /** * 示意方法，客户端请求处理的方法 */ public void request(); &#125; Adapter.java1234567891011121314151617181920212223package com.lhsjohn.adapter.example1;/* * 适配器 */public class Adapter implements Target&#123; //持有需要被适配的接口对象 private Adaptee adaptee; /** * 构造方法，传入需要被适配的对象 * @param adaptee */ public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; //可能转调已经实现了的方法，进行适配 adaptee.specificRequest(); &#125; &#125; Client.java1234567891011121314151617package com.lhsjohn.adapter.example1;/** * 使用适配器的客户端 * @author lihuashuo * */public class Client &#123; public static void main(String[] args) &#123; //创建需要被适配的对象 Adaptee adaptee=new Adaptee(); //创建客户端需要调用的接口对象。 Target target=new Adapter(adaptee); //请求处理 target.request(); &#125;&#125; 下面是对该模式的一个扩展 有这样一个应用场景： 同时支持数据库和文件的日志管理 1：日志管理第一版： 在第一版的时候，用户要求日志以文件的形式记录 2：日志管理第二版： 要采用数据可以来管理日志，并且已有新的基于数据库的实现 3：现在想在第二版的实现里面，能够同时兼容第一版的功能，那么就应该有一个类来实现第二版的接口，然后在这个类里面去调用已有的功能实现，这个类就是适配器 Example2LogModel.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lhsjohn.adapter.example2;import java.io.Serializable;/** * 日志数据对象 * @author lihuashuo * */public class LogModel implements Serializable &#123; //日志编号 private String logId; //操作人员 private String operaterUser; //操作时间，以yyyy-MM-dd HH:mm:ss的格式记录 private String operateTime; //日志内容 private String logContent; public String getLogId() &#123; return logId; &#125; public void setLogId(String logId) &#123; this.logId = logId; &#125; public String getOperaterUser() &#123; return operaterUser; &#125; public void setOperaterUser(String operaterUser) &#123; this.operaterUser = operaterUser; &#125; public String getOperateTime() &#123; return operateTime; &#125; public void setOperateTime(String operateTime) &#123; this.operateTime = operateTime; &#125; public String getLogContent() &#123; return logContent; &#125; public void setLogContent(String logContent) &#123; this.logContent = logContent; &#125; @Override public String toString() &#123; return "LogModel [logId=" + logId + ", operaterUser=" + operaterUser + ", operateTime=" + operateTime + ", logContent=" + logContent + "]"; &#125; &#125; LogFileOperateApi.java1234567891011121314151617181920212223package com.lhsjohn.adapter.example2;import java.util.List;/** * 日志文件操作接口 * @author lihuashuo * */public interface LogFileOperateApi &#123; /** * 读取文件，从文件里面获取存储的日志列表 * @return 存储的日志操作对象 */ public List&lt;LogModel&gt; readLogFile(); /** * 写日志文件，把日志列表写到日志文件中去 * @param list 要写到日志文件的日志列表 */ public void writeLogFile(List&lt;LogModel&gt; list); &#125; LogFileOperate.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.lhsjohn.adapter.example2;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.List;/** * 实现对日志文件的操作 * @author lihuashuo * */public class LogFileOperate implements LogFileOperateApi &#123; //日志文件的路径和文件名称，默认是当前classpath下的AdapterLog.log private String logFilePathName="AdapterLog.log"; /** * 构造方法，传入文件的路径和名称 * @param logFilePathName 文件的路径和名称 */ public LogFileOperate(String logFilePathName) &#123; //先判断是否传入了文件的路径和名称 //如果是的话，就重新设置操作的日志文件的路径和名称 if(logFilePathName!=null&amp;&amp; logFilePathName.trim().length()&gt;0) &#123; this.logFilePathName = logFilePathName; &#125; &#125; @Override public List&lt;LogModel&gt; readLogFile() &#123; List&lt;LogModel&gt; list=null; ObjectInputStream oin=null; try &#123; File f=new File(logFilePathName); if(f.exists()) &#123; oin=new ObjectInputStream(new BufferedInputStream(new FileInputStream(f))); list=(List&lt;LogModel&gt;) oin.readObject(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(oin!=null) &#123; oin.close(); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return list; &#125; @Override public void writeLogFile(List&lt;LogModel&gt; list) &#123; File f=new File(logFilePathName); ObjectOutputStream oout=null; try &#123; oout=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(f))); oout.writeObject(list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(oout!=null) &#123; oout.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; LogDbOperator.java1234567891011121314151617181920212223242526272829303132333435363738package com.lhsjohn.adapter.example2;import java.util.List;/** * 定义操作日志的应用接口 * 简单定义了增删改查的方法 * @author lihuashuo * */public interface LogDbOperaterApi &#123; /** * 新增日志 * @param lm 需要新增的日志对象 */ public void createLog(LogModel lm); /** * 删除日志 * @param lm 需要修改的日志对象 */ public void updateLog(LogModel lm); /** * 删除日志 * @param lm 需要删除的日志对象 */ public void removeLog(LogModel lm) ; /** * 获取所有的日志 * @return 所有的日志对象 */ public List&lt;LogModel&gt; getAllLog(); &#125; Adapter.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.lhsjohn.adapter.example2;import java.util.List;/** * 适配器对象，把记录日志到文件的功能适配成第二版需要的增删改查的功能 * @author lihuashuo * */public class Adapter implements LogDbOperaterApi &#123; /** * 持有需要被适配的对象 */ private LogFileOperateApi adaptee; /** * 构造方法，传入需要被适配的对象 * @param adaptee 需要被是配的对象 */ public Adapter(LogFileOperateApi adaptee) &#123; this.adaptee = adaptee; &#125; @Override public void createLog(LogModel lm) &#123; //1：先读取文件的内容 List&lt;LogModel&gt; list = adaptee.readLogFile(); //2:加入新的日志对象 list.add(lm); //3.重新写入文件 adaptee.writeLogFile(list); &#125; @Override public void updateLog(LogModel lm) &#123; //1:先读取文件的内容 List&lt;LogModel&gt; list = adaptee.readLogFile(); //2:修改相应的日志对象 for(int i=0;i&lt;list.size();i++) &#123; if(list.get(i).getLogId().equals(lm.getLogId())) &#123; list.set(i, lm); break; &#125; &#125; &#125; @Override public void removeLog(LogModel lm) &#123; //1:先读取文件的内容 List&lt;LogModel&gt; list = adaptee.readLogFile(); //2:删除对应的日志对象 list.remove(lm); //3:重新写入文件 adaptee.writeLogFile(list); &#125; @Override public List&lt;LogModel&gt; getAllLog() &#123; return adaptee.readLogFile(); &#125;&#125; Client.java12345678910111213141516171819202122232425262728293031323334353637package com.lhsjohn.adapter.example2;import java.util.ArrayList;import java.util.List;public class Client &#123; public static void main(String[] args) &#123; //准备日志内容，也就是测试的数据 LogModel lm1=new LogModel(); lm1.setLogId("001"); lm1.setOperaterUser("lhsjohn"); lm1.setOperateTime("2018-08-24 00:30:21"); lm1.setLogContent("这是一个测试"); List&lt;LogModel&gt; list=new ArrayList&lt;LogModel&gt;(); list.add(lm1); //创建操作日志文件的对象 LogFileOperateApi logFileApi=new LogFileOperate(""); //创建新版的操作日志的接口对象 LogDbOperaterApi api=new Adapter(logFileApi); //保存日志文件 api.createLog(lm1); //未使用适配器之前的:api.writeLogFile(list); //读取日志文件的内容 //未使用适配器的：List&lt;LogModel&gt; list2 = api.readLogFile(); //使用适配器的 List&lt;LogModel&gt; list2 = api.getAllLog(); System.out.println("readLog= "+list2); &#125;&#125; 再此基础上，再重新认识一下适配器模式 1：适配器模式的功能 主要是进行转换匹配，目的是复用已有的功能，而不是实现新的接口。 适配器里面也可以实现功能，称这种为智能适配器。 2：Adaptee和Target的关系 适配器模式中被适配的接口Adaptee和适配成为的接口Target是没有关联的。 3：对象组合 适配器的实现方式其实是依靠的对象组合的方式其实也可以用对象继承的方式，但是不推荐，因为Java是单继承的，只能继承一个类，如果要使用多个类的特性，就无法用继承完成 4.适配器模式调用的时序图 1：调用客户端需要的功能–&gt;1:1这个功能会由适配器来实现–&gt;1:1:1适配器会转调被适配对象的功能 适配器的实现1.适配器的常见实现 适配器通常是一个类，一般会让适配器去实现Target接口，然后在适配器的具体实现里面调用Adaptee. 2:智能适配器 可以在适配器的实现里面，加入新的功能实现，这种适配器被称为智能适配器 适配多个Adaptee 适配器Adapter实现的复杂程度适配器Adapter实现的复杂程度取决于Adaptee和Target的相似程度 5.缺省适配 为一个接口提供缺省实现：继承缺省适配器 双向适配器 example3LogModel.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.lhsjohn.adapter.example3;import java.io.Serializable;/** * 日志数据对象 * @author lihuashuo * */public class LogModel implements Serializable &#123; //日志编号 private String logId; //操作人员 private String operaterUser; //操作时间，以yyyy-MM-dd HH:mm:ss的格式记录 private String operateTime; //日志内容 private String logContent; public String getLogId() &#123; return logId; &#125; public void setLogId(String logId) &#123; this.logId = logId; &#125; public String getOperaterUser() &#123; return operaterUser; &#125; public void setOperaterUser(String operaterUser) &#123; this.operaterUser = operaterUser; &#125; public String getOperateTime() &#123; return operateTime; &#125; public void setOperateTime(String operateTime) &#123; this.operateTime = operateTime; &#125; public String getLogContent() &#123; return logContent; &#125; public void setLogContent(String logContent) &#123; this.logContent = logContent; &#125; @Override public String toString() &#123; return "LogModel [logId=" + logId + ", operaterUser=" + operaterUser + ", operateTime=" + operateTime + ", logContent=" + logContent + "]"; &#125; &#125; LogFileOperateApi.java1234567891011121314151617181920212223package com.lhsjohn.adapter.example3;import java.util.List;/** * 日志文件操作接口 * @author lihuashuo * */public interface LogFileOperateApi &#123; /** * 读取文件，从文件里面获取存储的日志列表 * @return 存储的日志操作对象 */ public List&lt;LogModel&gt; readLogFile(); /** * 写日志文件，把日志列表写到日志文件中去 * @param list 要写到日志文件的日志列表 */ public void writeLogFile(List&lt;LogModel&gt; list); &#125; LogFileOperate.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.lhsjohn.adapter.example3;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.util.List;/** * 实现对日志文件的操作 * @author lihuashuo * */public class LogFileOperate implements LogFileOperateApi &#123; //日志文件的路径和文件名称，默认是当前classpath下的AdapterLog.log private String logFilePathName="AdapterLog.log"; /** * 构造方法，传入文件的路径和名称 * @param logFilePathName 文件的路径和名称 */ public LogFileOperate(String logFilePathName) &#123; //先判断是否传入了文件的路径和名称 //如果是的话，就重新设置操作的日志文件的路径和名称 if(logFilePathName!=null&amp;&amp; logFilePathName.trim().length()&gt;0) &#123; this.logFilePathName = logFilePathName; &#125; &#125; @Override public List&lt;LogModel&gt; readLogFile() &#123; List&lt;LogModel&gt; list=null; ObjectInputStream oin=null; try &#123; File f=new File(logFilePathName); if(f.exists()) &#123; oin=new ObjectInputStream(new BufferedInputStream(new FileInputStream(f))); list=(List&lt;LogModel&gt;) oin.readObject(); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(oin!=null) &#123; oin.close(); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; return list; &#125; @Override public void writeLogFile(List&lt;LogModel&gt; list) &#123; File f=new File(logFilePathName); ObjectOutputStream oout=null; try &#123; oout=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(f))); oout.writeObject(list); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(oout!=null) &#123; oout.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; LogDbOperaterApi.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lhsjohn.adapter.example3;import java.util.List;/** * 定义操作日志的应用接口 * 简单定义了增删改查的方法 * @author lihuashuo * */public interface LogDbOperaterApi &#123; /** * 新增日志 * @param lm 需要新增的日志对象 */ public void createLog(LogModel lm); /** * 删除日志 * @param lm 需要修改的日志对象 */ public void updateLog(LogModel lm); /** * 删除日志 * @param lm 需要删除的日志对象 */ public void removeLog(LogModel lm) ; /** * 获取所有的日志 * @return 所有的日志对象 */ public List&lt;LogModel&gt; getAllLog(); /** * 删除所有的日志 */ public void removeAll(); &#125; LogDbOperater.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lhsjohn.adapter.example3;import java.util.List;import com.lhsjohn.adapter.example3.LogDbOperaterApi;import com.lhsjohn.adapter.example3.LogModel;/** * DB存储日志的实现，这里是模拟 * @author lihuashuo * */public class LogDbOperate implements LogDbOperaterApi &#123; @Override public void createLog(LogModel lm) &#123; System.out.println("now in LogDbOperate createLog,lm="+lm); &#125; @Override public void updateLog(LogModel lm) &#123; System.out.println("now in LogDbOperate updateLog,lm="+lm); &#125; @Override public void removeLog(LogModel lm) &#123; System.out.println("now in LogDbOperate removeLog,lm="+lm); &#125; @Override public List&lt;LogModel&gt; getAllLog() &#123; System.out.println("now in LogDbOperate getAllLog"); return null; &#125; @Override public void removeAll() &#123; System.out.println("now in LogDbOperate removeAll"); &#125;&#125; TwoDirectAdapter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.lhsjohn.adapter.example3;import java.util.List;import com.lhsjohn.adapter.example3.LogModel;/** * 双向适配器对象 * * @author lihuashuo * */public class TwoDirectAdapter implements LogDbOperaterApi, LogFileOperateApi &#123; /** * 持有需要被适配的文件存储日志的对象 */ private LogFileOperateApi fileLog; /** * 持有需要被适配的DB存储日志的接口对象 */ private LogDbOperaterApi dbLog; /** * 构造方法，传入需要被适配的对象 * * @param fileLog * 需要被适配的文件存储日志的对象 * @param dbLog * 需要被是配的DB存储日志的对象 */ public TwoDirectAdapter(LogFileOperateApi fileLog, LogDbOperaterApi dbLog) &#123; this.fileLog = fileLog; this.dbLog = dbLog; &#125; /*---------以下是把稳健操作的方式适配成DB实现方式的接口-------------*/ @Override public void createLog(LogModel lm) &#123; // 1：先读取文件的内容 List&lt;LogModel&gt; list = fileLog.readLogFile(); // 2:加入新的日志对象 list.add(lm); // 3.重新写入文件 fileLog.writeLogFile(list); &#125; @Override public void updateLog(LogModel lm) &#123; // 1:先读取文件的内容 List&lt;LogModel&gt; list = fileLog.readLogFile(); // 2:修改相应的日志对象 for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i).getLogId().equals(lm.getLogId())) &#123; list.set(i, lm); break; &#125; &#125; &#125; @Override public void removeLog(LogModel lm) &#123; // 1:先读取文件的内容 List&lt;LogModel&gt; list = fileLog.readLogFile(); // 2:删除对应的日志对象 list.remove(lm); // 3:重新写入文件 fileLog.writeLogFile(list); &#125; @Override public List&lt;LogModel&gt; getAllLog() &#123; return fileLog.readLogFile(); &#125; /* ----以下是把DB操作的方式适配成为文件实现的方式的接口*/ @Override public List&lt;LogModel&gt; readLogFile() &#123; return dbLog.getAllLog(); &#125; @Override public void writeLogFile(List&lt;LogModel&gt; list) &#123; //1:最简单的实现思路，先删除数据库中的数据 dbLog.removeLog(null); //2：然后循环把现在的数据加入到数据库中 for (LogModel lm : list) &#123; dbLog.createLog(lm); &#125; &#125; @Override public void removeAll() &#123; System.err.println("now in two driect remove All"); &#125;&#125; Client.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.lhsjohn.adapter.example3;import java.util.ArrayList;import java.util.List;public class Client &#123; public static void main(String[] args) &#123; //准备日志内容，也就是测试的数据 LogModel lm1=new LogModel(); lm1.setLogId("001"); lm1.setOperaterUser("lhsjohn"); lm1.setOperateTime("2018-08-24 00:30:21"); lm1.setLogContent("这是一个测试"); List&lt;LogModel&gt; list=new ArrayList&lt;LogModel&gt;(); list.add(lm1); //创建操作日志文件的对象 LogFileOperateApi fileLogApi=new LogFileOperate(""); LogDbOperaterApi dbLogApi=new LogDbOperate(); //创建经过双向适配后的操作接口日志的接口对象 LogFileOperateApi fileLogApi2=new TwoDirectAdapter(fileLogApi, dbLogApi); LogDbOperaterApi dbLogApi2=new TwoDirectAdapter(fileLogApi, dbLogApi); //先测试从文件操作适配器第二版，虽然调用第二版的接口，实际上是文件操作在实现 dbLogApi2.createLog(lm1); List&lt;LogModel&gt; allLog = dbLogApi2.getAllLog(); System.out.println("allLog="+allLog); //再测试从数据库存储适配成第一版的接口，调用第一版的接口，实际上是数据库相关在实现 System.out.println("------------------------File Api"); fileLogApi2.writeLogFile(list); fileLogApi2.readLogFile(); &#125;&#125; 控制台输出 12345allLog=[LogModel [logId=001, operaterUser=lhsjohn, operateTime=2018-08-24 00:30:21, logContent=这是一个测试], LogModel [logId=001, operaterUser=lhsjohn, operateTime=2018-08-24 00:30:21, logContent=这是一个测试]]------------------------File Apinow in LogDbOperate removeLog,lm=nullnow in LogDbOperate createLog,lm=LogModel [logId=001, operaterUser=lhsjohn, operateTime=2018-08-24 00:30:21, logContent=这是一个测试]now in LogDbOperate getAllLog 然后再深入理解一下适配器模式 对象适配器和类适配器 1：对象适配器的实现：依赖于对象组合，前面示例都是对象适配器的实现方式 2：类适配器的实现：采用多重继承对一个接口与另一个接口匹配。由于java不支持多重继承，所以到目前没涉及到。 但是java可以类似去实现类适配器，采用继承加实现接口的方式 最后来一个总结吧适配器模式的本质 转换匹配，复用功能 何时使用适配器模式 1：如果你想使用一个已经存在的类，但它的接口不符合你的需求，这种情况可以使用适配器模式，来把已有的实现转换成你需要的接口。 2：如果你想创建一个可以复用的类，这个类可能和一些不兼容的类一起工作，这种情况下可以使用适配器模式，到时候需要什么就适配什么 3：如果你想使用一些已经存在的子类，但是不可能对每一个子类都进行适配，这种情况下就可以选用对象适配器，直接适配这些子类的父类就可以了。 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个简单的登录拦截器]]></title>
    <url>%2F2018%2F08%2F22%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA%E5%99%A8(1)%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package cn.e3mall.cart.interceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import cn.e3mall.common.utils.CookieUtils;import cn.e3mall.common.utils.E3Result;import cn.e3mall.pojo.TbUser;import cn.e3mall.sso.service.TokenService;/** * 用户登录拦截器 * @author lihuashuo * */public class LoginInterceptor implements HandlerInterceptor &#123; @Autowired private TokenService tokenService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //前处理，执行handler之前处理 //返回 true,放行 false:拦截 //1.从cookie中取token String token = CookieUtils.getCookieValue(request, "token"); //2.如果没有token,未登录状态，直接放行 if(StringUtils.isBlank(token)) &#123; return true; &#125; //3.取到token,需要调用sso系统的服务，根据token取用户信息 E3Result e3Result = tokenService.getUserByToken(token); //4.没有取到用户信息。登录过期，直接放行 if(e3Result.getStatus()!=200) &#123; return true; &#125; //5.取到用户信息。登录状态。 TbUser user =(TbUser) e3Result.getData(); //6.把用户信息放到request中，只需要在Controller中判断是否包含user信息。放行 request.setAttribute("user", user); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; //handler执行之后,返回ModeAndView之前 // &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; //完成处理,返回ModelAndView之后 //可以在此处理异常 &#125; &#125; 拦截器配置 在springmvc.xml文件中123456&lt;!-- 拦截器配置 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="cn.e3mall.cart.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Intercepter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO单点登录]]></title>
    <url>%2F2018%2F08%2F19%2FSSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[集群环境下的登录 在集群环境下可能会出现要求用户多次登录的情况(配置了负载均衡后无法实现Session共享) 解决方案 1.可以配置tomcat集群,配置tomcatSession复制，节点数不要超过5个 2.可以使用Session服务器，保存Session信息，模拟Session. 单点登录系统是使用redis模拟Session,实现Session的统一管理 登录的处理流程： 1、登录页面提交用户名密码。 2、登录成功后生成token。Token相当于原来的jsessionid，字符串，可以使用uuid。 3、把用户信息保存到redis。Key就是token，value就是TbUser对象转换成json。 4、使用String类型保存Session信息。可以使用“前缀:token”为key 5、设置key的过期时间。模拟Session的过期时间。一般半个小时。 6、把token写入cookie中。7、Cookie需要跨域,可以使用工具类。 8、Cookie的有效期。关闭浏览器失效。 9、登录成功。]]></content>
      <categories>
        <category>项目</category>
        <category>java</category>
        <category>SSO单点登录</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SSO单点登录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ]]></title>
    <url>%2F2018%2F08%2F17%2FActiveMQ%2F</url>
    <content type="text"><![CDATA[What is ActiveMQ? ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。主要特点： 多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python, PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP 完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务) 对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性 通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resource adaptors的配置,可以让ActiveMQ可以自动的部署到任何兼容J2EE 1.4 商业服务器上 支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA 支持通过JDBC和journal提供高速的消息持久化 从设计上保证了高性能的集群,客户端-服务器,点对点 支持Ajax 支持与Axis的整合 可以很容易得调用内嵌JMS provider,进行测试 ActiveMQ的消息形式对于消息的传递有两种类型： 一种是点对点的，即一个生产者和一个消费者一一对应； 另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 · StreamMessage – Java原始值的数据流 · MapMessage–一套名称-值对 · TextMessage–一个字符串对象 · ObjectMessage–一个序列化的 Java对象 · BytesMessage–一个字节的数据流 使用测试(未整合Spring)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public void testQueueProducer() throws Exception &#123; // 1.创建一个连接工厂对象,需要指定服务的ip以及端口 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.128:61616"); // 2.使用工厂对象来创建一个Connection对象 Connection connection = connectionFactory.createConnection(); // 3.开启连接，调用Connection对象的start方法 connection.start(); // 4.创建一个Session对象 // 第一个参数:是否开启事务。如果true开启事务，第二个无意义。一般不开启false // 第二个参数：如果不开启事务。应答模式，一般是自动应答或者手动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5.使用Session对象创建一个Destination对象。两种形式queue、topic Queue queue = session.createQueue("spring-queue"); // 6.使用Session对象创建一个Producer对象 MessageProducer producer = session.createProducer(queue); // 7.创建一个Message对象，可以使用TextMessage。 /* * TextMessage textMessage=new ActiveMQTextMessage(); * textMessage.setText("hello Activemq"); */ TextMessage textMessage = session.createTextMessage("hello Activemq"); // 8.发送消息 producer.send(textMessage); // 9.关闭资源 producer.close(); session.close(); connection.close();&#125;public void testQueueConsumer() throws Exception &#123; // 创建一个ConnectionFactory对象连接MQ服务器 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.128:61616"); // 创建一个连接对象 Connection connection = connectionFactory.createConnection(); // 开启连接 connection.start(); // 使用Connection对象创建一个Session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建一个Destinatiion对象，queue对象 Queue queue = session.createQueue("spring-queue"); // 使用Session对象创建一个消费者对象 MessageConsumer consumer = session.createConsumer(queue); // 接收消息 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; // 打印结果 TextMessage textMessage = (TextMessage) message; String text; try &#123; text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); // 等待接收消息 System.in.read(); // 关闭资源 consumer.close(); session.close(); connection.close();&#125;public void testTopicProducer() throws Exception &#123; // 1.创建一个连接工厂对象,需要指定服务的ip以及端口 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.128:61616"); // 2.使用工厂对象来创建一个Connection对象 Connection connection = connectionFactory.createConnection(); // 3.开启连接，调用Connection对象的start方法 connection.start(); // 4.创建一个Session对象 // 第一个参数:是否开启事务。如果true开启事务，第二个无意义。一般不开启false // 第二个参数：如果不开启事务。应答模式，一般是自动应答或者手动应答 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 5.使用Session对象创建一个Destination对象。两种形式queue、topic Topic topic = session.createTopic("test-topic"); // 6.使用Session对象创建一个Producer对象 MessageProducer producer = session.createProducer(topic); // 7.创建一个Message对象，可以使用TextMessage。 /* * TextMessage textMessage=new ActiveMQTextMessage(); * textMessage.setText("hello Activemq"); */ TextMessage textMessage = session.createTextMessage("topicMessage"); // 8.发送消息 producer.send(textMessage); // 9.关闭资源 producer.close(); session.close(); connection.close();&#125;public void testTopicConsumer() throws Exception &#123; // 创建一个ConnectionFactory对象连接MQ服务器 ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.128:61616"); // 创建一个连接对象 Connection connection = connectionFactory.createConnection(); // 开启连接 connection.start(); // 使用Connection对象创建一个Session对象 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建一个Destinatiion对象，queue对象 Topic topic = session.createTopic("test-topic"); // 使用Session对象创建一个消费者对象 MessageConsumer consumer = session.createConsumer(topic); // 接收消息 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; // 打印结果 TextMessage textMessage = (TextMessage) message; String text; try &#123; text = textMessage.getText(); System.out.println(text); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); System.out.println("topic 消费者3已经启动"); // 等待接收消息 System.in.read(); // 关闭资源 consumer.close(); session.close(); connection.close();&#125; 作者：lhsjohn]]></content>
      <categories>
        <category>项目</category>
        <category>java</category>
        <category>ActiveMQ</category>
      </categories>
      <tags>
        <tag>ActiveMQ</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SolrCloud，一个分布式搜索方案]]></title>
    <url>%2F2018%2F08%2F14%2FSolrCloud%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[最近搞分布式搜索服务的实现，一直受到性能的瓶颈制约，单机版的solr服务对于少数用户体验还可以，但是涉及到几千的并发的时候，难免会造成性能的突然下降。 下面是一套利用solr和zookeeper实现的分布式搜索架构方案 Solr集群的系统架构 三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud。 索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。用户发起索引请求分别从shard1和shard2上获取，解决高并发问题。 Collection在SolrCloud集群中是一个逻辑意义上的完整的索引结构。它常常被划分为一个或多个Shard（分片），它们使用相同的配置信息。比如：针对商品信息搜索可以创建一个collection。 collection=shard1+shard2+….+shardX 每个Core是Solr中一个独立运行单位，提供 索引和搜索服务。一个shard需要由一个Core或多个Core组成。由于collection由多个shard组成所以collection一般由多个core组成。 Master是master-slave结构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的。 Collection的逻辑分片。每个Shard被化成一个或者多个replication，通过选举确定哪个是Leader。 下面是我的实现方案 下面是大体的实现步骤 第一步：创建四个tomcat实例。每个tomcat运行在不同的端口。8180、8280、8380、8480 第二步：部署solr的war包。把单机版的solr工程复制到集群中的tomcat中。 第三步：为每个solr实例创建一个对应的solrhome。使用单机版的solrhome复制四份。 第四步：需要修改solr的web.xml文件。把solrhome关联起来。 第五步：配置solrCloud相关的配置。每个solrhome下都有一个solr.xml，把其中的ip及端口号配置好。 第六步：让zookeeper统一管理配置文件。需要把solrhome/collection1/conf目录上传到zookeeper。上传任意solrhome中的配置文件即可。 第七步：修改tomcat/bin目录下的catalina.sh 文件，关联solr和zookeeper。把此配置添加到配置文件中：JAVA_OPTS=”-DzkHost=192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183” 第八步：启动每个tomcat实例。要包装zookeeper集群是启动状态。 第九步：访问集群 第十步：创建新的Collection进行分片处理。http://192.168.25.154:8180/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 第十一步：删除不用的Collection。http://192.168.25.154:8180/solr/admin/collections?action=DELETE&amp;name=collection1 在java中我们可以使用solrJ来对集群进行操作 使用步骤：第一步：把solrJ相关的jar包添加到工程中。 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。 第三步：需要设置DefaultCollection属性。 第四步：创建一SolrInputDocument对象。 第五步：向文档对象中添加域 第六步：把文档对象写入索引库。 第七步：提交。 最后来一段测试java代码 1234567891011121314151617181920@Test public void testSolrCloudAddDocument() throws Exception &#123; // 第一步：把solrJ相关的jar包添加到工程中。 // 第二步：创建一个SolrServer对象，需要使用CloudSolrServer子类。构造方法的参数是zookeeper的地址列表。 //参数是zookeeper的地址列表，使用逗号分隔 CloudSolrServer solrServer = new CloudSolrServer("192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183"); // 第三步：需要设置DefaultCollection属性。 solrServer.setDefaultCollection("collection2"); // 第四步：创建一SolrInputDocument对象。 SolrInputDocument document = new SolrInputDocument(); // 第五步：向文档对象中添加域 document.addField("item_title", "测试商品"); document.addField("item_price", "100"); document.addField("id", "test001"); // 第六步：把文档对象写入索引库。 solrServer.add(document); // 第七步：提交。 solrServer.commit(); &#125; 完毕！ 作者: lhsjohn]]></content>
      <categories>
        <category>项目</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>solr+zookeeper</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastdfs]]></title>
    <url>%2F2018%2F08%2F11%2Ffastdfs%2F</url>
    <content type="text"><![CDATA[FastDFS是C语言开发，建议在linux上运行，下面使用Centos6.4作为安装环境。安装FastDFS需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc：yum install gcc-c++ 安装libeventFastDFS依赖libevent库，需要安装： yum -y install libevent 安装libfastcommonlibfastcommon是FastDFS官方提供的，libfastcommon包含了FastDFS运行所需要的一些基础库。将libfastcommonV1.0.7.tar.gz拷贝至/usr/local/下 cd /usr/local tar -zxvf libfastcommonV1.0.7.tar.gz cd libfastcommon-1.0.7./make.sh ./make.sh install 注意：libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。 tracker编译安装将FastDFS_v5.05.tar.gz拷贝至/usr/local/下 tar -zxvf FastDFS_v5.05.tar.gz cd FastDFS ./make.sh ./make.sh install 安装成功将安装目录下的conf下的文件拷贝到/etc/fdfs/下。 配置安装成功后进入/etc/fdfs目录：拷贝一份新的tracker配置文件： cp tracker.conf.sample tracker.conf 修改tracker.confvi tracker.confbase_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFS 启动/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart启动的日志显示先停止5619进程（实际环境不是5619） 设置开机启动 vim /etc/rc.d/rc.local 将运行命令行添加进文件：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart 下面安装FastDFS-storage 安装libevent同tracker 安装libfastcommon同tracker 配置安装成功后进入/etc/fdfs目录： 拷贝一份新的storage配置文件：cp storage.conf.sample storage.conf 修改storage.conf vi storage.conf 1234567891011修改storage.confvi storage.confgroup_name=group1base_path=/home/yuqing/FastDFS改为：base_path=/home/FastDFSstore_path0=/home/yuqing/FastDFS改为：store_path0=/home/FastDFS/fdfs_storage#如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......tracker_server=192.168.101.3:22122 #配置tracker服务器:IP#如果有多个则配置多个trackertracker_server=192.168.101.4:22122 启动/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart 设置开机启动 vim /etc/rc.d/rc.local 将运行命令行添加进文件：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart tracker.conf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711 基本配置disable#func：配置是否生效#valu：true、falsedisable=falsebind_addr#func：绑定IP#valu：IP地址bind_addr=192.168.6.102port#func：服务端口#valu：端口整数值port=22122connect_timeout#func：连接超时#valu：秒单位正整数值connect_timeout=30network_timeout#func：网络超时#valu：秒单位正整数值network_timeout=60base_path#func：Tracker数据/日志目录地址#valu：路径base_path=/home/michael/fdfs/base4trackermax_connections#func：最大连接数#valu：正整数值max_connections=256work_threads#func：线程数，通常设置CPU数#valu：正整数值work_threads=4store_lookup#func：上传文件的选组方式。#valu：0、1或2。# 0：表示轮询# 1：表示指定组# 2：表示存储负载均衡（选择剩余空间最大的组）store_lookup=2store_group#func：指定上传的组，如果在应用层指定了具体的组，那么这个参数将不会起效。另外如果store_lookup如果是0或2，则此参数无效。#valu：group1等store_group=group1store_server#func：上传服务器的选择方式。(一个文件被上传后，这个storage server就相当于这个文件的storage server源，会对同组的storage server推送这个文件达到同步效果)#valu：0、1或2# 0: 轮询方式（默认）# 1: 根据ip 地址进行排序选择第一个服务器（IP地址最小者）# 2: 根据优先级进行排序（上传优先级由storage server来设置，参数名为upload_priority），优先级值越小优先级越高。store_server=0store_path#func：上传路径的选择方式。storage server可以有多个存放文件的base path（可以理解为多个磁盘）。#valu：# 0: 轮流方式，多个目录依次存放文件# 2: 存储负载均衡。选择剩余空间最大的目录存放文件（注意：剩余磁盘空间是动态的，因此存储到的目录或磁盘可能也是变化的）store_path=0download_server#func：下载服务器的选择方式。#valu：# 0：轮询（默认）# 1：IP最小者# 2：优先级排序（值最小的，优先级最高。）download_server=0reserved_storage_space#func：保留空间值。如果某个组中的某个服务器的剩余自由空间小于设定值，则文件不会被上传到这个组。#valu：# G or g for gigabyte# M or m for megabyte# K or k for kilobytereserved_storage_space=1GBlog_level#func：日志级别#valu：# emerg for emergency# alert# crit for critical# error# warn for warning# notice# info for information# debug for debugginglog_level=inforun_by_group / run_by_user#func：指定运行该程序的用户组#valu：用户组名或空run_by_group=#func：#valu：run_by_user=allow_hosts#func：可以连接到tracker server的ip范围。可设定多个值。#valuallow_hosts=check_active_interval#func：检测 storage server 存活的时间隔，单位为秒。# storage server定期向tracker server 发心跳，# 如果tracker server在一个check_active_interval内还没有收到storage server的一次心跳，# 那边将认为该storage server已经下线。所以本参数值必须大于storage server配置的心跳时间间隔。# 通常配置为storage server心跳时间间隔的2倍或3倍。check_active_interval=120thread_stack_size#func：设定线程栈的大小。 线程栈越大，一个线程占用的系统资源就越多。# 如果要启动更多的线程（V1.x对应的参数为max_connections，V2.0为work_threads），可以适当降低本参数值。#valu：如64KB，默认值为64，tracker server线程栈不应小于64KBthread_stack_size=64KBstorage_ip_changed_auto_adjust#func：这个参数控制当storage server IP地址改变时，集群是否自动调整。注：只有在storage server进程重启时才完成自动调整。#valu：true或falsestorage_ip_changed_auto_adjust=true2 同步storage_sync_file_max_delay#func：同组storage服务器之间同步的最大延迟时间。存储服务器之间同步文件的最大延迟时间，根据实际情况进行调整#valu：秒为单位，默认值为1天（24*3600）#sinc：v2.0storage_sync_file_max_delay=86400storage_sync_file_max_time#func：存储服务器同步一个文件需要消耗的最大时间，缺省为300s，即5分钟。#sinc：v2.0storage_sync_file_max_time=300sync_log_buff_interval#func：同步或刷新日志信息到硬盘的时间间隔。注意：tracker server 的日志不是时时写硬盘的，而是先写内存。#valu：以秒为单位sync_log_buff_interval=103 trunk 和 slot#func：是否使用trunk文件来存储几个小文件#valu：true或false#sinc：v3.0use_trunk_file=false#func：最小slot大小#valu：&lt;= 4KB，默认为256字节#sinc：v3.0slot_min_size=256#func：最大slot大小#valu：&gt;= slot_min_size，当小于这个值的时候就存储到trunk file中。默认为16MB。#sinc：v3.0slot_max_size=16MB#func：trunk file的size#valu：&gt;= 4MB，默认为64MB#sinc：v3.0trunk_file_size=64MB4 HTTP 相关是否启用 HTTP#func：HTTP是否生效#valu：true或falsehttp.disabled=falseHTTP 服务器端口号#func：tracker server上的http port#valu：#note：只有http.disabled=false时才生效http.server_port=7271检查Storage存活状态的间隔时间（心跳检测）#func：检查storage http server存活的间隔时间#valu：单位为秒#note：只有http.disabled=false时才生效http.check_alive_interval=30心跳检测使用的协议方式#func：检查storage http server存活的方式#valu：# tcp：连接到storage server的http端口，不进行request和response。# http：storage check alive url must return http status 200.#note：只有http.disabled=false时才生效http.check_alive_type=tcp检查 Storage 状态的 URI#func：检查storage http server是否alive的uri/url#note：只有http.disabled=false时才生效http.check_alive_uri=/status.html]]></content>
      <categories>
        <category>项目</category>
        <category>java</category>
        <category>fastdfs</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
        <tag>fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pom文件]]></title>
    <url>%2F2018%2F08%2F08%2FPom%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.e3mall&lt;/groupId&gt; &lt;artifactId&gt;e3-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!-- 集中定义依赖版本号 --&gt; &lt;properties&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.2.2&lt;/mybatis.spring.version&gt; &lt;mybatis.paginator.version&gt;1.2.15&lt;/mybatis.paginator.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;slf4j.version&gt;1.6.4&lt;/slf4j.version&gt; &lt;jackson.version&gt;2.4.2&lt;/jackson.version&gt; &lt;druid.version&gt;1.0.9&lt;/druid.version&gt; &lt;httpclient.version&gt;4.3.5&lt;/httpclient.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt; &lt;joda-time.version&gt;2.5&lt;/joda-time.version&gt; &lt;commons-lang3.version&gt;3.3.2&lt;/commons-lang3.version&gt; &lt;commons-io.version&gt;1.3.2&lt;/commons-io.version&gt; &lt;commons-net.version&gt;3.3&lt;/commons-net.version&gt; &lt;pagehelper.version&gt;3.4.2-fix&lt;/pagehelper.version&gt; &lt;jsqlparser.version&gt;0.9.1&lt;/jsqlparser.version&gt; &lt;commons-fileupload.version&gt;1.3.1&lt;/commons-fileupload.version&gt; &lt;jedis.version&gt;2.7.2&lt;/jedis.version&gt; &lt;solrj.version&gt;4.10.3&lt;/solrj.version&gt; &lt;dubbo.version&gt;2.5.3&lt;/dubbo.version&gt; &lt;zookeeper.version&gt;3.4.7&lt;/zookeeper.version&gt; &lt;zkclient.version&gt;0.1&lt;/zkclient.version&gt; &lt;activemq.version&gt;5.11.2&lt;/activemq.version&gt; &lt;freemarker.version&gt;2.3.23&lt;/freemarker.version&gt; &lt;quartz.version&gt;2.2.2&lt;/quartz.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- 时间操作组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;$&#123;joda-time.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Apache工具组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-io.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-net.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Jackson Json处理工具包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- httpclient --&gt; &lt;!--more--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- quartz任务调度框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;$&#123;quartz.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志处理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.paginator.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;$&#123;pagehelper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 文件上传组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Redis客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- solr客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.solr&lt;/groupId&gt; &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt; &lt;version&gt;$&#123;solrj.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;$&#123;freemarker.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;finalName&gt;$&#123;project.artifactId&#125;&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(四)-----单件模式]]></title>
    <url>%2F2018%2F08%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E5%9B%9B)-----%E5%8D%95%E4%BB%B6%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单件模式的定义确保一个类只有一个实例，并提供一个全局访问点。 类图 1.其中uniqueInstance 变量持有唯一的单间实例 2.getInstance()方法是静态的，这意味着它是一个类方法，所以可以在代码的任何地方使用Singleton.getnstance()访问它。这样和访问全局变量一样，只是多了一个优点：单件可以延迟实例化。 3.单件模式的类也可以是一般的类，具有一般的数据和方法。 下面是一个单件模式的经典实现： 1234567891011121314151617181920212223 Public class Singleton()&#123;//利用一个静态变量来记录Singleton类的唯一实例Private static Singleton uniqueInstance;//这里是用到的其他的有用的实例化的变量//把构造器类设置为私有的，只有自Singleton类内才可以调用构造器Private Singleton() &#123; &#125; //用getInstance()方法实例化对象，并返回这个对象的实例 Public static Singleton getInstance()&#123; If(uniqueInstance==null) &#123; uniqueInstance=new Singleton(); &#125; Return uniqueInstance; &#125;//这里是其他有用的方法&#125; 单件模式的多线程之伤 现在我们知道，绝大多数的应用程序都是多线程的，那么我们如果采用上面经典的单例模式的实现化，遇到多线程情况，就会遇到很大的麻烦了 下面我们来处理这种麻烦，处理多线程 在这里只需要我们把getInstance() 变成同步(synchronized)方法即可。 1234567891011121314151617181920212223 Public class Singleton()&#123;//利用一个静态变量来记录Singleton类的唯一实例 Private static Singleton uniqueInstance;//这里是用到的其他的有用的实例化的变量 //把构造器类设置为私有的，只有自Singleton类内才可以调用构造器Private Singleton() &#123; &#125; //用getInstance()方法实例化对象，并返回这个对象的实例Public static synchronized Singleton getInstance()&#123; if(uniqueInstance==null) &#123; uniqueInstance=new Singleton();&#125; Return uniqueInstance; &#125;//这里是其他有用的方法&#125; 通过增加synchronized 关键字到getInstance()方法中,我们迫使每个线程在进入这个方法之前，要先等候别的线程离开该方法。也就是说，不会有两个线程可以同时进入这个方法。 但这里需要我们注意的是，尽管用这个方式可以很简单的解决了上面的问题，但是这种方法却会降低应用程序的性能。 所以我们考虑一下，能否改善多线程呢？ 下面是我们可以采取的几种选择： 1.如果getInstance()的性能对于应用程序不是很关键，就什么也不用去做，直接可以采取上面所说的加上 synchronized 的做法。 2.使用”急切”创建实例，而不用延迟实例化的方法 123456789101112131415 Public class Singleton&#123; //在静态初始化器中创建单件，这段代码保证了线程安全。Private static Singleton uniqueInstace= new Singleton(); Private Singleton () &#123;&#125;Public static Singleton getInstance() &#123; Return uniqueInstance; &#125; &#125; 采用这个做法，我们依赖JVM 在加载这个类时马上创建此唯一的单件实例。JVM保证在任何线程访问uniqueInstance静态变量之前，一定会创建此实例。 3.用“双重检查加锁”，在getInstance()中减少同步 利用双重检查加锁，首先检查是否实例已经创建了，如果尚未创建，”才”进行同步，这样一来，只有第一次会同步，这正是我们想要的。 123456789101112131415161718192021 Public class Singleton&#123; //在静态初始化器中创建单件，这段代码保证了线程安全。 Private static Singleton uniqueInstace; Private Singleton () &#123;&#125; Public static Singleton getInstance() &#123; If(uniqueInstance ==null)&#123; Synchronized(Singleton.class) &#123; If(uniqueInstance ==null)&#123; uniqueInstance =new Singleton(); &#125; &#125; &#125; Return uniqueInstance; &#125;&#125; 注意如果使用的是JVM1.2或之前的版本，我们必须建立单间注册表，以免垃圾回收器将单件回收。 总的来说，单件模式相对于其他模式来说类图结构虽然没有那么复杂，但它却扮演着非常重要的角色，在保证应用程序的稳定性和安全性方面起着非常重要的作用。 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道算法题]]></title>
    <url>%2F2018%2F08%2F06%2F%E4%B8%80%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法题:请用js根据网站用户的内裤颜色调改变网站主题文字颜色。]]></content>
      <categories>
        <category>段子</category>
      </categories>
      <tags>
        <tag>段子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threadqiushi.py]]></title>
    <url>%2F2018%2F08%2F06%2Fthreadqiushi.py%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#!/usr/bin/env python# -*- coding:utf-8 -*-# 使用了线程库import threading# 队列from Queue import Queue# 解析库from lxml import etree# 请求处理import requests# json处理import jsonimport timeclass ThreadCrawl(threading.Thread): def __init__(self, threadName, pageQueue, dataQueue): #threading.Thread.__init__(self) # 调用父类初始化方法 super(ThreadCrawl, self).__init__() # 线程名 self.threadName = threadName # 页码队列 self.pageQueue = pageQueue # 数据队列 self.dataQueue = dataQueue # 请求报头 self.headers = &#123;"User-Agent" : "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;"&#125; def run(self): print "启动 " + self.threadName while not CRAWL_EXIT: try: # 取出一个数字，先进先出 # 可选参数block，默认值为True #1. 如果对列为空，block为True的话，不会结束，会进入阻塞状态，直到队列有新的数据 #2. 如果队列为空，block为False的话，就弹出一个Queue.empty()异常， page = self.pageQueue.get(False) url = "http://www.qiushibaike.com/8hr/page/" + str(page) +"/" #print url content = requests.get(url, headers = self.headers).text time.sleep(1) self.dataQueue.put(content) #print len(content) except: pass print "结束 " + self.threadName &lt;!--more--&gt;class ThreadParse(threading.Thread): def __init__(self, threadName, dataQueue, filename, lock): super(ThreadParse, self).__init__() # 线程名 self.threadName = threadName # 数据队列 self.dataQueue = dataQueue # 保存解析后数据的文件名 self.filename = filename # 锁 self.lock = lock def run(self): print "启动" + self.threadName while not PARSE_EXIT: try: html = self.dataQueue.get(False) self.parse(html) except: pass print "退出" + self.threadName def parse(self, html): # 解析为HTML DOM html = etree.HTML(html) node_list = html.xpath('//div[contains(@id, "qiushi_tag")]') for node in node_list: # xpath返回的列表，这个列表就这一个参数，用索引方式取出来，用户名 username = node.xpath('./div/a/@title')[0] # 图片连接 image = node.xpath('.//div[@class="thumb"]//@src')#[0] # 取出标签下的内容,段子内容 content = node.xpath('.//div[@class="content"]/span')[0].text # 取出标签里包含的内容，点赞 zan = node.xpath('.//i')[0].text # 评论 comments = node.xpath('.//i')[1].text items = &#123; "username" : username, "image" : image, "content" : content, "zan" : zan, "comments" : comments &#125; # with 后面有两个必须执行的操作：__enter__ 和 _exit__ # 不管里面的操作结果如何，都会执行打开、关闭 # 打开锁、处理内容、释放锁 with self.lock: # 写入存储的解析后的数据 self.filename.write(json.dumps(items, ensure_ascii = False).encode("utf-8") + "\n")CRAWL_EXIT = FalsePARSE_EXIT = Falsedef main(): # 页码的队列，表示20个页面 pageQueue = Queue(20) # 放入1~10的数字，先进先出 for i in range(1, 21): pageQueue.put(i) # 采集结果(每页的HTML源码)的数据队列，参数为空表示不限制 dataQueue = Queue() filename = open("duanzi.json", "a") # 创建锁 lock = threading.Lock() # 三个采集线程的名字 crawlList = ["采集线程1号", "采集线程2号", "采集线程3号"] # 存储三个采集线程的列表集合 threadcrawl = [] for threadName in crawlList: thread = ThreadCrawl(threadName, pageQueue, dataQueue) thread.start() threadcrawl.append(thread) # 三个解析线程的名字 parseList = ["解析线程1号","解析线程2号","解析线程3号"] # 存储三个解析线程 threadparse = [] for threadName in parseList: thread = ThreadParse(threadName, dataQueue, filename, lock) thread.start() threadparse.append(thread) # 等待pageQueue队列为空，也就是等待之前的操作执行完毕 while not pageQueue.empty(): pass # 如果pageQueue为空，采集线程退出循环 global CRAWL_EXIT CRAWL_EXIT = True print "pageQueue为空" for thread in threadcrawl: thread.join() print "1" while not dataQueue.empty(): pass global PARSE_EXIT PARSE_EXIT = True for thread in threadparse: thread.join() print "2" with lock: # 关闭文件 filename.close() print "谢谢使用！"if __name__ == "__main__": main()]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活带有主观性 —— 二刷《当幸福来敲门》]]></title>
    <url>%2F2018%2F08%2F05%2F%E7%94%9F%E6%B4%BB%E5%B8%A6%E6%9C%89%E4%B8%BB%E8%A7%82%E6%80%A7%E4%BA%8C%E5%88%B7%E3%80%8A%E5%BD%93%E5%B9%B8%E7%A6%8F%E6%9D%A5%E6%95%B2%E9%97%A8%E3%80%8B%2F</url>
    <content type="text"><![CDATA[“黑夜给了我黑色的眼睛，我却用它寻找光明”。这是顾城的一句经典语录，如果可以的话，我想把这个经典语录赋予给这个拥有灵魂的电影。 这部电影带给你最大的震撼或许就是，不同的成长阶段，你对他的感受会有所不同吧。 第一次观看这部电影大概是在三年前，高二的时候。应试型的教育形式一遍又一遍的在你身边重复显现，或许就真的变成了考试的机器一般，学习与考试，你的时间完全不在你手上，做不了自己喜欢的事情，成绩再好也毫无意义。 也就在这个状态之下，我观看了这么一部电影。这或许也是看到开头就能知道故事结局的一部电影，但是它确实有足够的魅力来吸引人们去观看它，去思考我们眼睛看不到的地方。 “克里斯·加德纳，生活在旧金山的黑人男青年，靠做推销员养着老婆还有幼子。克里斯从没觉得日子过得很幸福，当然也没很痛苦，就跟美国千千万普通男人一样过着平淡的生活，直到有一天，一系列突如其来的变故才让克里斯知道，原来平淡的日子有多珍贵。 首先，他丢了工作，公司裁员让他丢了饭碗。克里斯从此遭遇了一连串重大打击，妻子因忍受不了长期的贫困生活愤而出走，连六岁大的儿子（杰登·史密斯）也一同带走。没过多久，妻子又把儿子还给了克里斯，从此克里斯不仅要面对失业的困境，还要独立抚养儿子。没过多久，克里斯因长期欠交房租被房东赶出家门，带着儿子流落街头。在接下的两三年中，这对苦命父子的住所从纸皮箱搬到公共卫生间。克里斯坚强面对困境时刻打散工赚钱，同时也努力培养孩子乐观面对困境的精神，父子俩日子虽苦，但还是能快乐生活。一次，克里斯在停车场遇见一个开高级跑车的男人，克里斯问他做什么工作才能过上这样的生活，那男人告诉他自己是做股票经纪人的，克里斯从此就决定自己要做一个出色的股票经纪人，和儿子过上好日子。完全没有股票知识的克里斯靠着毅力在华尔街一家股票公司当上学徒，头脑灵活的他很快就掌握了股票市场的知识，随后开上了自己的股票经纪公司，最后成为百万富翁。一路上克里斯经历了不少挫折，但是年幼的儿子每次都能给予他最大的鼓励，两父子相互扶持最终完成了又一个美国梦。” 克里斯是幸运的的也是不幸运的。 他的不幸运来源于他之前的穷困潦倒，虽然这部电影并没有给我们介绍他之前的背景，我们也就无法得知他现在处境的原因，电影的开头只是给我们说明了确实有这么一个处境，至于其他的部分，就由你来想吧! 或许是他年轻时候的不努力也或者是他年轻时因为某些变故造成的自己与机会的远离。但是在那个年代，机会似乎也没有那么多。 高二的时候看这部影片，确实是一部实实在在的励志电影，一个人靠着自己坚定的意志力和常人难以接受的决定来改变自己的人生。给我当时增加了不少的动力，这些动力，来源于他的勇敢。 成功一帆风顺固然很好，但是如果你走的道路太顺利了，只能说明这条路很多人和你一样走过。 克里斯是一个真正的爷们，他的刚强，并不是一些人眼中所说的身强体壮，而是他重重的责任感以及永不抱怨的精神。即便在最为穷困的时候，也给自己孩子买了心爱的生日礼物，带着孩子吃甜点而自己也只是在旁边看着，妻子离她而去，自己也毅然而然扛起了生活的重担。看电影的时候都会为他感到着急，为什么运气会那么差，“屋漏偏逢天阴雨”，又看到屏幕上的一个个的弹幕，有庆幸自己成功的，也有刚失败激励自己重头再来的，只能说是，事态纷杂，每个人的经历都不一样，获得真正意义上的成功，又有几个呢？ 他的幸运是让他在人生最为低谷的时候抓住了机会，我们看到的，机会不是别人送来的，是他自己争取来的，有他的努力，当然与他与人坦诚相处的态度也是分不开的。 今天又把这部电影看了一遍，思考的角度与当年却有些不同。 现在，我觉得克里斯是不幸的。 首先是对于成功的定义，我觉得这是一部被资本化了的电影，首先故事的背景就是发生在资本化的美国，人们以金钱来衡量自己的财富，作为判断自己的人生成败的重要标准。 这种价值观，太过于“唯物”。 也许大家沉浸于他的改变中无所自拔，想象着这大概就是生活最为美好的情况。但我们同时也注意到，克里斯似乎并没有朋友，没有知己，完全是一个人在单打独斗，哪怕是在自己最为穷困潦倒的时刻，也找不到一个可以歇息的地方，只能带着自己的小孩子去睡车站厕所。同时他也有一段比较失败的婚姻，生活的窘迫逼走了他的妻子，只有他和儿子相依为命，一个人奔走于城市街头，拼命寻找自己的机遇。 最后他虽然取得了物质上的成功，但他却也早已经失去了永远无法挽回的东西。这样的人生对于克里斯是幸福的吗？ 他的“成功”之外，还有很重要的一点，就是他的天赋。 要是克里斯没那份数学天赋呢？他要是玩不来魔方呢？作为一个天才，他的奋斗很感人。但真相是，大部分人只是普通人。他们绝对不可能像克里斯一样去做“股票经纪人”，但是即便如此，也不能一棒子打死就说是天赋决定了他的成功。 天赋或许是你开启一扇门的钥匙，但前提是你要找对那一扇门。有天赋的人相比于其他人来说，只是多了一条捷径。 更多普通人的成功，则是靠的自己的兴趣和热爱 。 只有你真正的去热爱一样东西，在别人眼里，你所经历的苦只是放在他们身上他们认为的苦而已，真正沉浸于其中的喜悦，别人不得而知。 有追求，有意义，有妥协。人生的黄金三词，妥协使你低姿态开启人生，以大众视角观察周围的世界，去发现新的机遇。有追求则是投身于自己真正喜欢的事业，与强者为伴，不断学习进步，同时增强自身的能力，抓住发现的机遇，敢于做出决定，两个字就是果断，三个字就是执行力。 有意义是建立在其他两个词的基础之上的，这种“意义”，不仅仅是自己价值的实现，不仅仅是看到自己给周围带来改变时的那种成就感，也兼顾人生的其他方面，包括社交、精神享受等种种方面。 无论是有天赋的人，还是有着一腔热血的人，或是平平凡凡的人，都应该脚踏实地，一步一个脚印，胜不骄败不馁，要真正认清楚自己所处的现实情况。不要对一时间的”成就”蒙蔽住了双眼，记住，你所谓的成就并不一定是别人眼中认为的成功。 因为，对成功这个词的定义，每个人是不一样的。但是对于努力这个词，每个人一定会是一样的。 永远也不要抱怨，不去计较不公平，只要自己肯做出改变，一切皆有可能。 这应该是我在大二结束之际二刷这部电影的收获了。随着你的成长，观察问题的视野和角度也在不断变换。 毕竟每个人都有每个人不同看待问题的观点，对于这个电影的评论也无法做到让每个人都赞同，但也不要人云亦云亦步亦趋就好了。 最后说一句，男主的精神值得我们去学习，但他的行为并不是代表对每个人都有效的，因为生活往往带有主观性。从这部影片中，我们理应自己感受到更多！ 作者：lhsjohn]]></content>
      <categories>
        <category>观后感</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>影评</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ez_setup.py]]></title>
    <url>%2F2018%2F08%2F04%2Fez_setup.py%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#!/usr/bin/env python"""Setuptools bootstrapping installer.Maintained at https://github.com/pypa/setuptools/tree/bootstrap.Run this script to install or upgrade setuptools.This method is DEPRECATED. Check https://github.com/pypa/setuptools/issues/581 for more details."""import osimport shutilimport sysimport tempfileimport zipfileimport optparseimport subprocessimport platformimport textwrapimport contextlibfrom distutils import logtry: from urllib.request import urlopenexcept ImportError: from urllib2 import urlopentry: from site import USER_SITEexcept ImportError: USER_SITE = None# 33.1.1 is the last version that supports setuptools self upgrade/installation.DEFAULT_VERSION = "33.1.1"DEFAULT_URL = "https://pypi.io/packages/source/s/setuptools/"DEFAULT_SAVE_DIR = os.curdirDEFAULT_DEPRECATION_MESSAGE = "ez_setup.py is deprecated and when using it setuptools will be pinned to &#123;0&#125; since it's the last version that supports setuptools self upgrade/installation, check https://github.com/pypa/setuptools/issues/581 for more info; use pip to install setuptools"MEANINGFUL_INVALID_ZIP_ERR_MSG = 'Maybe &#123;0&#125; is corrupted, delete it and try again.'log.warn(DEFAULT_DEPRECATION_MESSAGE.format(DEFAULT_VERSION))def _python_cmd(*args): """ Execute a command. Return True if the command succeeded. """ args = (sys.executable,) + args return subprocess.call(args) == 0def _install(archive_filename, install_args=()): """Install Setuptools.""" with archive_context(archive_filename): # installing log.warn('Installing Setuptools') if not _python_cmd('setup.py', 'install', *install_args): log.warn('Something went wrong during the installation.') log.warn('See the error message above.') # exitcode will be 2 return 2def _build_egg(egg, archive_filename, to_dir): """Build Setuptools egg.""" with archive_context(archive_filename): # building an egg log.warn('Building a Setuptools egg in %s', to_dir) _python_cmd('setup.py', '-q', 'bdist_egg', '--dist-dir', to_dir) # returning the result log.warn(egg) if not os.path.exists(egg): raise IOError('Could not build the egg.')class ContextualZipFile(zipfile.ZipFile): """Supplement ZipFile class to support context manager for Python 2.6.""" def __enter__(self): return self def __exit__(self, type, value, traceback): self.close() def __new__(cls, *args, **kwargs): """Construct a ZipFile or ContextualZipFile as appropriate.""" if hasattr(zipfile.ZipFile, '__exit__'): return zipfile.ZipFile(*args, **kwargs) return super(ContextualZipFile, cls).__new__(cls)&lt;!--more--&gt;@contextlib.contextmanagerdef archive_context(filename): """ Unzip filename to a temporary directory, set to the cwd. The unzipped target is cleaned up after. """ tmpdir = tempfile.mkdtemp() log.warn('Extracting in %s', tmpdir) old_wd = os.getcwd() try: os.chdir(tmpdir) try: with ContextualZipFile(filename) as archive: archive.extractall() except zipfile.BadZipfile as err: if not err.args: err.args = ('', ) err.args = err.args + ( MEANINGFUL_INVALID_ZIP_ERR_MSG.format(filename), ) raise # going in the directory subdir = os.path.join(tmpdir, os.listdir(tmpdir)[0]) os.chdir(subdir) log.warn('Now working in %s', subdir) yield finally: os.chdir(old_wd) shutil.rmtree(tmpdir)def _do_download(version, download_base, to_dir, download_delay): """Download Setuptools.""" py_desig = 'py&#123;sys.version_info[0]&#125;.&#123;sys.version_info[1]&#125;'.format(sys=sys) tp = 'setuptools-&#123;version&#125;-&#123;py_desig&#125;.egg' egg = os.path.join(to_dir, tp.format(**locals())) if not os.path.exists(egg): archive = download_setuptools(version, download_base, to_dir, download_delay) _build_egg(egg, archive, to_dir) sys.path.insert(0, egg) # Remove previously-imported pkg_resources if present (see # https://bitbucket.org/pypa/setuptools/pull-request/7/ for details). if 'pkg_resources' in sys.modules: _unload_pkg_resources() import setuptools setuptools.bootstrap_install_from = eggdef use_setuptools( version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=DEFAULT_SAVE_DIR, download_delay=15): """ Ensure that a setuptools version is installed. Return None. Raise SystemExit if the requested version or later cannot be installed. """ to_dir = os.path.abspath(to_dir) # prior to importing, capture the module state for # representative modules. rep_modules = 'pkg_resources', 'setuptools' imported = set(sys.modules).intersection(rep_modules) try: import pkg_resources pkg_resources.require("setuptools&gt;=" + version) # a suitable version is already installed return except ImportError: # pkg_resources not available; setuptools is not installed; download pass except pkg_resources.DistributionNotFound: # no version of setuptools was found; allow download pass except pkg_resources.VersionConflict as VC_err: if imported: _conflict_bail(VC_err, version) # otherwise, unload pkg_resources to allow the downloaded version to # take precedence. del pkg_resources _unload_pkg_resources() return _do_download(version, download_base, to_dir, download_delay)def _conflict_bail(VC_err, version): """ Setuptools was imported prior to invocation, so it is unsafe to unload it. Bail out. """ conflict_tmpl = textwrap.dedent(""" The required version of setuptools (&gt;=&#123;version&#125;) is not available, and can't be installed while this script is running. Please install a more recent version first, using 'easy_install -U setuptools'. (Currently using &#123;VC_err.args[0]!r&#125;) """) msg = conflict_tmpl.format(**locals()) sys.stderr.write(msg) sys.exit(2)def _unload_pkg_resources(): sys.meta_path = [ importer for importer in sys.meta_path if importer.__class__.__module__ != 'pkg_resources.extern' ] del_modules = [ name for name in sys.modules if name.startswith('pkg_resources') ] for mod_name in del_modules: del sys.modules[mod_name]def _clean_check(cmd, target): """ Run the command to download target. If the command fails, clean up before re-raising the error. """ try: subprocess.check_call(cmd) except subprocess.CalledProcessError: if os.access(target, os.F_OK): os.unlink(target) raisedef download_file_powershell(url, target): """ Download the file at url to target using Powershell. Powershell will validate trust. Raise an exception if the command cannot complete. """ target = os.path.abspath(target) ps_cmd = ( "[System.Net.WebRequest]::DefaultWebProxy.Credentials = " "[System.Net.CredentialCache]::DefaultCredentials; " '(new-object System.Net.WebClient).DownloadFile("%(url)s", "%(target)s")' % locals() ) cmd = [ 'powershell', '-Command', ps_cmd, ] _clean_check(cmd, target)def has_powershell(): """Determine if Powershell is available.""" if platform.system() != 'Windows': return False cmd = ['powershell', '-Command', 'echo test'] with open(os.path.devnull, 'wb') as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_powershell.viable = has_powershelldef download_file_curl(url, target): cmd = ['curl', url, '--location', '--silent', '--output', target] _clean_check(cmd, target)def has_curl(): cmd = ['curl', '--version'] with open(os.path.devnull, 'wb') as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_curl.viable = has_curldef download_file_wget(url, target): cmd = ['wget', url, '--quiet', '--output-document', target] _clean_check(cmd, target)def has_wget(): cmd = ['wget', '--version'] with open(os.path.devnull, 'wb') as devnull: try: subprocess.check_call(cmd, stdout=devnull, stderr=devnull) except Exception: return False return Truedownload_file_wget.viable = has_wgetdef download_file_insecure(url, target): """Use Python to download the file, without connection authentication.""" src = urlopen(url) try: # Read all the data in one block. data = src.read() finally: src.close() # Write all the data in one block to avoid creating a partial file. with open(target, "wb") as dst: dst.write(data)download_file_insecure.viable = lambda: Truedef get_best_downloader(): downloaders = ( download_file_powershell, download_file_curl, download_file_wget, download_file_insecure, ) viable_downloaders = (dl for dl in downloaders if dl.viable()) return next(viable_downloaders, None)def download_setuptools( version=DEFAULT_VERSION, download_base=DEFAULT_URL, to_dir=DEFAULT_SAVE_DIR, delay=15, downloader_factory=get_best_downloader): """ Download setuptools from a specified location and return its filename. `version` should be a valid setuptools version number that is available as an sdist for download under the `download_base` URL (which should end with a '/'). `to_dir` is the directory where the egg will be downloaded. `delay` is the number of seconds to pause before an actual download attempt. ``downloader_factory`` should be a function taking no arguments and returning a function for downloading a URL to a target. """ # making sure we use the absolute path to_dir = os.path.abspath(to_dir) zip_name = "setuptools-%s.zip" % version url = download_base + zip_name saveto = os.path.join(to_dir, zip_name) if not os.path.exists(saveto): # Avoid repeated downloads log.warn("Downloading %s", url) downloader = downloader_factory() downloader(url, saveto) return os.path.realpath(saveto)def _build_install_args(options): """ Build the arguments to 'python setup.py install' on the setuptools package. Returns list of command line arguments. """ return ['--user'] if options.user_install else []def _parse_args(): """Parse the command line for options.""" parser = optparse.OptionParser() parser.add_option( '--user', dest='user_install', action='store_true', default=False, help='install in user site package') parser.add_option( '--download-base', dest='download_base', metavar="URL", default=DEFAULT_URL, help='alternative URL from where to download the setuptools package') parser.add_option( '--insecure', dest='downloader_factory', action='store_const', const=lambda: download_file_insecure, default=get_best_downloader, help='Use internal, non-validating downloader' ) parser.add_option( '--version', help="Specify which version to download", default=DEFAULT_VERSION, ) parser.add_option( '--to-dir', help="Directory to save (and re-use) package", default=DEFAULT_SAVE_DIR, ) options, args = parser.parse_args() # positional arguments are ignored return optionsdef _download_args(options): """Return args for download_setuptools function from cmdline args.""" return dict( version=options.version, download_base=options.download_base, downloader_factory=options.downloader_factory, to_dir=options.to_dir, )def main(): """Install or upgrade setuptools and EasyInstall.""" options = _parse_args() archive = download_setuptools(**_download_args(options)) return _install(archive, _build_install_args(options))if __name__ == '__main__': sys.exit(main())]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(三)装饰者模式]]></title>
    <url>%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%B8%89)-----%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式的定义装饰者模式动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 可以这么说：“装饰者模式给爱用继承的人一个全新的眼界” 下面来看一个装饰者模式的使用案例 对于一家咖啡店的订单系统，起初所有种类咖啡的类都是继承自饮料类的(Beverage),其中饮料类是一个抽象的类，内有description的实例变量，用来描述所做的饮料，有cost()方法来返回价钱。 但是我们都知道，咖啡的种类有很多很多种，加入的调料也不尽相同，比如说我们可以定制摩卡咖啡，奶泡咖啡等，且这些调料的价钱也是不尽相同的，或许我们最初想法是再将咖啡的种类根据调料来进行划分，派生出更多的子类出来，但是这种做法是不明智的，咖啡的种类有成千上百种，调料也有成千上百种，照这个思想进行下去的话，岂不是要派生出一大堆类出来，这对于系统的维护来说也将是一个棘手的事情。 那么，有没有其他的解决方案呢？ 答案是肯定的，在这里就是需要用到一个经典的设计模式——装饰者模式。 在这个例子中，我们要以饮料为主体，然后在运行时以调料来装饰饮料。举个栗子，如果顾客想要一杯摩卡和奶泡深焙咖啡，我们要做的事情有 1.拿一个深焙咖啡(DarkRoast)对象 2.以摩卡(Mocha)对象装饰它 3.以奶泡(Whip)对象装饰它 4.调用cost()方法，并依赖委托将调料的价钱加上去 以装饰者构造饮料订单 1.以DarkRoast对象开始，DarkRoast对象继承自Beverage，并且有一个用来计算饮料价钱的cost()方法。 2.顾客想要摩卡(Mocha)，所以建立一个Mocha对象，并用它将DarkRoast对象包起来，Mocha对象是一个装饰者，它的类型反映了它所装饰的对象，在本例中，也就是Beverage, 也就是说两者的类型一致。所以Mocha也有一个cost()方法，通过多态，也可以把Mocha包裹的任何Beverage当成是Beverage，因为Mocha是Berverage的子类型。 3.顾客也想要奶泡(Whip),所以需要建立一个Whip装饰者，并用它将Mocha对象包起来。 4.现在，顾客开始结账了。通过调用最外圈装饰者(Whip)的cost()就可以了。Whip的cost()会先委托它装饰的对象，在这里也就是Mocha，计算出价钱，然后再加上奶泡的价钱。(这种包裹关系你可以理解成食堂里的鸡蛋，鸡蛋壳包着鸡蛋清，鸡蛋清里面又有鸡蛋黄，但它们都是鸡蛋) 现在我们可以做一个简单的总结了 1.装饰者和被装饰对象有着相同的超类型。 2.你可以用一个或者多个装饰者包装一个对象 3.因为装饰者和被装饰的对象有着共同的超类型，所以在任何需要原始对象(被包装的)场合，可以用装饰过的对象代替它。 4.装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，来达到特定的目的。 5.对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。 下面是装饰者模式的类图 下面上代码，把设计转化成代码 先从Berverage类下手 1234567891011121314 Public abstract class Beverage&#123; String description=”Unknow Beverage “;Public String getDescription()&#123; Return description;&#125;Public abstract double cost();&#125; 下面让我们来实现Condiment(调料)抽象类，也就是装饰者类 1234567 Public abstract class CondimentDecorator extends Beverage&#123;Public abstract String getDescription();&#125; 现在我们有了基类，接下来是实现一些饮料，写一些饮料的代码 12345678910111213141516171819202122232425262728Public class Espresso extends Beverage&#123; Public Espresso()&#123; Description=”Espresso”; &#125; Public double cost()&#123; Return 1.99; &#125;&#125;Public class HouseBlend extends Beverage&#123; Public HouseBlend()&#123; Description=”House Blend Coffee”;&#125; Public double cost()&#123; Return 0.89; &#125;&#125; 写调料的代码 123456789101112131415161718192021 Public class Mocha extends CondimentDecorator&#123; Beverage beverage; Public Mocha(Beverage beverage)&#123; this.beverage=beverage; &#125; Public String getDescription()&#123; return beverage.getDescription() +”, Mocha”; &#125; Public double cost()&#123; return 0.20+beverage.cost(); &#125;&#125; 最后，是测试代码 1234567891011121314151617 Public class CoffeeOrders&#123; Public static void main(String[] args)&#123; Beverage beverage=new Espresso(); System.out.println(beverage.getDescription() +” $“+beverage.cost()); Beverage beverage2=new HouseBlend(); beverage2 =new Mocha(beverage2); //用Mocha装饰它 beverage2 =new Mocha(beverage2); //用第二个Mocha装饰它 beverage2 =new Whip(beverage2); System.out.println(beverage2.getDescription()+” $ ”+ beverage2.cost()); &#125;&#125; 输出结果为 Espresso $ 1.99 House Blend Coffee ,Mocha, Mocha, Whip $1.29 这样所有的代码就算完成了，总结说来，我们还应该记住一个新的设计原则 即“类应该对扩展开放，对修改关闭” jdk中也有很多地方用到了装饰者设计模式， 例如JAVA I/O 中的API很多就采取了这种模式 下面是收集的一些比较好的有关于装饰者者模式的博文 设计模式–装饰者模式思考 https://mrdear.cn/2018/03/08/experience/design_patterns--decorator_model/ JDK中的设计模式之装饰者模式 https://blog.csdn.net/kangkanglou/article/details/78744970 Spring容器装饰者模式应用之实现业务类与服务类自由组合的解决方案 https://blog.csdn.net/a1314517love/article/details/47705327 作者:lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib2爬虫初级 (二)]]></title>
    <url>%2F2018%2F08%2F01%2Furllib2%E7%88%AC%E8%99%AB%E5%88%9D%E7%BA%A7(%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[昨天用urllib模拟GET请求爬取了百度贴吧的一些内容，但是现在网络上还有很多数据是通过POST请求获得的，更复杂的情况是你要面临着如ajax的一些动态加载的数据，你所要获取的数据不能仅仅限于你在浏览器网页里看到的数据，所以在这里有几个处理的方法。 POST请求发送Request请求对象的里有data参数，它就是用在POST里的，我们要传送的数据就是这个参数data，data是一个字典，里面要匹配键值对 下面是流行的一个比较火的学习案例，通过POST请求模拟有道词典的翻译(之所以选择有道词典，是因为有些翻译词典发起的请求是GET的，这就很狗血了) 首先开启了我Chrome浏览器中的代理插件，要模仿有道词典翻译的工作我们需要得到有关的url以及data数据 这些数据的获取是我们通过抓包获取的 之前的博客写过我现在用的是Fiddler 来抓包的，功能还算比较强大用起来还是挺舒服的。 输入“我爱python” 的文字进行翻译，点击翻译按钮来发起一个请求，如下 下面是我抓到的包 于是接下来我们可以用来模拟发送POST请求 12345678910111213141516171819202122232425# -*- coding:UTF-8 -*-import urllibimport urllib2url="http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule "key =raw_input("请输入需要翻译的文字:")headers=&#123;"User-Agent":"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36" &#125;formdata=&#123;"i":key,"from":"AUTO","to":"AUTO","smartresult":"dict","client":"fanyideskweb","salt":"1533109653036","sign":"2ad8507b8a10dda31e7c0c1bcd3eef8d","doctype":"json","version":"2.1","keyfrom":"fanyi.web","action":"FY_BY_CLICKBUTTION","typoResult":"false" &#125;data= urllib.urlencode(formdata)request=urllib2.Request(url,data=data,headers=headers)print urllib2.urlopen(request).read() 其中的formdata就是我们抓包抓取的请求体里面的内容，请求体里面是以”&amp;”的形式分割的，在这里我们将数据提取出来转化成字典的形式，建立一个字典formdata. 还有要注意的一点，也是一个坑 请求url中的translate_o 需要写成translate才行，否则会报错，也不知道为什么，就是一个坑 运行程序，输入要翻译的文字，系统会输出一个Json格式的字符串 拿着个json字符串去解析，便可以看到我们想要的结果。有很多在线json解析的工具和网站我这里用的是www.json.cn 解析出来的结果如下12345678910111213&#123; "type":"ZH_CN2EN", "errorCode":0, "elapsedTime":1, "translateResult":[ [ &#123; "src":"我爱python", "tgt":"I love the python" &#125; ] ]&#125; 这样我们就完成了一个post请求的发送 处理Ajax加载的情况刚才我们爬取的页面是一个静态页面，所见及所得，但如果我们要爬取的是一个动态加载的页面呢？例如豆瓣电影网，在显示电影列表时就是根据你鼠标滑轮的滑动来加载的，如果你不往下滑动，下面的数据是不会有的。 但是我们只要记得，AJAX一般返回的是JSON,直接对AJAX地址进行post或get，就返回JSON数据了。 下面我们就拿一个例子来获取这种情况下的数据 下面我们就爬一下豆瓣的网站吧 作为爬虫的玩家，我们首先要关注的应该是数据的来源。 那么，我们开始了 像上一个例子一样，首先我们抓取了它的Url,抽取里面的数据建立字典，发送POST请求便可以获取我们想要的数据。 12345678910111213141516171819# -*- coding:UTF-8 -*-import urllibimport urllib2url="https://movie.douban.com/j/new_search_subjects?sort=T&amp;range=0,10&amp;tags=&amp;start=80"formdata=&#123; "sort":"T", "range":"0,10", "tags":"", "start":"80" &#125;headers=&#123;"User-Agent":"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36"&#125;data=urllib.urlencode(formdata)request=urllib2.Request(url,data=data,headers=headers)print urllib2.urlopen(request).read() 有些参数是我们可以手动去指定的，例如上面代码的range 、start等，这样我们就可以根据自己的需要来获取我们需要的数据的范围了 抓取的结果如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283"data":[ &#123; "directors":[ "宁浩" ], "rate":"8.3", "cover_x":578, "star":"40", "title":"疯狂的石头", "url":"https://movie.douban.com/subject/1862151/", "casts":[ "郭涛", "刘桦", "连晋", "黄渤", "徐峥" ], "cover":"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p712241453.jpg", "id":"1862151", "cover_y":764 &#125;, &#123; "directors":[ "大卫·芬奇" ], "rate":"8.7", "cover_x":1400, "star":"45", "title":"消失的爱人", "url":"https://movie.douban.com/subject/21318488/", "casts":[ "本·阿弗莱克", "裴淳华", "尼尔·帕特里克·哈里斯", "凯莉·库恩", "泰勒·派瑞" ], "cover":"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2221768894.jpg", "id":"21318488", "cover_y":2100 &#125;, &#123; "directors":[ "彼得·杰克逊" ], "rate":"8.9", "cover_x":1098, "star":"45", "title":"指环王1：魔戒再现", "url":"https://movie.douban.com/subject/1291571/", "casts":[ "伊莱贾·伍德", "西恩·奥斯汀", "伊恩·麦克莱恩", "维果·莫腾森", "奥兰多·布鲁姆" ], "cover":"https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1354436051.jpg", "id":"1291571", "cover_y":1500 &#125;, &#123; "directors":[ "陈可辛" ], "rate":"7.6", "cover_x":1017, "star":"40", "title":"中国合伙人", "url":"https://movie.douban.com/subject/11529526/", "casts":[ "黄晓明", "邓超", "佟大为", "杜鹃" ], "cover":"https://img1.doubanio.com/view/photo/s_ratio_poster/public/p1959304567.jpg", "id":"11529526", "cover_y":1500 &#125; .............等等等 ] &#125; 这样抓取一个ajax加载的页面也完成了 还有一个比较常用的操作是我们可以用cooike模拟用户登录我们知道，有些网站是需要我们登录过后才可以去访问的，没有登录的用户即便是输入了url地址，也会再次给你重定向到登陆的界面，这样你就不可能看到登录之后的数据了 要想用cooike模拟登录，我们只需要在请求头里面加入cooike的值就行了。至于怎么获取cooike的值，有很多的处理办法，目前只是用的最笨的那种，即抓包获取。 123456789101112131415161718192021import urllib2url = "http://www.renren.com/410043129/profile"headers = &#123; "Host" : "www.renren.com", "Connection" : "keep-alive", #"Upgrade-Insecure-Requests" : "1", "User-Agent" : "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36", "Accept" : "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", "Referer" : "http://www.renren.com/SysHome.do", #"Accept-Encoding" : "gzip, deflate, sdch", "Cookie" : "anonymid=ixrna3fysufnwv; _r01_=1; depovince=GW; jebe_key=f6fb270b-d06d-42e6-8b53-e67c3156aa7e%7Cc13c37f53bca9e1e7132d4b58ce00fa3%7C1484060607478%7C1%7C1484400895379; jebe_key=f6fb270b-d06d-42e6-8b53-e67c3156aa7e%7Cc13c37f53bca9e1e7132d4b58ce00fa3%7C1484060607478%7C1%7C1484400890914; JSESSIONID=abcX8s_OqSGsYeRg5vHMv; jebecookies=0c5f9b0d-03d8-4e6a-b7a9-3845d04a9870|||||; ick_login=8a429d6c-78b4-4e79-8fd5-33323cd9e2bc; _de=BF09EE3A28DED52E6B65F6A4705D973F1383380866D39FF5; p=0cedb18d0982741d12ffc9a0d93670e09; ap=327550029; first_login_flag=1; ln_uact=mr_mao_hacker@163.com; ln_hurl=http://hdn.xnimg.cn/photos/hdn521/20140529/1055/h_main_9A3Z_e0c300019f6a195a.jpg; t=56c0c522b5b068fdee708aeb1056ee819; societyguester=56c0c522b5b068fdee708aeb1056ee819; id=327550029; xnsid=5ea75bd6; loginfrom=syshome", "Accept-Language" : "zh-CN,zh;q=0.8,en;q=0.6",&#125;request = urllib2.Request(url, headers = headers)response = urllib2.urlopen(request)print response.read() 这样就可以模拟登录，访问登录后的界面了（这个是网上整理的demo,登进去的也不是我的页面） 以上就是用urllib2进行初级爬虫的一些总结，完成这些也远远算不上入门，总的来说，要做好一个比较漂亮的爬虫程序，还是需要一个不断积累的过程。 除了最后一个不能确定，前面的代码都是可以运行的。 今天的程序到此结束，大功告成！ 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(二)观察者模式]]></title>
    <url>%2F2018%2F07%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%BA%8C)-----%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式的定义： 观察者模式定义了对象的一对多依赖，这样一来，让一个对象改变状态时，它的所有依赖者都会收到通知并且会自动更新。 观察者模式的实例： 实例：建立一个气象站应用，利用WeatherData对象取得数据，并更新三个布告板：当前状况、气象统计和天气预报，当WeatherObject对象获得最新的测量数据时，三种布告板必须实时更新。 其实观察者模式可以从订报的角度来理解。 拿报纸的订阅来举例子： 报社的业务就是出版报纸 向某家报社订阅了报纸，只要他们有心得报纸出版，就会给你 送过来。只要你是他们的订户，你就会一直收到新报纸。 当你不再看报纸的时候，取消订阅，他们就不会再送报纸过来 只要报社还在运营，就会一直有人向他们订阅报纸或者取消订阅报纸。 定义观察者模式，类图 任何时候我们都可以增加新的观察者，因为主题唯一依赖的东西是一个实现了Observer接口的对象列表。所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的也可以在任何时候删除某些观察者。 有新类型的观察者出现时，主题的代码不需要修改。加入我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。 这里体现了我们的一个设计原则，即为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的相互依赖降到了最低。 基于以上的原则，我们可以得出我们对于该气象站的设计图： 下面我们用代码来实现气象站让我们从建立接口开始123456789Public interface Subject&#123;//这两个方法都需要一个观察者作为变量，该观察者是用来注册或者被删除的 Public void registerObserver(Observer o); Public void removeObserver(Observer o); //当主题状态改变时，这个方法会被调用，以通知所有的观察者 Public void notifyObservers();&#125; 1234567Public interface Observer&#123;//当气象观测值改变时，主题会把这些状态值当做方法的参数，传递给观察者。 Public void update(float temp,float humidity,float pressure);&#125; 123456Public interface DisplayElement&#123;//当布告板需要显示时，调用此方法。 Public void display();&#125; 在WeatherData中实现接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 Public class WeatherData implements Subject&#123; Private ArrayList observers; Private float temperature; Private float humidity; Private float pressure; Public WeatherData()&#123; Ovservers=new ArrayList(); &#125; Public void registreObserver(Observer o)&#123; Observers.add(o); &#125; Public void removeObserver(Observer o)&#123; int i=observers.indexOf(o); If(i&gt;=0)&#123; Observers.remove(i); &#125; &#125; Public void notifyObservers()&#123; for(int i=0;i&lt;observers.size();i++)&#123; Observer observer =(Observer) observers.get(i); Observer.update(temperature,humidity,pressure); &#125; &#125; Public void messurementsChanged()&#123; notifyObservers();&#125; Public void setMeasurements(float temperature,float humidity,float pressure) &#123; this.temperature=temperature; this.humidity=humidity; this.pressure=pressure; &#125; //WeatherData的其他方法 &#125; 现在让我们来建立布告板1234567891011121314151617181920212223Public class CurrentConditionsDisplay implements Observer ,DisplayElement &#123; Private float temperature; Private float humidity; Private Subject weatherData; //构造器需要weatherData对象作为注册之用 Public CurrentConditionsDisplay(Subjecy weatherData)&#123; this.weatherData =weatherData; weatherData.registerObserver(this); &#125; Public void update(float temperature,float humidity,float pressure) &#123; this.temperature=temperature; this.humidity=humidity; Display(); &#125; Public void display()&#123; System.out.println(“Current conditions: “+temperature +”℃ and ” +humidity+ “% humidity”) &#125; &#125; 最后我们可以建立一个测试程序1234567891011121314Public class WeatherStation &#123; Public static void main(String[] args) &#123; WeatherData weatherData=new WeatherData(); CurrentConditionsDisplay currentDisplay =new CurrentConditionsDisplay(weatherData); weatherData.setMeasurements(24,65,30.4f); weatherData.setMeasurements(25,64,29.4f); weatherData.setMeasurements(29,59,28.4f); &#125;&#125; 运行程序，即可看到输出结果 Current conditions: 24 ℃ and 65.0 % humidity Current conditions: 25 ℃ and 64.0 % humidity Current conditions: 29 ℃ and 59.0 % humidity 这样一个观察者模式的实例就完成了 java还有内置的观察者模式，Java API内有内置的观察者模式，java.util包内包含最基本的Observer接口与Observeable类，这和我们的Subject接口和 Observer接口很相似。 用我们的这个气象站的实现作比较，用java内置的观察者模式是有一点小的差异的，最明显的差异是WeatherData(也就是我们的主题)现在要扩展字Observable类，并继承一些添加、删除、通知观察者的方法。 下面是收集的一些比较好的有关于观察者模式的博文 1.观察者模式和Spring的结合https://blog.csdn.net/zlts000/article/details/53462181?ref=myread 2.观察者模式与事件监听机制https://blog.csdn.net/qq_22873427/article/details/77169781 3.设计模式–观察者模式的思考https://mrdear.cn/2018/04/20/experience/design_patterns--observer/ 4.设计模式 之 观察者 和监听器的区别https://blog.csdn.net/xiaoliuliu2050/article/details/73274985 5观察者模式和Spring的结合https://blog.csdn.net/zlts000/article/details/53462181?ref=myread 6.深入理解Javascript中的观察者模式https://www.jb51.net/article/106119.htm 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[urllib2爬虫初级 (一)]]></title>
    <url>%2F2018%2F07%2F31%2Furllib2%E7%88%AC%E8%99%AB%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[最近由于项目需要，难得需要获取网络上的一些数据，手动获取的话效率又太低，所以最近想要接触一下爬虫。因为有一小部分java开发的经验，所以入门python并不是特别困难，大概看了半天的官方文档后，决定采用python爬虫来获取相关的数据。 python 现在已经有了几个比较成熟的爬虫框架，如scrapy等，由于刚开始接触python以及python爬虫，我决定从比较底层的urllib2 入手。 爬虫，简单说来就是通过程序模拟浏览器请求站点的行为，把站点返回的HTML代码/JSON数据/二进制数据（图片、视频） 爬到本地，进而提取自己需要的数据，存放起来使用。 我使用爬虫的目的很简单，就是获取数据。 爬虫的一般流程为1.发起请求 也就是模仿浏览器，发送一个Request，一般包含请求头和请求体的部分。2.获取响应的内容3.解析内容4.保存数据(可以存在mysql这种关系型数据库中，但现在非常火的分布式爬虫经常使用redis、mogodb等非关系型数据库，极大提高了数据处理的性能) 同时推荐一个比较好用的抓包工具Fiddler 还有谷歌的代理请求插件Proxy SwitchyOmega 初级练习爬虫的话基本上都是结合着这两个工具来的 然后自己就跟着做了一个用url2初级爬虫的练习，可以爬取百度贴吧的一些信息，并保存下来为html文件（刚开始入门，并没有考虑到反 反爬虫） 下面安利一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding:utf-8 -*-import urllibimport urllib2def loadPage(url, filename): """ 作用：根据url发送请求，获取服务器响应文件 url: 需要爬取的url地址 filename : 处理的文件名 """ print "正在下载 " + filename headers = &#123;"User-Agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"&#125; request = urllib2.Request(url, headers = headers) return urllib2.urlopen(request).read()def writePage(html, filename): """ 作用：将html内容写入到本地 html：服务器相应文件内容 """ print "正在保存 " + filename # 文件写入 with open(filename, "w") as f: f.write(html) print "-" * 30def tiebaSpider(url, beginPage, endPage): """ 作用：贴吧爬虫调度器，负责组合处理每个页面的url url : 贴吧url的前部分 beginPage : 起始页 endPage : 结束页 """ for page in range(beginPage, endPage + 1): pn = (page - 1) * 50 filename = "the" + str(page) + ".html" fullurl = url + "&amp;pn=" + str(pn) #print fullurl html = loadPage(fullurl, filename) #print html writePage(html, filename) print "谢谢使用"if __name__ == "__main__": kw = raw_input("请输入需要爬取的贴吧名:") beginPage = int(raw_input("请输入起始页：")) endPage = int(raw_input("请输入结束页：")) url = "http://tieba.baidu.com/f?" key = urllib.urlencode(&#123;"kw": kw&#125;) fullurl = url + key tiebaSpider(fullurl, beginPage, endPage) 下面是运行的效果首先你要输入你想要爬取的关键信息，例如我想爬python吧的一些内容，我就直接输入python了。接下来输入要爬取的页码的范围，例如这里我输入的是1-1,即我只爬取第一页。 爬取成功之后便会生成一个html文件，里面便存放了你所要爬取的内容。 然后一个简单的贴吧爬虫就完成了。。。 再次强调这里使用的是最基本的爬虫，并没有考虑到个别网站的反爬虫措施，也没有分布式的存储，仅仅是通过一个小程序完成爬虫原理的小入门。 当然java也有比较成熟的爬虫封装，例如使用HttpClient的jar包等来实现基本的http操作。 但比较而来，python的爬虫更为简洁，而java爬虫比较好维护。 总而言之，爬虫之路还有走很久，一些东西需要自己不断摸索，只苦逼做项目数据也得自己来搞 orz 太肝了，做完这个记录就滚去睡觉吧 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式思考(一)策略模式]]></title>
    <url>%2F2018%2F07%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83(%E4%B8%80)-----%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(1)%2F</url>
    <content type="text"><![CDATA[策略模式的定义：策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。 OO基础 抽象 封装 多态 继承 OO原则 封装变化 多用组合，少用继承 针对接口编程，不针对实现编程 OO模式 本篇介绍的是策略模式 策略模式的实例： 下面举一个Duck类的实例来说明策略模式 Duck(鸭子)类是所有类的基类 1234567891011121314151617181920212223242526272829 Public abstract class Duck &#123; //为行为接口类型声明两个引用变量，所有鸭子子类(在同一个package中)都继承它们。 FlyBehavior flyBehavior; QuackBehavior quackBehavior; Public Duck() &#123;&#125; Public abstract void display(); Public void performFly()&#123; //委托给行为类 flyBehavior.fly(); &#125; Public void performQuack()&#123; quackBehavior.quack(); &#125; Public void swim()&#123; System.out.println(“所有的鸭子都会游泳”); &#125; &#125; ##飞行行为接口 123456789public interface FlyBehavior &#123; public void fly(); &#125; 12345678910111213141516171819 //这是飞行类的实现，适用于会飞的鸭子Public class FlyWithWings implements FlyBehavior&#123; Public void fly()&#123; System.out.println(“I’m flying!!”); &#125;&#125;//这也是飞行类的实现，给不会飞的鸭子用，如橡皮鸭等Public class FlyNoWay implements FlyBehavior&#123; Public void fly()&#123; System.out.println(“我不会飞”); &#125;&#125; ## QuackBehavior 接口及其实现 12 Public interface QuackBehavior { Public void quack(); } Public class Quack implements QuackBehavior{ Public void quack(){ System.out.println(“Quack”); } } Public class MuteQuack implements QuackBehavior{ Public void quack(){ System.out.println(“&lt;&lt; Silence &gt;&gt;”); } } Public class Squeak implements QuackBehavior{ Public void quack() { System.out.println(“Squeak”); } } 12##下面我们给这些Duck动态设定行为##在Duck 类中加入两个新的方法 Public void setFlyBehavior (FlyBehavior fb) { flyBehavior=fb; } Public void setQuackBehavior (QuackBehavior qb) { quackBehavior =qb; }1##创建一个新的鸭子,模型鸭。 Public class ModelDuck extends Duck{ Public ModelDuck(){ flyBehavior =new FlyNoWay(); quackBehavior=new Quack(); } Public void display(){ System.out.println(“我是模型鸭”); } } 1##建立一个新的FlyBehavior 类型 Public class FlyRocketPowered implements FlyBehavior { Public void fly(){ System.out.println(“我是火箭驱动飞行的”); } } 1##测试类进行测试 Public class TestDuck(){ Public static void main(String[] args){ Duck model=new ModelDuck(); //第一次调用performFly()会被委托给flyBehavior对象，也就是FlyNoWay的实例，该对象 //是在模型鸭构造器中设置的 Model.performFly(); //这里调用继承来的setter方法，给它指定特定的飞行行为 Model.setFlyBehavior(new FlyRocketPowered()); Model.performFly(); } }` 测试结果控制台输出我不会飞 我是火箭驱动飞行的 下面是相关类和接口的关系图 收集的一些写的有关策略模式的比较好的博客 1.【设计模式–spring源码中使用策略模式（Strategy Pattern)】 https://blog.csdn.net/lzwglory/article/details/51822442 2.【策略模式和Spring的结合在项目中的应用】 https://blog.csdn.net/zlts000/article/details/54754789 3.【设计模式（一）策略模式】 https://www.cnblogs.com/jenkinschan/p/5645300.html 4.【深度剖析策略模式（包括该模式在JDK中的应用）】 https://www.cnblogs.com/lewis0077/p/5133812.html 作者：lhsjohn]]></content>
      <categories>
        <category>学习</category>
        <category>java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《西虹市首富》--爆笑与浪漫的融合体]]></title>
    <url>%2F2018%2F07%2F29%2F%E3%80%8A%E8%A5%BF%E8%99%B9%E5%B8%82%E9%A6%96%E5%AF%8C%E3%80%8B---%E7%88%86%E7%AC%91%E4%B8%8E%E6%B5%AA%E6%BC%AB%E7%9A%84%E8%9E%8D%E5%90%88%E4%BD%93%2F</url>
    <content type="text"><![CDATA[在家闲着无聊，无意之间看到了手机上推荐的最近比较火的电影《西虹市首富》。西红柿首付？听起来谐音就挺搞笑，潜意识感觉应该挺不错的一部电影。 “可以去看看，颇具沈腾风格的一部电影。”朋友曾这么给我推荐过。 确实啊，在家也确实无聊，虽然刚买的书已经到了，但是最近浮躁的心却平静不下来，去看吧。 老天并不友好，当我换好衣服准备出门的时候，天就有些阴沉沉的了，因为家电影院不算特别远，“算了，直接去吧”。 “假如突然给你十亿，让你在一个月花完，并且有一部分特殊的要求要满足，你会怎么做？” 电影开篇，十个亿的噱头就足以证实了这部电影的脑洞。 一个有梦想的穷人突然获得十亿，整个故事都像是一场幻想的梦境，简直就是走了“狗屎运”，电影开端给了观众极强的代入感。 在我看来，这部电影能够引人发笑的原因无非就是它的不可预测性的想象，脑洞很大，反转很多，但是仔细去想的话你又会觉得它是合乎情理的，沈腾式的幽默确实给大家带来了不少的小点。 另外一个十足的亮点是王力宏的出场，带翻了全场的节奏，“一个我 需要梦想 需要方向 需要眼泪 更需要 一个人来 点亮天的黑 ”，王力宏的倾情演奏与欢笑惊喜的场面完美融合，其实给人营来了一种暖暖的感动氛围。 整部电影吧，可以说是笑声与浪漫的融合，不乏空奇的想象，也不缺浪漫的爱情。猛烈的抨击了一部分人金钱至上的低俗心态，钱买不来感情，当金钱与人性二选一的时候，你的决定又会是什么？ 爆笑以及浪漫和思考，一样都不能少的，《西虹市首富》这部电影，带给我们的不仅仅是欢笑。 作者：lhsjohn]]></content>
      <categories>
        <category>观后感</category>
        <category>影评</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
        <tag>影评</tag>
        <tag>喜剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下Eclipse搭建python环境]]></title>
    <url>%2F2018%2F07%2F29%2FWindows%E4%B8%8BEclipse%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在Eclipse上安装和搭建Python开发环境需要以下五步完成： 1.下载最新的Eclipse安装包,我是基于Python版本python-3.6.4。python-3.6.4要求的Eclipse高版本，我选择了最新的Eclipse版本：eclipse-java-oxygen-2-win32-x86_64.zip下载eclipse-java-oxygen-2-win32-x86_64.zip，可以到Eclipse官方网站：https://www.eclipse.org/downloads/eclipse-packages/在这个页面选择版本系列：Eclipse IDE for Java Developers 2.配置Eclipse开发环境。我下载的是zip包，解压到一个目录E:\developer\eclipse： 3.在Eclipse中添加Python的开发部署软件系统。Eclipse -&gt; Help -&gt; Install New SoftWare -&gt; Add ，在弹出的框添加如图所示的内容： 然后选中python IDE一路next等待下载安装完毕 4.下载最新的Python SDK开发包。Python最新的开发包在官方网站可以下载，链接：https://www.python.org/downloads/release把zip压缩包下载完成后解压到一个文件目录下，比如： 5.此时开始正式写Python代码，写一个经典的hello world。Eclipse中，选择File -&gt; New -&gt; Other，然后会弹出一系列代码项目选择项，选择PyDev Project，然后点击Next。以上配置完成后，就可以正式写Python代码了。新建一个File -&gt; New -&gt; Other -&gt; PyDev Project，然后选中该项目，鼠标右键 -&gt; New -&gt; PyDev Module，在弹出的框中写好包名和Name 然后点击左上角的绿色按钮，选中Hello Test.py就可以看到成功运行出helloWorld了]]></content>
      <categories>
        <category>学习</category>
        <category>python</category>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>技术</tag>
        <tag>Python环境搭建</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青春]]></title>
    <url>%2F2018%2F07%2F28%2F%E9%9D%92%E6%98%A5%2F</url>
    <content type="text"><![CDATA[青春不是年华，而是心境，青春不是桃面、丹唇、柔膝，而是深沉的意志、恢弘的想象、炽热的感情；青春是生命的深泉在涌流。青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生有之，六旬男子则更多见。年岁有加，并非垂老；理想丢弃，方堕暮年。岁月悠悠，衰微只及肌肤，热忱抛却，颓唐必至灵魂。忧烦、惶恐、丧失自信，定使心灵扭曲，一起如灰。无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人的心灵应如浩渺瀚海，只要不断接受美好、希望、欢乐、勇气和力量的信号，你无不青春永驻，风华长存。一旦心海枯竭，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即便年方二十，实已垂垂老矣，然则只要虚怀若谷，让喜悦达观、仁爱充盈期间，你就有望在八十高龄告别尘寰时仍觉年轻。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始学习vue.js了]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%BC%80%E5%90%AF%E6%88%91%E7%9A%84vue%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[作为一个刚放暑假的大二技术小白，在家也只是无聊的刷刷手机看看电视等。 一天天的生活确实循环枯燥。 不如学习 早就听说了vue的强大之处，虽然还不怎么流行但自己也早就想去仔细的研究一番那么这个暑假便是一个很好的机会去接触它了解它 [文档链接]：https://cn.vuejs.org/v2/guide/#%E8%B5%B7%E6%AD%A5 作者：lhsjohn]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2018%2F07%2F28%2FThe%20first%20one%2F</url>
    <content type="text"><![CDATA[这算是我刚刚对hexo的一个基本的入门吧，俗话说的好”九尺之台，起于垒土.” 对于自己刚刚搭建的这个比较简单的博客而言，我更把它当做我学习和积累知识的一个平台，是一个起点，以后的许多功能需要不断去完善，希望自己能够加油！ 作者：lhsjohn]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>心得</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
